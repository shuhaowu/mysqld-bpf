struct typedef __va_list_tag __va_list_tag {
	unsigned int               gp_offset;            /*     0     4 */
	unsigned int               fp_offset;            /*     4     4 */
	void *                     overflow_arg_area;    /*     8     8 */
	void *                     reg_save_area;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct _G_fpos64_t {
	__off64_t                  __pos;                /*     0     8 */
	__mbstate_t                __state;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct _IO_FILE {
	int                        _flags;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     _IO_read_ptr;         /*     8     8 */
	char *                     _IO_read_end;         /*    16     8 */
	char *                     _IO_read_base;        /*    24     8 */
	char *                     _IO_write_base;       /*    32     8 */
	char *                     _IO_write_ptr;        /*    40     8 */
	char *                     _IO_write_end;        /*    48     8 */
	char *                     _IO_buf_base;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     _IO_buf_end;          /*    64     8 */
	char *                     _IO_save_base;        /*    72     8 */
	char *                     _IO_backup_base;      /*    80     8 */
	char *                     _IO_save_end;         /*    88     8 */
	class _IO_marker *         _markers;             /*    96     8 */
	class _IO_FILE *           _chain;               /*   104     8 */
	int                        _fileno;              /*   112     4 */
	int                        _flags2;              /*   116     4 */
	__off_t                    _old_offset;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	short unsigned int         _cur_column;          /*   128     2 */
	signed char                _vtable_offset;       /*   130     1 */
	char                       _shortbuf[1];         /*   131     1 */

	/* XXX 4 bytes hole, try to pack */

	_IO_lock_t *               _lock;                /*   136     8 */
	__off64_t                  _offset;              /*   144     8 */
	class _IO_codecvt *        _codecvt;             /*   152     8 */
	class _IO_wide_data *      _wide_data;           /*   160     8 */
	class _IO_FILE *           _freeres_list;        /*   168     8 */
	void *                     _freeres_buf;         /*   176     8 */
	size_t                     __pad5;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        _mode;                /*   192     4 */
	char                       _unused2[20];         /*   196    20 */

	/* size: 216, cachelines: 4, members: 29 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct timeval {
	__time_t                   tv_sec;               /*     0     8 */
	__suseconds_t              tv_usec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct timespec {
	__time_t                   tv_sec;               /*     0     8 */
	__syscall_slong_t          tv_nsec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct __pthread_internal_list {
	class __pthread_internal_list * __prev;          /*     0     8 */
	class __pthread_internal_list * __next;          /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct __pthread_mutex_s {
	int                        __lock;               /*     0     4 */
	unsigned int               __count;              /*     4     4 */
	int                        __owner;              /*     8     4 */
	unsigned int               __nusers;             /*    12     4 */
	int                        __kind;               /*    16     4 */
	short int                  __spins;              /*    20     2 */
	short int                  __elision;            /*    22     2 */
	__pthread_list_t           __list;               /*    24    16 */

	/* size: 40, cachelines: 1, members: 8 */
	/* last cacheline: 40 bytes */
};
struct __pthread_rwlock_arch_t {
	unsigned int               __readers;            /*     0     4 */
	unsigned int               __writers;            /*     4     4 */
	unsigned int               __wrphase_futex;      /*     8     4 */
	unsigned int               __writers_futex;      /*    12     4 */
	unsigned int               __pad3;               /*    16     4 */
	unsigned int               __pad4;               /*    20     4 */
	int                        __cur_writer;         /*    24     4 */
	int                        __shared;             /*    28     4 */
	signed char                __rwelision;          /*    32     1 */
	unsigned char              __pad1[7];            /*    33     7 */
	long unsigned int          __pad2;               /*    40     8 */
	unsigned int               __flags;              /*    48     4 */

	/* size: 56, cachelines: 1, members: 12 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct __pthread_cond_s {
	union {
		long long unsigned int     __wseq;               /*     0     8 */
		struct {
			unsigned int       __low;                /*     0     4 */
			unsigned int       __high;               /*     4     4 */
		} __wseq32;                                      /*     0     8 */
	};

	union {
		long long unsigned int     __g1_start;           /*     0     8 */
		struct {
			unsigned int       __low;                /*     0     4 */
			unsigned int       __high;               /*     4     4 */
		} __g1_start32;                                  /*     0     8 */
	};

	union {
		long long unsigned int __wseq;           /*     0     8 */
		struct {
			unsigned int __low;              /*     0     4 */
			unsigned int __high;             /*     4     4 */
		} __wseq32;                              /*     0     8 */
	};                                               /*     0     8 */
	union {
		long long unsigned int __g1_start;       /*     8     8 */
		struct {
			unsigned int __low;              /*     8     4 */
			unsigned int __high;             /*    12     4 */
		} __g1_start32;                          /*     8     8 */
	};                                               /*     8     8 */
	unsigned int               __g_refs[2];          /*    16     8 */
	unsigned int               __g_size[2];          /*    24     8 */
	unsigned int               __g1_orig_size;       /*    32     4 */
	unsigned int               __wrefs;              /*    36     4 */
	unsigned int               __g_signals[2];       /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
union pthread_attr_t {
	char                       __size[56];         /*     0    56 */
	long int                   __align;            /*     0     8 */
};
struct tm {
	int                        tm_sec;               /*     0     4 */
	int                        tm_min;               /*     4     4 */
	int                        tm_hour;              /*     8     4 */
	int                        tm_mday;              /*    12     4 */
	int                        tm_mon;               /*    16     4 */
	int                        tm_year;              /*    20     4 */
	int                        tm_wday;              /*    24     4 */
	int                        tm_yday;              /*    28     4 */
	int                        tm_isdst;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   tm_gmtoff;            /*    40     8 */
	const char  *              tm_zone;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct lconv {
	char *                     decimal_point;        /*     0     8 */
	char *                     thousands_sep;        /*     8     8 */
	char *                     grouping;             /*    16     8 */
	char *                     int_curr_symbol;      /*    24     8 */
	char *                     currency_symbol;      /*    32     8 */
	char *                     mon_decimal_point;    /*    40     8 */
	char *                     mon_thousands_sep;    /*    48     8 */
	char *                     mon_grouping;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     positive_sign;        /*    64     8 */
	char *                     negative_sign;        /*    72     8 */
	char                       int_frac_digits;      /*    80     1 */
	char                       frac_digits;          /*    81     1 */
	char                       p_cs_precedes;        /*    82     1 */
	char                       p_sep_by_space;       /*    83     1 */
	char                       n_cs_precedes;        /*    84     1 */
	char                       n_sep_by_space;       /*    85     1 */
	char                       p_sign_posn;          /*    86     1 */
	char                       n_sign_posn;          /*    87     1 */
	char                       int_p_cs_precedes;    /*    88     1 */
	char                       int_p_sep_by_space;   /*    89     1 */
	char                       int_n_cs_precedes;    /*    90     1 */
	char                       int_n_sep_by_space;   /*    91     1 */
	char                       int_p_sign_posn;      /*    92     1 */
	char                       int_n_sign_posn;      /*    93     1 */

	/* size: 96, cachelines: 2, members: 24 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
struct MYSQL_LEX_STRING {
	char *                     str;                  /*     0     8 */
	size_t                     length;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct MYSQL_LEX_CSTRING {
	const char  *              str;                  /*     0     8 */
	size_t                     length;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct MY_UNICASE_CHARACTER {
	uint32                     toupper;              /*     0     4 */
	uint32                     tolower;              /*     4     4 */
	uint32                     sort;                 /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct MY_UNICASE_INFO {
	my_wc_t                    maxchar;              /*     0     8 */
	const MY_UNICASE_CHARACTER  * * page;            /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct MY_UNI_CTYPE {
	uchar                      pctype;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	uchar *                    ctype;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct MY_UNI_IDX {
	uint16                     from;                 /*     0     2 */
	uint16                     to;                   /*     2     2 */

	/* XXX 4 bytes hole, try to pack */

	const uchar  *             tab;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct CHARSET_INFO {
	uint                       number;               /*     0     4 */
	uint                       primary_number;       /*     4     4 */
	uint                       binary_number;        /*     8     4 */
	uint                       state;                /*    12     4 */
	const char  *              csname;               /*    16     8 */
	const char  *              name;                 /*    24     8 */
	const char  *              comment;              /*    32     8 */
	const char  *              tailoring;            /*    40     8 */
	class Coll_param *         coll_param;           /*    48     8 */
	const uchar  *             ctype;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	const uchar  *             to_lower;             /*    64     8 */
	const uchar  *             to_upper;             /*    72     8 */
	const uchar  *             sort_order;           /*    80     8 */
	class MY_UCA_INFO *        uca;                  /*    88     8 */
	const uint16  *            tab_to_uni;           /*    96     8 */
	const MY_UNI_IDX  *        tab_from_uni;         /*   104     8 */
	const MY_UNICASE_INFO  *   caseinfo;             /*   112     8 */
	const class lex_state_maps_st  * state_maps;     /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	const uchar  *             ident_map;            /*   128     8 */
	uint                       strxfrm_multiply;     /*   136     4 */
	uchar                      caseup_multiply;      /*   140     1 */
	uchar                      casedn_multiply;      /*   141     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       mbminlen;             /*   144     4 */
	uint                       mbmaxlen;             /*   148     4 */
	uint                       mbmaxlenlen;          /*   152     4 */

	/* XXX 4 bytes hole, try to pack */

	my_wc_t                    min_sort_char;        /*   160     8 */
	my_wc_t                    max_sort_char;        /*   168     8 */
	uchar                      pad_char;             /*   176     1 */
	bool                       escape_with_backslash_is_dangerous; /*   177     1 */
	uchar                      levels_for_compare;   /*   178     1 */

	/* XXX 5 bytes hole, try to pack */

	MY_CHARSET_HANDLER *       cset;                 /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	MY_COLLATION_HANDLER *     coll;                 /*   192     8 */
	enum Pad_attribute         pad_attribute;        /*   200     4 */

	/* size: 208, cachelines: 4, members: 33 */
	/* sum members: 193, holes: 3, sum holes: 11 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct MY_CHARSET_LOADER {
	uint                       errcode;              /*     0     4 */
	char                       errarg[192];          /*     4   192 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	void *                     (*once_alloc)(size_t); /*   200     8 */
	void *                     (*mem_malloc)(size_t); /*   208     8 */
	void *                     (*mem_realloc)(void *, size_t); /*   216     8 */
	void                       (*mem_free)(void *);  /*   224     8 */
	void                       (*reporter)(enum loglevel, uint, ...); /*   232     8 */
	int                        (*add_collation)(class CHARSET_INFO *); /*   240     8 */

	/* size: 248, cachelines: 4, members: 8 */
	/* sum members: 244, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct MY_COLLATION_HANDLER {
	bool                       (*init)(class CHARSET_INFO *, MY_CHARSET_LOADER *); /*     0     8 */
	void                       (*uninit)(class CHARSET_INFO *); /*     8     8 */
	int                        (*strnncoll)(const class CHARSET_INFO  *, const uchar  *, size_t, const uchar  *, size_t, bool); /*    16     8 */
	int                        (*strnncollsp)(const class CHARSET_INFO  *, const uchar  *, size_t, const uchar  *, size_t); /*    24     8 */
	size_t                     (*strnxfrm)(const class CHARSET_INFO  *, uchar *, size_t, uint, const uchar  *, size_t, uint); /*    32     8 */
	size_t                     (*strnxfrmlen)(const class CHARSET_INFO  *, size_t); /*    40     8 */
	bool                       (*like_range)(const class CHARSET_INFO  *, const char  *, size_t, char, char, char, size_t, char *, char *, size_t *, size_t *); /*    48     8 */
	int                        (*wildcmp)(const class CHARSET_INFO  *, const char  *, const char  *, const char  *, const char  *, int, int, int); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        (*strcasecmp)(const class CHARSET_INFO  *, const char  *, const char  *); /*    64     8 */
	uint                       (*strstr)(const class CHARSET_INFO  *, const char  *, size_t, const char  *, size_t, my_match_t *, uint); /*    72     8 */
	void                       (*hash_sort)(const class CHARSET_INFO  *, const uchar  *, size_t, uint64 *, uint64 *); /*    80     8 */
	bool                       (*propagate)(const class CHARSET_INFO  *, const uchar  *, size_t); /*    88     8 */

	/* size: 96, cachelines: 2, members: 12 */
	/* last cacheline: 32 bytes */
};
struct MY_CHARSET_HANDLER {
	bool                       (*init)(class CHARSET_INFO *, MY_CHARSET_LOADER *); /*     0     8 */
	uint                       (*ismbchar)(const class CHARSET_INFO  *, const char  *, const char  *); /*     8     8 */
	uint                       (*mbcharlen)(const class CHARSET_INFO  *, uint); /*    16     8 */
	size_t                     (*numchars)(const class CHARSET_INFO  *, const char  *, const char  *); /*    24     8 */
	size_t                     (*charpos)(const class CHARSET_INFO  *, const char  *, const char  *, size_t); /*    32     8 */
	size_t                     (*well_formed_len)(const class CHARSET_INFO  *, const char  *, const char  *, size_t, int *); /*    40     8 */
	size_t                     (*lengthsp)(const class CHARSET_INFO  *, const char  *, size_t); /*    48     8 */
	size_t                     (*numcells)(const class CHARSET_INFO  *, const char  *, const char  *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	my_charset_conv_mb_wc      mb_wc;                /*    64     8 */
	my_charset_conv_wc_mb      wc_mb;                /*    72     8 */
	int                        (*ctype)(const class CHARSET_INFO  *, int *, const uchar  *, const uchar  *); /*    80     8 */
	size_t                     (*caseup_str)(const class CHARSET_INFO  *, char *); /*    88     8 */
	size_t                     (*casedn_str)(const class CHARSET_INFO  *, char *); /*    96     8 */
	my_charset_conv_case       caseup;               /*   104     8 */
	my_charset_conv_case       casedn;               /*   112     8 */
	size_t                     (*snprintf)(const class CHARSET_INFO  *, char *, size_t, const char  *, ...); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	size_t                     (*long10_to_str)(const class CHARSET_INFO  *, char *, size_t, int, long int); /*   128     8 */
	size_t                     (*longlong10_to_str)(const class CHARSET_INFO  *, char *, size_t, int, longlong); /*   136     8 */
	void                       (*fill)(const class CHARSET_INFO  *, char *, size_t, int); /*   144     8 */
	long int                   (*strntol)(const class CHARSET_INFO  *, const char  *, size_t, int, const char  * *, int *); /*   152     8 */
	ulong                      (*strntoul)(const class CHARSET_INFO  *, const char  *, size_t, int, const char  * *, int *); /*   160     8 */
	longlong                   (*strntoll)(const class CHARSET_INFO  *, const char  *, size_t, int, const char  * *, int *); /*   168     8 */
	ulonglong                  (*strntoull)(const class CHARSET_INFO  *, const char  *, size_t, int, const char  * *, int *); /*   176     8 */
	double                     (*strntod)(const class CHARSET_INFO  *, const char  *, size_t, const char  * *, int *); /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	longlong                   (*strtoll10)(const class CHARSET_INFO  *, const char  *, const char  * *, int *); /*   192     8 */
	ulonglong                  (*strntoull10rnd)(const class CHARSET_INFO  *, const char  *, size_t, int, const char  * *, int *); /*   200     8 */
	size_t                     (*scan)(const class CHARSET_INFO  *, const char  *, const char  *, int); /*   208     8 */

	/* size: 216, cachelines: 4, members: 27 */
	/* last cacheline: 24 bytes */
};
struct lex_state_maps_st {
	enum my_lex_states         main_map[256];        /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	enum hint_lex_char_classes hint_map[256];        /*   256   256 */

	/* size: 512, cachelines: 8, members: 2 */
};
struct decimal_t {
	int                        intg;                 /*     0     4 */
	int                        frac;                 /*     4     4 */
	int                        len;                  /*     8     4 */
	bool                       sign;                 /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	decimal_digit_t *          buf;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct mysql_zlib_compress_context {
	unsigned int               compression_level;    /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct mysql_zstd_compress_context {
	ZSTD_CCtx *                cctx;                 /*     0     8 */
	ZSTD_DCtx *                dctx;                 /*     8     8 */
	unsigned int               compression_level;    /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct mysql_compress_context {
	union {
		mysql_zlib_compress_context zlib_ctx;            /*     0     4 */
		mysql_zstd_compress_context zstd_ctx;            /*     0    24 */
	};

	enum enum_compression_algorithm algorithm;       /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		mysql_zlib_compress_context zlib_ctx;    /*     8     4 */
		mysql_zstd_compress_context zstd_ctx;    /*     8    24 */
	} u;                                             /*     8    24 */

	/* size: 32, cachelines: 1, members: 2 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct PSI_instr {
	bool                       m_enabled;            /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct sockaddr {
	sa_family_t                sa_family;            /*     0     2 */
	char                       sa_data[14];          /*     2    14 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct sockaddr_storage {
	sa_family_t                ss_family;            /*     0     2 */
	char                       __ss_padding[118];    /*     2   118 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	long unsigned int          __ss_align;           /*   120     8 */

	/* size: 128, cachelines: 2, members: 3 */
};
struct mysql_cond_t {
	native_cond_t              m_cond;               /*     0    48 */
	class PSI_cond *           m_psi;                /*    48     8 */

	/* size: 56, cachelines: 1, members: 2 */
	/* last cacheline: 56 bytes */
};
struct PSI_cond : PSI_instr {
	/* struct PSI_instr           <ancestor>; */     /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */

	/* BRAIN FART ALERT! 1 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 8 bits */
};
struct my_mutex_t {
	union u {
		native_mutex_t             m_native;             /*     0    40 */
		class safe_mutex_t *       m_safe_ptr;           /*     0     8 */
	};

	union u                    m_u;                  /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct mysql_mutex_t {
	my_mutex_t                 m_mutex;              /*     0    40 */
	class PSI_mutex *          m_psi;                /*    40     8 */
	void mysql_mutex_t(class mysql_mutex_t *);


	/* size: 48, cachelines: 1, members: 2 */
	/* last cacheline: 48 bytes */
};
struct PSI_mutex : PSI_instr {
	/* struct PSI_instr           <ancestor>; */     /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */

	/* BRAIN FART ALERT! 1 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 8 bits */
};
struct PSI_file_info_v1 {
	PSI_file_key *             m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */
	int                        m_volatility;         /*    20     4 */
	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct PSI_file_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */
	enum PSI_file_operation    m_operation;          /*     4     4 */
	class PSI_file *           m_file;               /*     8     8 */
	const char  *              m_name;               /*    16     8 */
	void *                     m_class;              /*    24     8 */
	class PSI_thread *         m_thread;             /*    32     8 */
	size_t                     m_number_of_bytes;    /*    40     8 */
	long long unsigned int     m_timer_start;        /*    48     8 */
	long long unsigned int     (*m_timer)(void);     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void *                     m_wait;               /*    64     8 */

	/* size: 72, cachelines: 2, members: 10 */
	/* last cacheline: 8 bytes */
};
struct PSI_memory_info_v1 {
	PSI_memory_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */
	int                        m_volatility;         /*    20     4 */
	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct PSI_stage_progress_v1 {
	long long unsigned int     m_work_completed;     /*     0     8 */
	long long unsigned int     m_work_estimated;     /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PSI_stage_info_v1 {
	PSI_stage_key              m_key;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 24, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct MY_TMPDIR {
	char * *                   list;                 /*     0     8 */
	uint                       cur;                  /*     8     4 */
	uint                       max;                  /*    12     4 */
	struct mysql_mutex_t       mutex;                /*    16    48 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct IO_CACHE {
	my_off_t                   pos_in_file;          /*     0     8 */
	my_off_t                   end_of_file;          /*     8     8 */
	uchar *                    read_pos;             /*    16     8 */
	uchar *                    read_end;             /*    24     8 */
	uchar *                    buffer;               /*    32     8 */
	uchar *                    request_pos;          /*    40     8 */
	uchar *                    write_buffer;         /*    48     8 */
	uchar *                    append_read_pos;      /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uchar *                    write_pos;            /*    64     8 */
	uchar *                    write_end;            /*    72     8 */
	uchar * *                  current_pos;          /*    80     8 */
	uchar * *                  current_end;          /*    88     8 */
	struct mysql_mutex_t       append_buffer_lock;   /*    96    48 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class IO_CACHE_SHARE *     share;                /*   144     8 */
	int                        (*read_function)(class IO_CACHE *, uchar *, size_t); /*   152     8 */
	int                        (*write_function)(class IO_CACHE *, const uchar  *, size_t); /*   160     8 */
	enum cache_type            type;                 /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	IO_CACHE_CALLBACK          pre_read;             /*   176     8 */
	IO_CACHE_CALLBACK          post_read;            /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	IO_CACHE_CALLBACK          pre_close;            /*   192     8 */
	ulong                      disk_writes;          /*   200     8 */
	void *                     arg;                  /*   208     8 */
	char *                     file_name;            /*   216     8 */
	char *                     dir;                  /*   224     8 */
	char *                     prefix;               /*   232     8 */
	File                       file;                 /*   240     4 */
	PSI_file_key               file_key;             /*   244     4 */
	bool                       seek_not_done;        /*   248     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        error;                /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	size_t                     buffer_length;        /*   256     8 */
	size_t                     read_length;          /*   264     8 */
	myf                        myflags;              /*   272     4 */
	bool                       alloced_buffer;       /*   276     1 */

	/* XXX 3 bytes hole, try to pack */

	class Stream_cipher *      m_encryptor;          /*   280     8 */
	class Stream_cipher *      m_decryptor;          /*   288     8 */
	bool                       disk_sync;            /*   296     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       disk_sync_delay;      /*   300     4 */

	/* size: 304, cachelines: 5, members: 37 */
	/* sum members: 291, holes: 4, sum holes: 13 */
	/* last cacheline: 48 bytes */
};
struct IO_CACHE_SHARE {
	struct mysql_mutex_t       mutex;                /*     0    48 */
	struct mysql_cond_t        cond;                 /*    48    56 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	struct mysql_cond_t        cond_writer;          /*   104    56 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	my_off_t                   pos_in_file;          /*   160     8 */
	class IO_CACHE *           source_cache;         /*   168     8 */
	uchar *                    buffer;               /*   176     8 */
	uchar *                    read_end;             /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        running_threads;      /*   192     4 */
	int                        total_threads;        /*   196     4 */
	int                        error;                /*   200     4 */

	/* size: 208, cachelines: 4, members: 10 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct PSI_cond_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_data_lock_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_error_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_file_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_idle_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_mdl_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_memory_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_mutex_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_rwlock_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_socket_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_stage_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_statement_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_system_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_table_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_thread_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_transaction_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_tls_channel_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct mysql_malloc_service_st {
	mysql_malloc_t             mysql_malloc;         /*     0     8 */
	mysql_realloc_t            mysql_realloc;        /*     8     8 */
	mysql_claim_t              mysql_claim;          /*    16     8 */
	mysql_free_t               mysql_free;           /*    24     8 */
	my_memdup_t                my_memdup;            /*    32     8 */
	my_strdup_t                my_strdup;            /*    40     8 */
	my_strndup_t               my_strndup;           /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct PSI_memory_service_v2 {
	register_memory_v1_t       register_memory;      /*     0     8 */
	memory_alloc_v1_t          memory_alloc;         /*     8     8 */
	memory_realloc_v1_t        memory_realloc;       /*    16     8 */
	memory_claim_v2_t          memory_claim;         /*    24     8 */
	memory_free_v1_t           memory_free;          /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct MEM_ROOT {
	struct Block {
		class Block *              prev;                 /*     0     8 */

		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */
	};

	void MEM_ROOT(class MEM_ROOT *);

	void MEM_ROOT(class MEM_ROOT *, PSI_memory_key, size_t);

	void MEM_ROOT(class MEM_ROOT *, const class MEM_ROOT  &);

	void MEM_ROOT(class MEM_ROOT *, );

	class MEM_ROOT & operator=(class MEM_ROOT *, const class MEM_ROOT  &);

	class MEM_ROOT & operator=(class MEM_ROOT *, );

	void ~MEM_ROOT(class MEM_ROOT *, int);

	void * Alloc(class MEM_ROOT *, size_t);

	void * Alloc_aligned(class MEM_ROOT *, size_t, size_t);

	void Claim(class MEM_ROOT *, bool);

	void Clear(class MEM_ROOT *);

	void ClearForReuse(class MEM_ROOT *);

	bool inited(const class MEM_ROOT  *);

	void set_max_capacity(class MEM_ROOT *, size_t);

	size_t get_max_capacity(const class MEM_ROOT  *);

	void set_error_for_capacity_exceeded(class MEM_ROOT *, bool);

	bool get_error_for_capacity_exceeded(const class MEM_ROOT  *);

	void set_error_handler(class MEM_ROOT *, void (*)(void));

	size_t allocated_size(const class MEM_ROOT  *);

	void set_block_size(class MEM_ROOT *, size_t);

	class pair<char*, char*> Peek(const class MEM_ROOT  *);

	bool ForceNewBlock(class MEM_ROOT *, size_t);

	void RawCommit(class MEM_ROOT *, size_t);

private:

	static char                       s_dummy_target; /*     0     0 */
	class pair<MEM_ROOT::Block*, long unsigned int> AllocBlock(class MEM_ROOT *, size_t, size_t);

	void * AllocSlow(class MEM_ROOT *, size_t);

	void FreeBlocks(class Block *);

	class Block *              m_current_block;      /*     0     8 */
	char *                     m_current_free_start; /*     8     8 */
	char *                     m_current_free_end;   /*    16     8 */
	size_t                     m_block_size;         /*    24     8 */
	size_t                     m_orig_block_size;    /*    32     8 */
	size_t                     m_max_capacity;       /*    40     8 */
	size_t                     m_allocated_size;     /*    48     8 */
	bool                       m_error_for_capacity_exceeded; /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*m_error_handler)(void); /*    64     8 */
	PSI_memory_key             m_psi_key;            /*    72     4 */
	class Block * ArrayAlloc<mem_root_deque<Item*>::Block>(class MEM_ROOT *, size_t);


	/* size: 80, cachelines: 2, members: 10, static members: 1 */
	/* sum members: 69, holes: 1, sum holes: 7 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct My_free_deleter {
	void operator()(const class My_free_deleter  *, void *);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class Collation_hasher {
public:

	void Collation_hasher(class Collation_hasher *, const class CHARSET_INFO  *);

	size_t operator()(const class Collation_hasher  *, const string  &);

	const class CHARSET_INFO  * cs;                  /*     0     8 */
	void                       (*hash_sort)(const class CHARSET_INFO  *, const uchar  *, size_t, uint64 *, uint64 *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Collation_key_equal {
public:

	void Collation_key_equal(class Collation_key_equal *, const class CHARSET_INFO  *);

	size_t operator()(const class Collation_key_equal  *, const string  &, const string  &);

	const class CHARSET_INFO  * cs;                  /*     0     8 */
	int                        (*strnncollsp)(const class CHARSET_INFO  *, const uchar  *, size_t, const uchar  *, size_t); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PSI_mutex_info_v1 {
	PSI_mutex_key *            m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */
	int                        m_volatility;         /*    20     4 */
	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct PSI_mutex_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */
	enum PSI_mutex_operation   m_operation;          /*     4     4 */
	class PSI_mutex *          m_mutex;              /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	long long unsigned int     m_timer_start;        /*    24     8 */
	long long unsigned int     (*m_timer)(void);     /*    32     8 */
	void *                     m_wait;               /*    40     8 */
	void PSI_mutex_locker_state_v1(class PSI_mutex_locker_state_v1 *);


	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct PSI_mutex_service_v1 {
	register_mutex_v1_t        register_mutex;       /*     0     8 */
	init_mutex_v1_t            init_mutex;           /*     8     8 */
	destroy_mutex_v1_t         destroy_mutex;        /*    16     8 */
	start_mutex_wait_v1_t      start_mutex_wait;     /*    24     8 */
	end_mutex_wait_v1_t        end_mutex_wait;       /*    32     8 */
	unlock_mutex_v1_t          unlock_mutex;         /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct my_thread_handle {
	my_thread_t                thread;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Mutex_lock {
public:

	void Mutex_lock(class Mutex_lock *, class mysql_mutex_t *, const char  *, int);

	void ~Mutex_lock(class Mutex_lock *, int);

	class mysql_mutex_t *      m_mutex;              /*     0     8 */
	const char  *              m_src_file;           /*     8     8 */
	int                        m_src_line;           /*    16     4 */
	void Mutex_lock(class Mutex_lock *, const class Mutex_lock  &);

	void operator=(class Mutex_lock *, const class Mutex_lock  &);


	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_idle_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_thread *         m_thread;             /*     8     8 */
	long long unsigned int     m_timer_start;        /*    16     8 */
	long long unsigned int     (*m_timer)(void);     /*    24     8 */
	void *                     m_wait;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct PSI_statement_info_v1 {
	PSI_statement_key          m_key;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 24, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct PSI_statement_locker_state_v1 {
	bool                       m_discarded;          /*     0     1 */
	bool                       m_in_prepare;         /*     1     1 */
	unsigned char              m_no_index_used;      /*     2     1 */
	unsigned char              m_no_good_index_used; /*     3     1 */
	unsigned int               m_flags;              /*     4     4 */
	void *                     m_class;              /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	long long unsigned int     m_timer_start;        /*    24     8 */
	long long unsigned int     (*m_timer)(void);     /*    32     8 */
	void *                     m_statement;          /*    40     8 */
	long long unsigned int     m_lock_time;          /*    48     8 */
	long long unsigned int     m_rows_sent;          /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	long long unsigned int     m_rows_examined;      /*    64     8 */
	long unsigned int          m_created_tmp_disk_tables; /*    72     8 */
	long unsigned int          m_created_tmp_tables; /*    80     8 */
	long unsigned int          m_select_full_join;   /*    88     8 */
	long unsigned int          m_select_full_range_join; /*    96     8 */
	long unsigned int          m_select_range;       /*   104     8 */
	long unsigned int          m_select_range_check; /*   112     8 */
	long unsigned int          m_select_scan;        /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	long unsigned int          m_sort_merge_passes;  /*   128     8 */
	long unsigned int          m_sort_range;         /*   136     8 */
	long unsigned int          m_sort_rows;          /*   144     8 */
	long unsigned int          m_sort_scan;          /*   152     8 */
	const class sql_digest_storage  * m_digest;      /*   160     8 */
	char                       m_schema_name[192];   /*   168   192 */
	/* --- cacheline 5 boundary (320 bytes) was 40 bytes ago --- */
	unsigned int               m_schema_name_length; /*   360     4 */
	unsigned int               m_cs_number;          /*   364     4 */
	const char  *              m_query_sample;       /*   368     8 */
	unsigned int               m_query_sample_length; /*   376     4 */
	bool                       m_query_sample_truncated; /*   380     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 6 boundary (384 bytes) --- */
	PSI_sp_share *             m_parent_sp_share;    /*   384     8 */
	PSI_prepared_stmt *        m_parent_prepared_stmt; /*   392     8 */

	/* size: 400, cachelines: 7, members: 33 */
	/* sum members: 397, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct sql_digest_storage {
	bool                       m_full;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	size_t                     m_byte_count;         /*     8     8 */
	unsigned char              m_hash[32];           /*    16    32 */
	uint                       m_charset_number;     /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	unsigned char *            m_token_array;        /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	size_t                     m_token_array_length; /*    64     8 */
	void sql_digest_storage(class sql_digest_storage *);

	void reset(class sql_digest_storage *, unsigned char *, size_t);

	void reset(class sql_digest_storage *);

	bool is_empty(class sql_digest_storage *);

	void copy(class sql_digest_storage *, const class sql_digest_storage  *);


	/* size: 72, cachelines: 2, members: 6 */
	/* sum members: 61, holes: 2, sum holes: 11 */
	/* last cacheline: 8 bytes */
};
struct PSI_sp_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_thread *         m_thread;             /*     8     8 */
	long long unsigned int     m_timer_start;        /*    16     8 */
	long long unsigned int     (*m_timer)(void);     /*    24     8 */
	PSI_sp_share *             m_sp_share;           /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct PSI_thread_info_v1 {
	PSI_thread_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */
	int                        m_volatility;         /*    20     4 */
	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
class THD : public MDL_context_owner, public Query_arena, public Open_tables_state {
	class Query_plan {
		const class THD *          thd;                  /*     0     8 */
		enum enum_sql_command      sql_command;          /*     8     4 */

		/* XXX 4 bytes hole, try to pack */

		class LEX *                lex;                  /*    16     8 */
		const class Modification_plan  * modification_plan; /*    24     8 */
		bool                       is_ps;                /*    32     1 */
		void Query_plan(class Query_plan *, const class Query_plan  &);

		class Query_plan & operator=(class Query_plan *, const class Query_plan  &);

	public:

		void assert_plan_is_locked_if_other(const class Query_plan  *);

		void Query_plan(class Query_plan *, class THD *);

		void set_query_plan(class Query_plan *, enum enum_sql_command, class LEX *, bool);

		enum enum_sql_command get_command(const class Query_plan  *);

		class LEX * get_lex(const class Query_plan  *);

		const class Modification_plan  * get_modification_plan(const class Query_plan  *);

		bool is_ps_query(const class Query_plan  *);

		bool is_single_table_plan(const class Query_plan  *);

		void set_modification_plan(class Query_plan *, class Modification_plan *);


		/* size: 40, cachelines: 1, members: 5 */
		/* sum members: 29, holes: 1, sum holes: 4 */
		/* padding: 7 */
		/* last cacheline: 40 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	enum binlog_filter_state {
		BINLOG_FILTER_UNKNOWN = 0,
		BINLOG_FILTER_CLEAR   = 1,
		BINLOG_FILTER_SET     = 2,
	};

	struct Transaction_state {
		void Transaction_state(class Transaction_state *);

		void ~Transaction_state(class Transaction_state *, int);

		void backup(class Transaction_state *, class THD *);

		void restore(class Transaction_state *, class THD *);

		enum enum_sql_command      m_sql_command;        /*     0     4 */

		/* XXX 4 bytes hole, try to pack */

		class Query_tables_list *  m_query_tables_list;  /*     8     8 */
		class Open_tables_backup  m_open_tables_state;   /*    16    96 */
		/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
		sql_mode_t                 m_sql_mode;           /*   112     8 */
		enum enum_tx_isolation     m_tx_isolation;       /*   120     4 */

		/* XXX 4 bytes hole, try to pack */

		/* --- cacheline 2 boundary (128 bytes) --- */
		class Prealloced_array<Ha_data, 15> m_ha_data;   /*   128  1088 */
		/* --- cacheline 19 boundary (1216 bytes) --- */
		class Transaction_ctx *    m_trx;                /*  1216     8 */
		bool                       m_tx_read_only;       /*  1224     1 */

		/* XXX 7 bytes hole, try to pack */

		ulonglong                  m_thd_option_bits;    /*  1232     8 */
		PSI_transaction_locker *   m_transaction_psi;    /*  1240     8 */
		uint                       m_server_status;      /*  1248     4 */
		bool                       m_in_lock_tables;     /*  1252     1 */
		bool                       m_time_zone_used;     /*  1253     1 */
		bool                       m_transaction_rollback_request; /*  1254     1 */

		/* size: 1256, cachelines: 20, members: 14 */
		/* sum members: 1240, holes: 3, sum holes: 15 */
		/* padding: 1 */
		/* last cacheline: 40 bytes */
	};

	enum enum_reset_lex {
		RESET_LEX        = 0,
		DO_NOT_RESET_LEX = 1,
	};

	enum Commit_error {
		CE_NONE                      = 0,
		CE_FLUSH_ERROR               = 1,
		CE_FLUSH_GNO_EXHAUSTED_ERROR = 2,
		CE_SYNC_ERROR                = 3,
		CE_COMMIT_ERROR              = 4,
		CE_ERROR_COUNT               = 5,
	};

	enum killed_state {
		NOT_KILLED      = 0,
		KILL_CONNECTION = 1053,
		KILL_QUERY      = 1317,
		KILL_TIMEOUT    = 3024,
		KILLED_NO_VALUE = 3025,
	};

	/* tag__fprintf: const_type tag not supported! */;

	union {
		bool                       bool_value;           /*     0     1 */
		long int                   long_value;           /*     0     8 */
		ulong                      ulong_value;          /*     0     8 */
		ulonglong                  ulonglong_value;      /*     0     8 */
		double                     double_value;         /*     0     8 */
	};

	struct {
		bool                       do_union;             /*     0     1 */
		bool                       unioned_events;       /*     1     1 */
		bool                       unioned_events_trans; /*     2     1 */

		/* XXX 5 bytes hole, try to pack */

		query_id_t                 first_query_id;       /*     8     8 */

		/* size: 16, cachelines: 1, members: 4 */
		/* sum members: 11, holes: 1, sum holes: 5 */
		/* last cacheline: 16 bytes */
	};

	enum enum_binlog_query_type {
		ROW_QUERY_TYPE   = 0,
		STMT_QUERY_TYPE  = 1,
		QUERY_TYPE_COUNT = 2,
	};

	enum Se_GTID_flag {
		SE_GTID_PIN              = 0,
		SE_GTID_CLEANUP          = 1,
		SE_GTID_PERSIST          = 2,
		SE_GTID_RESET_LOG        = 3,
		SE_GTID_PERSIST_EXPLICIT = 4,
		SE_GTID_MAX              = 5,
	} __attribute__((__packed__));

public:

	/* class MDL_context_owner   <ancestor>; */      /*     0     8 */
	/* class Query_arena         <ancestor>; */      /*     8    32 */
	/* class Open_tables_state   <ancestor>; */      /*    40    80 */
	void THD(class THD *, const class THD  &);

	bool is_stmt_prepare(const class THD  *);

	bool is_stmt_prepare_or_first_sp_execute(const class THD  *);

	bool is_stmt_prepare_or_first_stmt_execute(const class THD  *);

	bool is_regular(const class THD  *);

	class MDL_context         mdl_context;           /*   120   352 */

	/* XXX last struct has 4 bytes of padding */

	enum enum_mark_columns     mark_used_columns;    /*   472     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      want_privilege;       /*   480     8 */
	class unique_ptr<LEX, std::default_delete<LEX> > main_lex; /*   488     8 */
	class LEX *                lex;                  /*   496     8 */
	class Dictionary_client * dd_client(const class THD  *);

	class unique_ptr<dd::cache::Dictionary_client, std::default_delete<dd::cache::Dictionary_client> > m_dd_client; /*   504     8 */
	LEX_CSTRING                m_query_string;       /*   512    16 */
	class String              m_normalized_query;    /*   528    32 */

	/* XXX last struct has 3 bytes of padding */

	struct atomic<bool>        m_safe_to_display __attribute__((__aligned__(1))); /*   560     1 */

	/* XXX 7 bytes hole, try to pack */

	LEX_CSTRING                m_catalog;            /*   568    16 */
	LEX_CSTRING                m_db;                 /*   584    16 */
	struct Resource_group_ctx  m_resource_group_ctx; /*   600    80 */
	class String              m_rewritten_query;     /*   680    32 */

	/* XXX last struct has 3 bytes of padding */

	class Relay_log_info *     rli_fake;             /*   712     8 */
	class Relay_log_info *     rli_slave;            /*   720     8 */
	bool                       tx_commit_pending;    /*   728     1 */

	/* XXX 7 bytes hole, try to pack */
	bool is_binlog_applier(const class THD  *);

	void rpl_detach_engine_ha_data(class THD *);

	void rpl_reattach_engine_ha_data(class THD *);

	bool is_engine_ha_data_detached(const class THD  *);

	void reset_for_next_command(class THD *);

	/* Bitfield combined with previous fields */

	static const const char  *        DEFAULT_WHERE; /*     0     0 */
	NET_SERVER                 m_net_server_extension; /*   736   112 */
	class THD_event_functions * scheduler;           /*   848     8 */
	class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > user_vars; /*   856    96 */
	struct rand_struct         rand;                 /*   952    32 */
	struct rand_struct         slog_rand;            /*   984    32 */
	struct System_variables    variables;            /*  1016  1008 */
	/* --- cacheline 31 boundary (1984 bytes) was 40 bytes ago --- */
	struct System_status_var   status_var;           /*  2024  1800 */
	/* --- cacheline 59 boundary (3776 bytes) was 48 bytes ago --- */
	class System_status_var *  initial_status_var;   /*  3824     8 */
	bool                       status_var_aggregated; /*  3832     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 60 boundary (3840 bytes) --- */
	class vector<char, std::allocator<char> > m_connection_attributes; /*  3840    24 */
	double                     m_current_query_cost; /*  3864     8 */
	ulonglong                  m_current_query_partial_plans; /*  3872     8 */
	void clear_current_query_costs(class THD *);

	void save_current_query_costs(class THD *);

	struct THR_LOCK_INFO       lock_info;            /*  3880    16 */
	struct mysql_mutex_t       LOCK_thd_data;        /*  3896    48 */
	/* --- cacheline 61 boundary (3904 bytes) was 40 bytes ago --- */
	struct mysql_mutex_t       LOCK_thd_query;       /*  3944    48 */
	/* --- cacheline 62 boundary (3968 bytes) was 24 bytes ago --- */
	struct mysql_mutex_t       LOCK_temporary_tables; /*  3992    48 */
	/* --- cacheline 63 boundary (4032 bytes) was 8 bytes ago --- */
	struct mysql_mutex_t       LOCK_thd_sysvar;      /*  4040    48 */
	struct mysql_mutex_t       LOCK_thd_protocol;    /*  4088    48 */
	/* --- cacheline 64 boundary (4096 bytes) was 40 bytes ago --- */
	struct mysql_mutex_t       LOCK_query_plan;      /*  4136    48 */
	void lock_query_plan(class THD *);

	void unlock_query_plan(class THD *);

	/* --- cacheline 65 boundary (4160 bytes) was 24 bytes ago --- */
	class Prepared_statement_map stmt_map;           /*  4184   168 */
	/* --- cacheline 68 boundary (4352 bytes) --- */
	const char  *              thread_stack;         /*  4352     8 */
	class Security_context    m_main_security_ctx;   /*  4360  1040 */
	/* --- cacheline 84 boundary (5376 bytes) was 24 bytes ago --- */
	class Security_context *   m_security_ctx;       /*  5400     8 */
	class Security_context * security_context(const class THD  *);

	void set_security_context(class THD *, class Security_context *);

	class List<Security_context> m_view_ctx_list;    /*  5408    24 */
	bool                       m_disable_password_validation; /*  5432     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 85 boundary (5440 bytes) --- */
	class unique_ptr<Protocol_text, std::default_delete<Protocol_text> > protocol_text; /*  5440     8 */
	class unique_ptr<Protocol_binary, std::default_delete<Protocol_binary> > protocol_binary; /*  5448     8 */
	const class Protocol  * get_protocol(const class THD  *);

	class Protocol * get_protocol(class THD *);

	SSL * get_ssl(const class THD  *);

	bool is_ssl(const class THD  *);

	const class Protocol_classic  * get_protocol_classic(const class THD  *);

	class Protocol_classic * get_protocol_classic(class THD *);

	class Protocol *           m_protocol;           /*  5456     8 */
	SSL *                      m_SSL;                /*  5464     8 */
	class Query_plan          query_plan;            /*  5472    40 */

	/* XXX last struct has 7 bytes of padding */
	const LEX_CSTRING  & catalog(const class THD  *);

	void set_catalog(class THD *, const LEX_CSTRING  &);


	/* --- cacheline 86 boundary (5504 bytes) was 8 bytes ago --- */
	PSI_stage_key              m_current_stage_key;  /*  5512     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_proc_info;          /*  5520     8 */
	const char  * proc_info(const class THD  *, const class System_variables  &);

	void enter_stage(class THD *, const PSI_stage_info  *, PSI_stage_info *, const char  *, const char  *, unsigned int);

	const char  * proc_info(const class THD  *);

	const char  * proc_info_session(const class THD  *, class THD *);

	void set_proc_info(class THD *, const char  *);

	PSI_stage_key get_current_stage_key(const class THD  *);

	const char  *              where;                /*  5528     8 */
	ulong                      max_client_packet_length; /*  5536     8 */
	class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> > handler_tables_hash; /*  5544    96 */
	/* --- cacheline 88 boundary (5632 bytes) was 8 bytes ago --- */
	class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > ull_hash; /*  5640    64 */
	/* --- cacheline 89 boundary (5696 bytes) was 8 bytes ago --- */
	bool                       is_killable;          /*  5704     1 */

	/* XXX 7 bytes hole, try to pack */

	struct mysql_mutex_t       LOCK_current_cond;    /*  5712    48 */
	/* --- cacheline 90 boundary (5760 bytes) --- */
	struct atomic<mysql_mutex_t*> current_mutex;     /*  5760     8 */
	struct atomic<mysql_cond_t*> current_cond;       /*  5768     8 */
	struct mysql_cond_t        COND_thr_lock;        /*  5776    56 */
	/* --- cacheline 91 boundary (5824 bytes) was 8 bytes ago --- */
	enum enum_server_command   m_command;            /*  5832     4 */
	bool                       m_is_admin_conn;      /*  5836     1 */

	/* XXX 3 bytes hole, try to pack */
	void set_admin_connection(class THD *, bool);

	bool is_admin_connection(const class THD  *);


	uint32                     unmasked_server_id;   /*  5840     4 */
	uint32                     server_id;            /*  5844     4 */
	uint32                     file_id;              /*  5848     4 */
	uint16                     peer_port;            /*  5852     2 */

	/* XXX 2 bytes hole, try to pack */

	struct timeval             start_time;           /*  5856    16 */
	struct timeval             user_time;            /*  5872    16 */
	/* --- cacheline 92 boundary (5888 bytes) --- */
	ulonglong                  start_utime;          /*  5888     8 */
	ulonglong                  utime_after_lock;     /*  5896     8 */
	ulonglong                  utime_after_query;    /*  5904     8 */
	enum thr_lock_type         update_lock_default;  /*  5912     4 */
	enum thr_lock_type         insert_lock_default;  /*  5916     4 */
	ulonglong                  bytes_sent_old;       /*  5920     8 */
	ulong                      tmp_tables_used;      /*  5928     8 */
	ulong                      tmp_tables_disk_used; /*  5936     8 */
	ulonglong                  tmp_tables_size;      /*  5944     8 */
	/* --- cacheline 93 boundary (5952 bytes) --- */
	ulonglong                  innodb_trx_id;        /*  5952     8 */
	ulong                      innodb_io_reads;      /*  5960     8 */
	ulonglong                  innodb_io_read;       /*  5968     8 */
	uint64_t                   innodb_io_reads_wait_timer; /*  5976     8 */
	uint64_t                   innodb_lock_que_wait_timer; /*  5984     8 */
	uint64_t                   innodb_innodb_que_wait_timer; /*  5992     8 */
	bool                       innodb_was_used;      /*  6000     1 */

	/* XXX 7 bytes hole, try to pack */

	class Bloom_filter        approx_distinct_pages; /*  6008    56 */
	/* --- cacheline 94 boundary (6016 bytes) was 48 bytes ago --- */
	ulong                      innodb_page_access;   /*  6064     8 */
	void mark_innodb_used(class THD *, ulonglong);

	void access_distinct_page(class THD *, ulong);

	bool innodb_slow_log_enabled(const class THD  *);

	bool innodb_slow_log_data_logged(const class THD  *);

	ulong                      query_plan_flags;     /*  6072     8 */
	/* --- cacheline 95 boundary (6080 bytes) --- */
	ulong                      query_plan_fsort_passes; /*  6080     8 */
	uint                       last_errno;           /*  6088     4 */
	void set_slow_log_for_admin_command(class THD *);

	void clear_slow_extended(class THD *);

	void reset_sub_statement_state_slow_extended(class THD *, class Sub_statement_state *);

	void restore_sub_statement_state_slow_extended(class THD *, const class Sub_statement_state  &);

	uint                       in_sub_stmt;          /*  6092     4 */
	bool                       skip_wait_timeout;    /*  6096     1 */

	/* XXX 3 bytes hole, try to pack */
	ulong get_wait_timeout(const class THD  *);


	uint                       fill_status_recursion_level; /*  6100     4 */
	uint                       fill_variables_recursion_level; /*  6104     4 */

	/* XXX 4 bytes hole, try to pack */

	class Prealloced_array<Ha_data, 15> ha_data;     /*  6112  1088 */
	class Ha_data * get_ha_data(class THD *, int);

	void backup_ha_data(class THD *, class Prealloced_array<Ha_data, 15> *);

	void restore_ha_data(class THD *, const class Prealloced_array<Ha_data, 15>  &);

	/* --- cacheline 112 boundary (7168 bytes) was 32 bytes ago --- */
	bool                       order_deterministic;  /*  7200     1 */

	/* XXX 7 bytes hole, try to pack */

	struct rpl_event_coordinates binlog_next_event_pos; /*  7208    16 */
	void set_next_event_pos(class THD *, const char  *, ulonglong);

	void clear_next_event_pos(class THD *);

	uchar *                    binlog_row_event_extra_data; /*  7224     8 */
	int binlog_setup_trx_data(class THD *);

	int binlog_write_table_map(class THD *, class TABLE *, bool, bool);

	int binlog_write_row(class THD *, class TABLE *, bool, const uchar  *, const unsigned char  *);

	int binlog_delete_row(class THD *, class TABLE *, bool, const uchar  *, const unsigned char  *);

	int binlog_update_row(class THD *, class TABLE *, bool, const uchar  *, const uchar  *, const uchar  *);

	void set_server_id(class THD *, uint32);

	class Rows_log_event * binlog_get_pending_rows_event(const class THD  *, bool);

	int binlog_flush_pending_rows_event(class THD *, bool);

	int binlog_flush_pending_rows_event(class THD *, bool, bool);

	int is_current_stmt_binlog_format_row(const class THD  *);

	bool is_current_stmt_binlog_disabled(const class THD  *);

	bool is_current_stmt_binlog_log_replica_updates_disabled(const class THD  *);

	bool is_current_stmt_binlog_row_enabled_with_write_set_extraction(const class THD  *);

	bool optimizer_switch_flag(const class THD  *, ulonglong);

	void reset_binlog_local_stmt_filter(class THD *);

	void clear_binlog_local_stmt_filter(class THD *);

	void set_binlog_local_stmt_filter(class THD *);

	enum binlog_filter_state get_binlog_local_stmt_filter(const class THD  *);

	/* --- cacheline 113 boundary (7232 bytes) --- */
	class THD_timer_info *     timer;                /*  7232     8 */
	class THD_timer_info *     timer_cache;          /*  7240     8 */
	bool                       skip_readonly_check;  /*  7248     1 */

	/* XXX 3 bytes hole, try to pack */

	enum binlog_filter_state   m_binlog_filter_state; /*  7252     4 */
	enum enum_binlog_format    current_stmt_binlog_format; /*  7256     4 */
	uint32                     binlog_unsafe_warning_flags; /*  7260     4 */
	uint                       binlog_table_maps;    /*  7264     4 */

	/* XXX 4 bytes hole, try to pack */

	class List<char> *         binlog_accessed_db_names; /*  7272     8 */
	const char  *              m_trans_log_file;     /*  7280     8 */
	char *                     m_trans_fixed_log_file; /*  7288     8 */
	/* --- cacheline 114 boundary (7296 bytes) --- */
	my_off_t                   m_trans_end_pos;      /*  7296     8 */
	NET                        net;                  /*  7304   664 */
	/* --- cacheline 124 boundary (7936 bytes) was 32 bytes ago --- */
	class String              packet;                /*  7968    32 */

	/* XXX last struct has 3 bytes of padding */
	void set_skip_readonly_check(class THD *);

	bool is_cmd_skip_readonly(const class THD  *);

	void reset_skip_readonly_check(class THD *);

	void issue_unsafe_warnings(class THD *);

	uint get_binlog_table_maps(const class THD  *);

	void clear_binlog_table_maps(class THD *);

	class List<char> * get_binlog_accessed_db_names(const class THD  *);

	void add_to_binlog_accessed_dbs(class THD *, const char  *);


	/* --- cacheline 125 boundary (8000 bytes) --- */
	class unique_ptr<Transaction_ctx, std::default_delete<Transaction_ctx> > m_transaction; /*  8000     8 */
	class Attachable_trx {
	public:

		int ()(void) * *           _vptr.Attachable_trx; /*     0     8 */
		void Attachable_trx(class Attachable_trx *, class THD *, class Attachable_trx *);

		virtual void ~Attachable_trx(class Attachable_trx *, int);

		class Attachable_trx * get_prev_attachable_trx(const class Attachable_trx  *);

		virtual bool is_read_only(const class Attachable_trx  *);

	protected:

		class THD *                m_thd;                /*     8     8 */
		enum enum_reset_lex        m_reset_lex;          /*    16     4 */

		/* XXX 4 bytes hole, try to pack */

		class Attachable_trx *     m_prev_attachable_trx; /*    24     8 */
		struct Transaction_state   m_trx_state;          /*    32  1256 */

		/* XXX last struct has 1 byte of padding */
		void Attachable_trx(class Attachable_trx *, const class Attachable_trx  &);

		class Attachable_trx & operator=(class Attachable_trx *, const class Attachable_trx  &);

		/* vtable has 1 entries: {
		   [2] = is_read_only((null)), 
		} */
		/* size: 1288, cachelines: 21, members: 5 */
		/* sum members: 1284, holes: 1, sum holes: 4 */
		/* paddings: 1, sum paddings: 1 */
		/* last cacheline: 8 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Attachable_trx *     m_attachable_trx;     /*  8008     8 */
	class Transaction_ctx * get_transaction(class THD *);

	const class Transaction_ctx  * get_transaction(const class THD  *);

	void set_transaction(class THD *, class Transaction_ctx *);

	class Global_read_lock    global_read_lock;      /*  8016    24 */
	class Global_backup_lock  backup_tables_lock;    /*  8040    16 */
	class Vio *                active_vio;           /*  8056     8 */
	/* --- cacheline 126 boundary (8064 bytes) --- */
	class Vio *                clone_vio;            /*  8064     8 */
	Item_change_list           change_list;          /*  8072    24 */
	class Query_arena *        stmt_arena;           /*  8096     8 */
	table_map                  table_map_for_update; /*  8104     8 */
	bool                       arg_of_last_insert_id_function; /*  8112     1 */

	/* XXX 7 bytes hole, try to pack */

	ulonglong                  first_successful_insert_id_in_prev_stmt; /*  8120     8 */
	/* --- cacheline 127 boundary (8128 bytes) --- */
	ulonglong                  first_successful_insert_id_in_prev_stmt_for_binlog; /*  8128     8 */
	ulonglong                  first_successful_insert_id_in_cur_stmt; /*  8136     8 */
	bool                       stmt_depends_on_first_successful_insert_id_in_prev_stmt; /*  8144     1 */

	/* XXX 7 bytes hole, try to pack */

	class Discrete_intervals_list auto_inc_intervals_in_cur_stmt_for_binlog; /*  8152    64 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 128 boundary (8192 bytes) was 24 bytes ago --- */
	class Discrete_intervals_list auto_inc_intervals_forced; /*  8216    64 */

	/* XXX last struct has 4 bytes of padding */
	void record_first_successful_insert_id_in_cur_stmt(class THD *, ulonglong);

	ulonglong read_first_successful_insert_id_in_prev_stmt(class THD *);

	void reset_first_successful_insert_id(class THD *);

	void force_one_auto_inc_interval(class THD *, ulonglong);


	/* --- cacheline 129 boundary (8256 bytes) was 24 bytes ago --- */
	ulonglong                  previous_found_rows;  /*  8280     8 */
	ulonglong                  current_found_rows;   /*  8288     8 */
	bool                       is_operating_gtid_table_implicitly; /*  8296     1 */
	bool                       is_operating_substatement_implicitly; /*  8297     1 */

	/* XXX 6 bytes hole, try to pack */

	longlong                   m_row_count_func;     /*  8304     8 */
	longlong get_row_count_func(const class THD  *);

	void set_row_count_func(class THD *, longlong);

	ha_rows                    num_truncated_fields; /*  8312     8 */
	/* --- cacheline 130 boundary (8320 bytes) --- */
	ha_rows                    m_sent_row_count;     /*  8320     8 */
	ha_rows                    m_examined_row_count; /*  8328     8 */
	USER_CONN *                m_user_connect;       /*  8336     8 */
	void set_user_connect(class THD *, USER_CONN *);

	const USER_CONN  * get_user_connect(const class THD  *);

	void increment_user_connections_counter(class THD *);

	void decrement_user_connections_counter(class THD *);

	void increment_con_per_hour_counter(class THD *);

	void increment_updates_counter(class THD *);

	void increment_questions_counter(class THD *);

	void time_out_user_resource_limits(class THD *);

	ha_rows get_sent_row_count(const class THD  *);

	ha_rows get_examined_row_count(const class THD  *);

	void set_sent_row_count(class THD *, ha_rows);

	void inc_sent_row_count(class THD *, ha_rows);

	void inc_examined_row_count(class THD *, ha_rows);

	void inc_status_created_tmp_disk_tables(class THD *);

	void inc_status_created_tmp_tables(class THD *);

	void inc_status_select_full_join(class THD *);

	void inc_status_select_full_range_join(class THD *);

	void inc_status_select_range(class THD *);

	void inc_status_select_range_check(class THD *);

	void inc_status_select_scan(class THD *);

	void inc_status_sort_merge_passes(class THD *);

	void inc_status_sort_range(class THD *);

	void inc_status_sort_rows(class THD *, ha_rows);

	void inc_status_sort_scan(class THD *);

	void set_status_no_index_used(class THD *);

	void set_status_no_good_index_used(class THD *);

	const class CHARSET_INFO  * db_charset;          /*  8344     8 */
	class unique_ptr<PROFILING, std::default_delete<PROFILING> > profiling; /*  8352     8 */
	PSI_stage_progress *       m_stage_progress_psi; /*  8360     8 */
	sql_digest_state *         m_digest;             /*  8368     8 */
	unsigned char *            m_token_array;        /*  8376     8 */
	/* --- cacheline 131 boundary (8384 bytes) --- */
	sql_digest_state           m_digest_state;       /*  8384    80 */
	/* --- cacheline 132 boundary (8448 bytes) was 16 bytes ago --- */
	PSI_statement_locker *     m_statement_psi;      /*  8464     8 */
	PSI_statement_locker_state m_statement_state;    /*  8472   400 */
	/* --- cacheline 138 boundary (8832 bytes) was 40 bytes ago --- */
	PSI_transaction_locker *   m_transaction_psi;    /*  8872     8 */
	PSI_transaction_locker_state m_transaction_state; /*  8880    88 */
	/* --- cacheline 140 boundary (8960 bytes) was 8 bytes ago --- */
	PSI_idle_locker *          m_idle_psi;           /*  8968     8 */
	PSI_idle_locker_state      m_idle_state;         /*  8976    40 */
	bool                       m_server_idle;        /*  9016     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 141 boundary (9024 bytes) --- */
	query_id_t                 query_id;             /*  9024     8 */
	ulong                      statement_id_counter; /*  9032     8 */
	ulong                      rand_saved_seed1;     /*  9040     8 */
	ulong                      rand_saved_seed2;     /*  9048     8 */
	my_thread_t                real_id;              /*  9056     8 */
	my_thread_id               m_thread_id;          /*  9064     4 */
	void set_new_thread_id(class THD *);

	my_thread_id thread_id(const class THD  *);

	uint                       tmp_table;            /*  9068     4 */
	uint                       server_status;        /*  9072     4 */
	uint                       open_options;         /*  9076     4 */
	enum enum_thread_type      system_thread;        /*  9080     4 */
	bool is_system_thread(const class THD  *);

	bool is_dd_system_thread(const class THD  *);

	bool is_initialize_system_thread(const class THD  *);

	bool is_init_file_system_thread(const class THD  *);

	bool is_bootstrap_system_thread(const class THD  *);

	bool is_server_upgrade_thread(const class THD  *);

	enum enum_tx_isolation     tx_isolation;         /*  9084     4 */
	/* --- cacheline 142 boundary (9088 bytes) --- */
	bool                       tx_read_only;         /*  9088     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        tx_priority;          /*  9092     4 */
	int                        thd_tx_priority;      /*  9096     4 */
	enum enum_check_fields     check_for_truncated_fields; /*  9100     4 */
	ha_rows                    updated_row_count;    /*  9104     8 */
	ha_rows                    sent_row_count_2;     /*  9112     8 */
	class Prealloced_array<Binlog_user_var_event*, 2> user_var_events; /*  9120    32 */
	/* --- cacheline 143 boundary (9152 bytes) --- */
	class MEM_ROOT *           user_var_events_alloc; /*  9152     8 */
	class THD *                next_to_commit;       /*  9160     8 */
	bool                       binlog_need_explicit_defaults_ts; /*  9168     1 */

	/* XXX 3 bytes hole, try to pack */
	void set_trans_pos(class THD *, const char  *, my_off_t);

	void get_trans_pos(const class THD  *, const char  * *, my_off_t *);

	void get_trans_fixed_pos(const class THD  *, const char  * *, my_off_t *);


	enum Commit_error          commit_error;         /*  9172     4 */
	enum durability_properties durability_property;  /*  9176     4 */
	struct atomic<THD::killed_state> killed __attribute__((__aligned__(4))); /*  9180     4 */
	bool                       running_explain_analyze; /*  9184     1 */

	/* XXX 7 bytes hole, try to pack */

	class DD_kill_immunizer *  kill_immunizer;       /*  9192     8 */
	char                       scramble[21];         /*  9200    21 */
	/* --- cacheline 144 boundary (9216 bytes) was 5 bytes ago --- */
	bool                       slave_thread;         /*  9221     1 */
	uchar                      password;             /*  9222     1 */
	bool                       m_is_fatal_error;     /*  9223     1 */
	bool                       transaction_rollback_request; /*  9224     1 */
	bool                       is_fatal_sub_stmt_error; /*  9225     1 */
	bool                       query_start_usec_used; /*  9226     1 */
	bool                       rand_used;            /*  9227     1 */
	bool                       time_zone_used;       /*  9228     1 */
	bool                       in_lock_tables;       /*  9229     1 */
	bool                       is_slave_error;       /*  9230     1 */
	bool                       thread_specific_used; /*  9231     1 */
	bool                       charset_is_system_charset; /*  9232     1 */
	bool                       charset_is_collation_connection; /*  9233     1 */
	bool                       charset_is_character_set_filesystem; /*  9234     1 */
	bool                       enable_slow_log;      /*  9235     1 */
	bool                       derived_tables_processing; /*  9236     1 */
	bool                       parsing_system_view;  /*  9237     1 */

	/* XXX 2 bytes hole, try to pack */

	class sp_rcontext *        sp_runtime_ctx;       /*  9240     8 */
	class sp_cache *           sp_proc_cache;        /*  9248     8 */
	class sp_cache *           sp_func_cache;        /*  9256     8 */
	uint                       query_name_consts;    /*  9264     4 */

	/* XXX 4 bytes hole, try to pack */

	class LOG_INFO *           current_linfo;        /*  9272     8 */
	/* --- cacheline 145 boundary (9280 bytes) --- */
	ulonglong                  current_connect_time; /*  9280     8 */
	ulonglong                  last_global_update_time; /*  9288     8 */
	double                     busy_time;            /*  9296     8 */
	double                     diff_total_busy_time; /*  9304     8 */
	double                     cpu_time;             /*  9312     8 */
	double                     diff_total_cpu_time;  /*  9320     8 */
	ulonglong                  bytes_received;       /*  9328     8 */
	ulonglong                  diff_total_bytes_received; /*  9336     8 */
	/* --- cacheline 146 boundary (9344 bytes) --- */
	ulonglong                  bytes_sent;           /*  9344     8 */
	ulonglong                  diff_total_bytes_sent; /*  9352     8 */
	ulonglong                  binlog_bytes_written; /*  9360     8 */
	ulonglong                  diff_total_binlog_bytes_written; /*  9368     8 */
	ha_rows                    diff_total_sent_rows; /*  9376     8 */
	ha_rows                    diff_total_updated_rows; /*  9384     8 */
	ha_rows                    diff_total_read_rows; /*  9392     8 */
	ulonglong                  diff_select_commands; /*  9400     8 */
	/* --- cacheline 147 boundary (9408 bytes) --- */
	ulonglong                  diff_update_commands; /*  9408     8 */
	ulonglong                  diff_other_commands;  /*  9416     8 */
	ulonglong                  diff_commit_trans;    /*  9424     8 */
	ulonglong                  diff_rollback_trans;  /*  9432     8 */
	ulonglong                  diff_denied_connections; /*  9440     8 */
	ulonglong                  diff_lost_connections; /*  9448     8 */
	ulonglong                  diff_access_denied_errors; /*  9456     8 */
	ulonglong                  diff_empty_queries;   /*  9464     8 */
	/* --- cacheline 148 boundary (9472 bytes) --- */
	ulonglong                  query_delay_millis;   /*  9472     8 */
	union {
		bool               bool_value;           /*  9480     1 */
		long int           long_value;           /*  9480     8 */
		ulong              ulong_value;          /*  9480     8 */
		ulonglong          ulonglong_value;      /*  9480     8 */
		double             double_value;         /*  9480     8 */
	} sys_var_tmp;                                   /*  9480     8 */
	struct {
		bool               do_union;             /*  9488     1 */
		bool               unioned_events;       /*  9489     1 */
		bool               unioned_events_trans; /*  9490     1 */

		/* XXX 5 bytes hole, try to pack */

		query_id_t         first_query_id;       /*  9496     8 */
	} binlog_evt_union;                              /*  9488    16 */
	class Parser_state *       m_parser_state;       /*  9504     8 */
	class Locked_tables_list  locked_tables_list;    /*  9512   136 */
	/* --- cacheline 150 boundary (9600 bytes) was 48 bytes ago --- */
	class partition_info *     work_part_info;       /*  9648     8 */
	class Plugin_array        audit_class_plugins;   /*  9656    32 */
	/* --- cacheline 151 boundary (9664 bytes) was 24 bytes ago --- */
	class Prealloced_array<long unsigned int, 11> audit_class_mask; /*  9688    96 */
	/* --- cacheline 152 boundary (9728 bytes) was 56 bytes ago --- */
	bool                       m_enable_plugins;     /*  9784     1 */
	bool                       m_audited;            /*  9785     1 */
	void THD(class THD *, bool);

	virtual void ~THD(class THD *, int);

	void release_resources(class THD *);

	bool release_resources_done(const class THD  *);

	bool                       m_release_resources_done; /*  9786     1 */
	bool                       cleanup_done;         /*  9787     1 */

	/* XXX 4 bytes hole, try to pack */
	void cleanup(class THD *);

	void init(class THD *);

	void init_query_mem_roots(class THD *);

	void cleanup_connection(class THD *);

	void reset_stats(class THD *);

	void reset_diff_stats(class THD *);

	void update_stats(class THD *, bool);

	void cleanup_after_query(class THD *);

	void store_globals(class THD *);

	void restore_globals(class THD *);

	void set_active_vio(class THD *, class Vio *);

	void set_ssl(class THD *, class Vio *);

	void clear_active_vio(class THD *);

	void set_clone_vio(class THD *, class Vio *);

	void clear_clone_vio(class THD *);

	bool check_clone_vio(class THD *);

	void shutdown_clone_vio(class THD *);

	enum enum_vio_type get_vio_type(const class THD  *);

	void shutdown_active_vio(class THD *);

	void awake(class THD *, enum killed_state);

	void disconnect(class THD *, bool);

	int binlog_query(class THD *, enum enum_binlog_query_type, const char  *, size_t, bool, bool, bool, int);

	virtual void enter_cond(class THD *, class mysql_cond_t *, class mysql_mutex_t *, const PSI_stage_info  *, PSI_stage_info *, const char  *, const char  *, int);

	virtual void exit_cond(class THD *, const PSI_stage_info  *, const char  *, const char  *, int);

	virtual int is_killed(const class THD  *);

	virtual bool might_have_commit_order_waiters(const class THD  *);

	virtual class THD * get_thd(class THD *);

	virtual void notify_shared_lock(class THD *, class MDL_context_owner *, bool);

	virtual bool notify_hton_pre_acquire_exclusive(class THD *, const class MDL_key  *, bool *);

	virtual void notify_hton_post_release_exclusive(class THD *, const class MDL_key  *);

	virtual uint get_rand_seed(const class THD  *);

	bool is_strict_mode(const class THD  *);

	const class CHARSET_INFO  * collation(class THD *);

	class Time_zone * time_zone(class THD *);

	time_t query_start_in_secs(const class THD  *);

	ulonglong query_start_in_usecs(const class THD  *);

	class timeval query_start_timeval_trunc(class THD *, uint);

	void set_time(class THD *);

	void set_time(class THD *, const class timeval  *);

	void get_time(const class THD  *, class QUERY_START_TIME_INFO *);

	void set_time(class THD *, const class QUERY_START_TIME_INFO  &);

	void set_time_after_lock(class THD *);

	bool is_fsp_truncate_mode(const class THD  *);

	ulonglong current_utime(void);

	void update_slow_query_status(class THD *);

	ulonglong found_rows(const class THD  *);

	void update_previous_found_rows(class THD *);

	bool in_multi_stmt_transaction_mode(const class THD  *);

	bool in_active_multi_stmt_transaction(const class THD  *);

	bool fill_information_schema_tables(const class THD  *);

	bool convert_string(class THD *, LEX_STRING *, const class CHARSET_INFO  *, const char  *, size_t, const class CHARSET_INFO  *, bool);

	int send_explain_fields(class THD *, class Query_result *);

	void clear_error(class THD *);

	bool is_classic_protocol(const class THD  *);

	virtual bool is_connected(class THD *);

	void fatal_error(class THD *);

	bool is_fatal_error(const class THD  *);

	bool is_error(const class THD  *);

	class Diagnostics_area * get_stmt_da(class THD *);

	const class Diagnostics_area  * get_stmt_da(const class THD  *);

	const class Diagnostics_area  * get_stacked_da(const class THD  *);

	class Diagnostics_area * get_parser_da(class THD *);

	class Diagnostics_area * get_query_rewrite_plugin_da(class THD *);

	void push_diagnostics_area(class THD *, class Diagnostics_area *, bool);

	void pop_diagnostics_area(class THD *);

	void push_protocol(class THD *, class Protocol *);

	void pop_protocol(class THD *);

	const class CHARSET_INFO  * charset(const class THD  *);

	void update_charset(class THD *);

	void change_item_tree(class THD *, class Item * *, class Item *);

	void nocheck_register_item_tree_change(class THD *, class Item * *, class Item *);

	void rollback_item_tree_changes(class THD *);

	void end_statement(class THD *);

	void send_kill_message(const class THD  *);

	void reset_n_backup_open_tables_state(class THD *, class Open_tables_backup *, uint);

	void restore_backup_open_tables_state(class THD *, class Open_tables_backup *);

	void reset_sub_statement_state(class THD *, class Sub_statement_state *, uint);

	void restore_sub_statement_state(class THD *, class Sub_statement_state *);

	void begin_attachable_ro_transaction(class THD *);

	void begin_attachable_rw_transaction(class THD *);

	void end_attachable_transaction(class THD *);

	bool is_attachable_ro_transaction_active(const class THD  *);

	bool is_attachable_transaction_active(const class THD  *);

	bool is_attachable_rw_transaction_active(const class THD  *);

	void set_current_stmt_binlog_format_row_if_mixed(class THD *);

	void set_current_stmt_binlog_format_row(class THD *);

	void clear_current_stmt_binlog_format_row(class THD *);

	void reset_current_stmt_binlog_format_row(class THD *);

	void set_original_commit_timestamp_for_slave_thread(class THD *);

	class Gtid_set * get_gtid_next_list(class THD *);

	const class Gtid_set  * get_gtid_next_list_const(const class THD  *);

	bool is_binlog_cache_empty(const class THD  *, bool);


	/* --- cacheline 153 boundary (9792 bytes) --- */
	struct Gtid                owned_gtid;           /*  9792    16 */

	/* Bitfield combined with previous fields */

	static const int                  OWNED_SIDNO_GTID_SET = 18446744073709551615; /*     0     0 */
	static const int                  OWNED_SIDNO_ANONYMOUS = 18446744073709551614; /*     0     0 */
	rpl_sid                    owned_sid;            /*  9808    16 */
	typedef struct bitset<5> Se_GTID_flagset;

	Se_GTID_flagset            m_se_gtid_flags;      /*  9824     8 */
	void pin_gtid(class THD *);

	void unpin_gtid(class THD *);

	bool is_one_phase_commit(class THD *);

	void set_log_reset(class THD *);

	void clear_log_reset(class THD *);

	bool is_log_reset(const class THD  *);

	void set_gtid_persisted_by_se(class THD *);

	void request_persist_gtid_by_se(class THD *);

	void reset_gtid_persisted_by_se(class THD *);

	bool se_persists_gtid(const class THD  *);

	bool se_persists_gtid_explicit(const class THD  *);

	bool is_extrenal_xa(const class THD  *);

	class Rpl_thd_context     rpl_thd_ctx;           /*  9832    88 */

	/* XXX last struct has 4 bytes of padding */
	void clear_owned_gtids(class THD *);

	bool owned_gtid_is_empty(class THD *);


	/* --- cacheline 155 boundary (9920 bytes) --- */
	bool                       skip_gtid_rollback;   /*  9920     1 */
	bool                       is_commit_in_middle_of_statement; /*  9921     1 */
	bool                       has_gtid_consistency_violation; /*  9922     1 */

	/* XXX 5 bytes hole, try to pack */
	const LEX_CSTRING  & db(const class THD  *);

	bool set_db(class THD *, const LEX_CSTRING  &);

	void reset_db(class THD *, const LEX_CSTRING  &);

	bool copy_db_to(const class THD  *, const char  * *, size_t *);

	bool copy_db_to(const class THD  *, char * *, size_t *);


	class thd_scheduler       event_scheduler;       /*  9928     8 */
	class Resource_group_ctx * resource_group_ctx(class THD *);

	void set_psi(class THD *, PSI_thread *);

	PSI_thread * get_psi(const class THD  *);

	struct atomic<PSI_thread*> m_psi;                /*  9936     8 */
	const class Internal_error_handler  * get_internal_handler(const class THD  *);

	void push_internal_handler(class THD *, class Internal_error_handler *);

	bool handle_condition(class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	class Internal_error_handler * pop_internal_handler(class THD *);

	class Opt_trace_context   opt_trace;             /*  9944    16 */

	/* XXX last struct has 4 bytes of padding */
	void raise_error(class THD *, uint);

	void raise_error_printf(class THD *, uint, ...);

	void raise_warning(class THD *, uint);

	void raise_warning_printf(class THD *, uint, ...);

	void raise_note(class THD *, uint);

	void raise_note_printf(class THD *, uint, ...);

	class Sql_condition * raise_condition(class THD *, uint, const char  *, enum enum_severity_level, const char  *, bool);

	void set_command(class THD *, enum enum_server_command);

	enum enum_server_command get_command(const class THD  *);

	void debug_assert_query_locked(const class THD  *);

	const LEX_CSTRING  & query(const class THD  *);

	const class String  normalized_query(class THD *);

	void set_query_for_display(class THD *, const char  *, size_t);

	void reset_query_for_display(class THD *);

	bool safe_to_display(const class THD  *);

	void set_safe_display(class THD *, bool);

	void set_query(class THD *, const char  *, size_t);

	void set_query(class THD *, LEX_CSTRING);

	void reset_query(class THD *);

	void swap_rewritten_query(class THD *, class String &);

	const class String  & rewritten_query(const class THD  *);

	void reset_rewritten_query(class THD *);

	void set_query_id(class THD *, query_id_t);

	void set_open_tables(class THD *, class TABLE *);

	void set_is_killable(class THD *, bool);

	void enter_locked_tables_mode(class THD *, enum enum_locked_tables_mode);

	void leave_locked_tables_mode(class THD *);

	int decide_logging_format(class THD *, class TABLE_LIST *);

	bool is_dml_gtid_compatible(class THD *, bool, bool, bool);

	bool is_ddl_gtid_compatible(class THD *);

	void binlog_invoker(class THD *);

	bool need_binlog_invoker(const class THD  *);

	void get_definer(class THD *, class LEX_USER *);

	void set_invoker(class THD *, const LEX_STRING  *, const LEX_STRING  *);

	LEX_CSTRING get_invoker_user(const class THD  *);

	LEX_CSTRING get_invoker_host(const class THD  *);

	bool has_invoker(const class THD  *);

	void mark_transaction_to_rollback(class THD *, bool);


	class Internal_error_handler * m_internal_handler; /*  9960     8 */
	struct MEM_ROOT            main_mem_root;        /*  9968    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 157 boundary (10048 bytes) --- */
	class Diagnostics_area    main_da;               /* 10048   736 */
	/* --- cacheline 168 boundary (10752 bytes) was 32 bytes ago --- */
	class Diagnostics_area    m_parser_da;           /* 10784   736 */
	/* --- cacheline 180 boundary (11520 bytes) --- */
	class Diagnostics_area    m_query_rewrite_plugin_da; /* 11520   736 */
	/* --- cacheline 191 boundary (12224 bytes) was 32 bytes ago --- */
	class Diagnostics_area *   m_query_rewrite_plugin_da_ptr; /* 12256     8 */
	class Diagnostics_area *   m_stmt_da;            /* 12264     8 */
	bool                       m_binlog_invoker;     /* 12272     1 */

	/* XXX 7 bytes hole, try to pack */

	LEX_CSTRING                m_invoker_user;       /* 12280    16 */
	/* --- cacheline 192 boundary (12288 bytes) was 8 bytes ago --- */
	LEX_CSTRING                m_invoker_host;       /* 12296    16 */
	class Cost_model_server   m_cost_model;          /* 12312     0 */

	/* XXX 24 bytes hole, try to pack */
	void init_cost_model(class THD *);

	const class Cost_model_server  * cost_model(const class THD  *);


	class Session_tracker     session_tracker;       /* 12336    40 */
	/* --- cacheline 193 boundary (12352 bytes) was 24 bytes ago --- */
	class Session_sysvar_resource_manager session_sysvar_res_mgr; /* 12376    64 */
	void syntax_error(class THD *);

	void syntax_error(class THD *, const char  *, ...);

	void syntax_error(class THD *, int, ...);

	void syntax_error_at(class THD *, const class YYLTYPE  &);

	void syntax_error_at(class THD *, const class YYLTYPE  &, const char  *, ...);

	void syntax_error_at(class THD *, const class YYLTYPE  &, int, ...);

	void vsyntax_error_at(class THD *, const class YYLTYPE  &, const char  *, class typedef __va_list_tag __va_list_tag *);

	void vsyntax_error_at(class THD *, const char  *, const char  *, class typedef __va_list_tag __va_list_tag *);

	bool send_result_metadata(class THD *, const class mem_root_deque<Item*>  &, uint);

	bool send_result_set_row(class THD *, const class mem_root_deque<Item*>  &);

	void send_statement_status(class THD *);

	/* --- cacheline 194 boundary (12416 bytes) was 24 bytes ago --- */
	bool                       duplicate_slave_id;   /* 12440     1 */
	void claim_memory_ownership(class THD *, bool);

	bool is_a_srv_session(const class THD  *);

	void mark_as_srv_session(class THD *);

	const class st_plugin_int  * get_plugin(const class THD  *);

	void set_plugin(class THD *, const class st_plugin_int  *);

	bool is_plugin_fake_ddl(const class THD  *);

	void mark_plugin_fake_ddl(class THD *, bool);

	bool                       is_a_srv_session_thd; /* 12441     1 */

	/* XXX 6 bytes hole, try to pack */

	const class st_plugin_int  * m_plugin;           /* 12448     8 */
	bool                       m_is_plugin_fake_ddl; /* 12456     1 */
	bool                       waiting_for_disk_space; /* 12457     1 */

	/* XXX 2 bytes hole, try to pack */
	void set_waiting_for_disk_space(class THD *, bool);

	bool is_waiting_for_disk_space(const class THD  *);

	bool sql_parser(class THD *);

	void set_secondary_engine_optimization(class THD *, enum Secondary_engine_optimization);

	enum Secondary_engine_optimization secondary_engine_optimization(const class THD  *);

	bool is_secondary_storage_engine_eligible(const class THD  *);


	enum Secondary_engine_optimization m_secondary_engine_optimization; /* 12460     4 */
	void cleanup_after_parse_error(class THD *);

	struct atomic<bool>        m_is_system_user __attribute__((__aligned__(1))); /* 12464     1 */

	/* XXX 7 bytes hole, try to pack */
	bool is_system_user(class THD *);

	void set_system_user(class THD *, bool);


	class Transactional_ddl_context m_transactional_ddl; /* 12472    80 */
	/* --- cacheline 196 boundary (12544 bytes) was 8 bytes ago --- */
	bool                       m_inside_system_variable_global_update; /* 12552     1 */

	/* XXX 7 bytes hole, try to pack */

	class PS_PARAM *           bind_parameter_values; /* 12560     8 */
	long unsigned int          bind_parameter_values_count; /* 12568     8 */
	void copy_table_access_properties(class THD *, class THD *);

	class Attachable_trx_rw : public Attachable_trx {
	public:

		/* class Attachable_trx      <ancestor>; */      /*     0  1288 */
		virtual bool is_read_only(const class Attachable_trx_rw  *);

		void Attachable_trx_rw(class Attachable_trx_rw *, class THD *);

		void Attachable_trx_rw(class Attachable_trx_rw *, const class Attachable_trx_rw  &);

		class Attachable_trx_rw & operator=(class Attachable_trx_rw *, const class Attachable_trx_rw  &);

		virtual void ~Attachable_trx_rw(class Attachable_trx_rw *, int);

		/* vtable has 1 entries: {
		   [2] = is_read_only((null)), 
		} */
		/* size: 1288, cachelines: 21, members: 1 */
		/* last cacheline: 8 bytes */

		/* BRAIN FART ALERT! 1288 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 10304 bits */
	};

	/* tag__fprintf: const_type tag not supported! */;

	/* vtable has 10 entries: {
	   [2] = enter_cond((null)), 
	   [3] = exit_cond((null)), 
	   [4] = is_killed((null)), 
	   [6] = might_have_commit_order_waiters((null)), 
	   [7] = get_thd((null)), 
	   [8] = notify_shared_lock((null)), 
	   [9] = notify_hton_pre_acquire_exclusive((null)), 
	   [10] = notify_hton_post_release_exclusive((null)), 
	   [11] = get_rand_seed((null)), 
	   [5] = is_connected((null)), 
	} */
	/* size: 12576, cachelines: 197, members: 267, static members: 3 */
	/* sum members: 12272, holes: 32, sum holes: 184 */
	/* paddings: 10, sum paddings: 40 */
	/* forced alignments: 3 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 12576 bytes != 12272 (member bytes) + 0 (member bits) + 184 (byte holes) + 0 (bit holes), diff = 960 bits */
} __attribute__((__aligned__(8)));
struct PSI_thread_attrs_v3 {
	long long unsigned int     m_thread_internal_id; /*     0     8 */
	long unsigned int          m_processlist_id;     /*     8     8 */
	long long unsigned int     m_thread_os_id;       /*    16     8 */
	void *                     m_user_data;          /*    24     8 */
	char                       m_username[96];       /*    32    96 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	size_t                     m_username_length;    /*   128     8 */
	char                       m_hostname[255];      /*   136   255 */

	/* XXX 1 byte hole, try to pack */

	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
	size_t                     m_hostname_length;    /*   392     8 */
	char                       m_groupname[192];     /*   400   192 */
	/* --- cacheline 9 boundary (576 bytes) was 16 bytes ago --- */
	size_t                     m_groupname_length;   /*   592     8 */
	struct sockaddr_storage    m_sock_addr;          /*   600   128 */
	/* --- cacheline 11 boundary (704 bytes) was 24 bytes ago --- */
	socklen_t                  m_sock_addr_length;   /*   728     4 */
	bool                       m_system_thread;      /*   732     1 */

	/* size: 736, cachelines: 12, members: 13 */
	/* sum members: 732, holes: 1, sum holes: 1 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */
};
struct PSI_notification_v3 {
	PSI_notification_cb_v3     thread_create;        /*     0     8 */
	PSI_notification_cb_v3     thread_destroy;       /*     8     8 */
	PSI_notification_cb_v3     session_connect;      /*    16     8 */
	PSI_notification_cb_v3     session_disconnect;   /*    24     8 */
	PSI_notification_cb_v3     session_change_user;  /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct PSI_transaction_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     m_class;              /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	long long unsigned int     m_timer_start;        /*    24     8 */
	long long unsigned int     (*m_timer)(void);     /*    32     8 */
	void *                     m_transaction;        /*    40     8 */
	bool                       m_read_only;          /*    48     1 */
	bool                       m_autocommit;         /*    49     1 */

	/* XXX 6 bytes hole, try to pack */

	long unsigned int          m_statement_count;    /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	long unsigned int          m_savepoint_count;    /*    64     8 */
	long unsigned int          m_rollback_to_savepoint_count; /*    72     8 */
	long unsigned int          m_release_savepoint_count; /*    80     8 */

	/* size: 88, cachelines: 2, members: 12 */
	/* sum members: 78, holes: 2, sum holes: 10 */
	/* last cacheline: 24 bytes */
};
struct PSI_stage_service_v1 {
	register_stage_v1_t        register_stage;       /*     0     8 */
	start_stage_v1_t           start_stage;          /*     8     8 */
	get_current_stage_progress_v1_t get_current_stage_progress; /*    16     8 */
	end_stage_v1_t             end_stage;            /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct PSI_statement_service_v2 {
	register_statement_v1_t    register_statement;   /*     0     8 */
	get_thread_statement_locker_v1_t get_thread_statement_locker; /*     8     8 */
	refine_statement_v1_t      refine_statement;     /*    16     8 */
	start_statement_v1_t       start_statement;      /*    24     8 */
	set_statement_text_v1_t    set_statement_text;   /*    32     8 */
	set_statement_query_id_t   set_statement_query_id; /*    40     8 */
	set_statement_lock_time_t  set_statement_lock_time; /*    48     8 */
	set_statement_rows_sent_t  set_statement_rows_sent; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	set_statement_rows_examined_t set_statement_rows_examined; /*    64     8 */
	inc_statement_created_tmp_disk_tables_t inc_statement_created_tmp_disk_tables; /*    72     8 */
	inc_statement_created_tmp_tables_t inc_statement_created_tmp_tables; /*    80     8 */
	inc_statement_select_full_join_t inc_statement_select_full_join; /*    88     8 */
	inc_statement_select_full_range_join_t inc_statement_select_full_range_join; /*    96     8 */
	inc_statement_select_range_t inc_statement_select_range; /*   104     8 */
	inc_statement_select_range_check_t inc_statement_select_range_check; /*   112     8 */
	inc_statement_select_scan_t inc_statement_select_scan; /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	inc_statement_sort_merge_passes_t inc_statement_sort_merge_passes; /*   128     8 */
	inc_statement_sort_range_t inc_statement_sort_range; /*   136     8 */
	inc_statement_sort_rows_t  inc_statement_sort_rows; /*   144     8 */
	inc_statement_sort_scan_t  inc_statement_sort_scan; /*   152     8 */
	set_statement_no_index_used_t set_statement_no_index_used; /*   160     8 */
	set_statement_no_good_index_used_t set_statement_no_good_index_used; /*   168     8 */
	end_statement_v1_t         end_statement;        /*   176     8 */
	create_prepared_stmt_v1_t  create_prepared_stmt; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	destroy_prepared_stmt_v1_t destroy_prepared_stmt; /*   192     8 */
	reprepare_prepared_stmt_v1_t reprepare_prepared_stmt; /*   200     8 */
	execute_prepared_stmt_v1_t execute_prepared_stmt; /*   208     8 */
	set_prepared_stmt_text_v1_t set_prepared_stmt_text; /*   216     8 */
	digest_start_v1_t          digest_start;         /*   224     8 */
	digest_end_v1_t            digest_end;           /*   232     8 */
	get_sp_share_v1_t          get_sp_share;         /*   240     8 */
	release_sp_share_v1_t      release_sp_share;     /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	start_sp_v1_t              start_sp;             /*   256     8 */
	end_sp_v1_t                end_sp;               /*   264     8 */
	drop_sp_v1_t               drop_sp;              /*   272     8 */

	/* size: 280, cachelines: 5, members: 35 */
	/* last cacheline: 24 bytes */
};
struct PSI_thread_service_v4 {
	register_thread_v1_t       register_thread;      /*     0     8 */
	spawn_thread_v1_t          spawn_thread;         /*     8     8 */
	new_thread_v1_t            new_thread;           /*    16     8 */
	set_thread_id_v1_t         set_thread_id;        /*    24     8 */
	get_current_thread_internal_id_v2_t get_current_thread_internal_id; /*    32     8 */
	get_thread_internal_id_v2_t get_thread_internal_id; /*    40     8 */
	get_thread_by_id_v2_t      get_thread_by_id;     /*    48     8 */
	set_thread_THD_v1_t        set_thread_THD;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	set_thread_os_id_v1_t      set_thread_os_id;     /*    64     8 */
	get_thread_v1_t            get_thread;           /*    72     8 */
	set_thread_user_v1_t       set_thread_user;      /*    80     8 */
	set_thread_account_v1_t    set_thread_account;   /*    88     8 */
	set_thread_db_v1_t         set_thread_db;        /*    96     8 */
	set_thread_command_v1_t    set_thread_command;   /*   104     8 */
	set_connection_type_v1_t   set_connection_type;  /*   112     8 */
	set_thread_start_time_v1_t set_thread_start_time; /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	set_thread_start_time_usec_v4_t set_thread_start_time_usec; /*   128     8 */
	set_thread_rows_sent_v4_t  set_thread_rows_sent; /*   136     8 */
	set_thread_rows_examined_v4_t set_thread_rows_examined; /*   144     8 */
	set_thread_info_v1_t       set_thread_info;      /*   152     8 */
	set_thread_resource_group_v1_t set_thread_resource_group; /*   160     8 */
	set_thread_resource_group_by_id_v1_t set_thread_resource_group_by_id; /*   168     8 */
	set_thread_v1_t            set_thread;           /*   176     8 */
	set_thread_peer_port_v4_t  set_thread_peer_port; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	aggregate_thread_status_v2_t aggregate_thread_status; /*   192     8 */
	delete_current_thread_v1_t delete_current_thread; /*   200     8 */
	delete_thread_v1_t         delete_thread;        /*   208     8 */
	set_thread_connect_attrs_v1_t set_thread_connect_attrs; /*   216     8 */
	get_current_thread_event_id_v2_t get_current_thread_event_id; /*   224     8 */
	get_thread_event_id_v2_t   get_thread_event_id;  /*   232     8 */
	get_thread_system_attrs_v3_t get_thread_system_attrs; /*   240     8 */
	get_thread_system_attrs_by_id_v3_t get_thread_system_attrs_by_id; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	register_notification_v3_t register_notification; /*   256     8 */
	unregister_notification_v1_t unregister_notification; /*   264     8 */
	notify_session_connect_v1_t notify_session_connect; /*   272     8 */
	notify_session_disconnect_v1_t notify_session_disconnect; /*   280     8 */
	notify_session_change_user_v1_t notify_session_change_user; /*   288     8 */

	/* size: 296, cachelines: 5, members: 37 */
	/* last cacheline: 40 bytes */
};
struct my_thread_scheduler_service {
	int                        (*connection_handler_set)(class Connection_handler_functions *, class THD_event_functions *); /*     0     8 */
	int                        (*connection_handler_reset)(void); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct THD_event_functions {
	void                       (*thd_wait_begin)(class THD *, int); /*     0     8 */
	void                       (*thd_wait_end)(class THD *); /*     8     8 */
	void                       (*post_kill_notification)(class THD *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct NET {
	class Vio *                vio;                  /*     0     8 */
	unsigned char *            buff;                 /*     8     8 */
	unsigned char *            buff_end;             /*    16     8 */
	unsigned char *            write_pos;            /*    24     8 */
	unsigned char *            read_pos;             /*    32     8 */
	my_socket                  fd;                   /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int          remain_in_buf;        /*    48     8 */
	long unsigned int          length;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	long unsigned int          buf_length;           /*    64     8 */
	long unsigned int          where_b;              /*    72     8 */
	long unsigned int          max_packet;           /*    80     8 */
	long unsigned int          max_packet_size;      /*    88     8 */
	unsigned int               pkt_nr;               /*    96     4 */
	unsigned int               compress_pkt_nr;      /*   100     4 */
	unsigned int               write_timeout;        /*   104     4 */
	unsigned int               read_timeout;         /*   108     4 */
	unsigned int               retry_count;          /*   112     4 */
	int                        fcntl;                /*   116     4 */
	unsigned int *             return_status;        /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	unsigned char              reading_or_writing;   /*   128     1 */
	unsigned char              save_char;            /*   129     1 */
	bool                       compress;             /*   130     1 */

	/* XXX 1 byte hole, try to pack */

	unsigned int               last_errno;           /*   132     4 */
	unsigned char              error;                /*   136     1 */
	char                       last_error[512];      /*   137   512 */
	/* --- cacheline 10 boundary (640 bytes) was 9 bytes ago --- */
	char                       sqlstate[6];          /*   649     6 */

	/* XXX 1 byte hole, try to pack */

	void *                     extension;            /*   656     8 */

	/* size: 664, cachelines: 11, members: 27 */
	/* sum members: 658, holes: 3, sum holes: 6 */
	/* last cacheline: 24 bytes */
};
struct Vio {
	struct MYSQL_SOCKET        mysql_socket;         /*     0    16 */
	bool                       localhost;            /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	enum enum_vio_type         type;                 /*    20     4 */
	int                        read_timeout;         /*    24     4 */
	int                        write_timeout;        /*    28     4 */
	int                        retry_count;          /*    32     4 */
	bool                       inactive;             /*    36     1 */
	bool                       force_skip_proxy;     /*    37     1 */

	/* XXX 2 bytes hole, try to pack */

	struct sockaddr_storage    local;                /*    40   128 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	struct sockaddr_storage    remote;               /*   168   128 */
	/* --- cacheline 4 boundary (256 bytes) was 40 bytes ago --- */
	size_t                     addrLen;              /*   296     8 */
	char *                     read_buffer;          /*   304     8 */
	char *                     read_pos;             /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	char *                     read_end;             /*   320     8 */
	my_thread_t                thread_id;            /*   328     8 */
	sigset_t                   signal_mask;          /*   336   128 */
	/* --- cacheline 7 boundary (448 bytes) was 16 bytes ago --- */
	struct atomic_flag         poll_shutdown_flag;   /*   464     1 */
	char                       network_namespace[256]; /*   465   256 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 11 boundary (704 bytes) was 24 bytes ago --- */
	void                       (*viodelete)(class Vio *); /*   728     8 */
	int                        (*vioerrno)(class Vio *); /*   736     8 */
	size_t                     (*read)(class Vio *, uchar *, size_t); /*   744     8 */
	size_t                     (*write)(class Vio *, const uchar  *, size_t); /*   752     8 */
	int                        (*timeout)(class Vio *, uint, bool); /*   760     8 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	int                        (*viokeepalive)(class Vio *, bool); /*   768     8 */
	int                        (*fastsend)(class Vio *); /*   776     8 */
	bool                       (*peer_addr)(class Vio *, char *, uint16 *, size_t); /*   784     8 */
	void                       (*in_addr)(class Vio *, class sockaddr_storage *); /*   792     8 */
	bool                       (*should_retry)(class Vio *); /*   800     8 */
	bool                       (*was_timeout)(class Vio *); /*   808     8 */
	int                        (*vioshutdown)(class Vio *, int); /*   816     8 */
	int                        (*viocancel)(class Vio *, int); /*   824     8 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	bool                       (*is_connected)(class Vio *); /*   832     8 */
	bool                       (*has_data)(class Vio *); /*   840     8 */
	int                        (*io_wait)(class Vio *, enum enum_vio_io_event, int); /*   848     8 */
	bool                       (*connect)(class Vio *, class sockaddr *, socklen_t, int); /*   856     8 */
	void *                     ssl_arg;              /*   864     8 */
	class PSI_socket_locker *  m_psi_read_locker;    /*   872     8 */
	PSI_socket_locker_state    m_psi_read_state;     /*   880    80 */
	/* --- cacheline 15 boundary (960 bytes) --- */
	class PSI_socket_locker *  m_psi_write_locker;   /*   960     8 */
	PSI_socket_locker_state    m_psi_write_state;    /*   968    80 */
	/* --- cacheline 16 boundary (1024 bytes) was 24 bytes ago --- */
	bool                       (*is_blocking)(class Vio *); /*  1048     8 */
	int                        (*set_blocking)(class Vio *, bool); /*  1056     8 */
	int                        (*set_blocking_flag)(class Vio *, bool); /*  1064     8 */
	bool                       is_blocking_flag;     /*  1072     1 */
private:

	void Vio(class Vio *, uint);

	void ~Vio(class Vio *, int);

	void Vio(class Vio *, const class Vio  &);

	class Vio & operator=(class Vio *, const class Vio  &);

	class Vio & operator=(class Vio *, );


	/* size: 1080, cachelines: 17, members: 44 */
	/* sum members: 1061, holes: 3, sum holes: 12 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct rand_struct {
	long unsigned int          seed1;                /*     0     8 */
	long unsigned int          seed2;                /*     8     8 */
	long unsigned int          max_value;            /*    16     8 */
	double                     max_value_dbl;        /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct UDF_ARGS {
	unsigned int               arg_count;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	enum Item_result *         arg_type;             /*     8     8 */
	char * *                   args;                 /*    16     8 */
	long unsigned int *        lengths;              /*    24     8 */
	char *                     maybe_null;           /*    32     8 */
	char * *                   attributes;           /*    40     8 */
	long unsigned int *        attribute_lengths;    /*    48     8 */
	void *                     extension;            /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct UDF_INIT {
	bool                       maybe_null;           /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               decimals;             /*     4     4 */
	long unsigned int          max_length;           /*     8     8 */
	char *                     ptr;                  /*    16     8 */
	bool                       const_item;           /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	void *                     extension;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 30, holes: 2, sum holes: 10 */
	/* last cacheline: 40 bytes */
};
struct compression_attributes {
	char                       compress_algorithm[32]; /*     0    32 */
	unsigned int               compress_level;       /*    32     4 */
	bool                       compression_optional; /*    36     1 */
	void compression_attributes(class compression_attributes *);


	/* size: 40, cachelines: 1, members: 3 */
	/* padding: 3 */
	/* last cacheline: 40 bytes */
};
struct NET_SERVER {
	before_header_callback_fn  m_before_header;      /*     0     8 */
	after_header_callback_fn   m_after_header;       /*     8     8 */
	void *                     m_user_data;          /*    16     8 */
	struct compression_attributes compression;       /*    24    40 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) --- */
	mysql_compress_context     compress_ctx;         /*    64    32 */
	long unsigned int          max_interval_packet;  /*    96     8 */
	long long unsigned int     net_buffer_shrink_time; /*   104     8 */
	void NET_SERVER(class NET_SERVER *);


	/* size: 112, cachelines: 2, members: 7 */
	/* paddings: 1, sum paddings: 3 */
	/* last cacheline: 48 bytes */
};
struct user_conn {
	char *                     user;                 /*     0     8 */
	char *                     host;                 /*     8     8 */
	ulonglong                  reset_utime;          /*    16     8 */
	size_t                     len;                  /*    24     8 */
	uint                       connections;          /*    32     4 */
	uint                       conn_per_hour;        /*    36     4 */
	uint                       updates;              /*    40     4 */
	uint                       questions;            /*    44     4 */
	USER_RESOURCES             user_resources;       /*    48    20 */

	/* size: 72, cachelines: 2, members: 9 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
class Security_context {
public:

	void Security_context(class Security_context *, class THD *);

	void ~Security_context(class Security_context *, int);

	void Security_context(class Security_context *, const class Security_context  &);

	class Security_context & operator=(class Security_context *, const class Security_context  &);

	void skip_grants(class Security_context *, const char  *, const char  *);

	bool is_skip_grants_user(class Security_context *);

	LEX_CSTRING user(const class Security_context  *);

	void set_user_ptr(class Security_context *, const char  *, size_t);

	void assign_user(class Security_context *, const char  *, size_t);

	class pair<bool, bool> has_global_grant(class Security_context *, const char  *, size_t);

	class pair<bool, bool> has_global_grant(class Security_context *, const class Auth_id  &, const string  &, bool);

	bool can_operate_with(class Security_context *, const class Auth_id  &, const string  &, bool, bool, bool);

	int activate_role(class Security_context *, LEX_CSTRING, LEX_CSTRING, bool);

	void clear_active_roles(class Security_context *);

	List_of_auth_id_refs * get_active_roles(class Security_context *);

	size_t get_num_active_roles(const class Security_context  *);

	void get_active_roles(class Security_context *, class THD *, class List<LEX_USER> &);

	void checkout_access_maps(class Security_context *);

	ulong db_acl(const class Security_context  *, LEX_CSTRING, bool);

	ulong procedure_acl(class Security_context *, LEX_CSTRING, LEX_CSTRING);

	ulong function_acl(class Security_context *, LEX_CSTRING, LEX_CSTRING);

	ulong table_acl(class Security_context *, LEX_CSTRING, LEX_CSTRING);

	class Grant_table_aggregate table_and_column_acls(class Security_context *, LEX_CSTRING, LEX_CSTRING);

	bool has_with_admin_acl(class Security_context *, const LEX_CSTRING  &, const LEX_CSTRING  &);

	bool any_sp_acl(class Security_context *, const LEX_CSTRING  &);

	bool any_table_acl(class Security_context *, const LEX_CSTRING  &);

	bool is_table_blocked(class Security_context *, ulong, const class TABLE  *);

	bool has_column_access(class Security_context *, ulong, const class TABLE  *, class vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basi);

	LEX_CSTRING host(const class Security_context  *);

	void set_host_ptr(class Security_context *, const char  *, size_t);

	void assign_host(class Security_context *, const char  *, size_t);

	LEX_CSTRING ip(const class Security_context  *);

	void set_ip_ptr(class Security_context *, const char  *, int);

	void assign_ip(class Security_context *, const char  *, int);

	LEX_CSTRING host_or_ip(const class Security_context  *);

	void set_host_or_ip_ptr(class Security_context *);

	void set_host_or_ip_ptr(class Security_context *, const char  *, int);

	LEX_CSTRING external_user(const class Security_context  *);

	void set_external_user_ptr(class Security_context *, const char  *, int);

	void assign_external_user(class Security_context *, const char  *, int);

	LEX_CSTRING priv_user(const class Security_context  *);

	void assign_priv_user(class Security_context *, const char  *, size_t);

	LEX_CSTRING proxy_user(const class Security_context  *);

	void assign_proxy_user(class Security_context *, const char  *, size_t);

	LEX_CSTRING priv_host(const class Security_context  *);

	void assign_priv_host(class Security_context *, const char  *, size_t);

	const char  * priv_host_name(const class Security_context  *);

	ulong master_access(const class Security_context  *);

	ulong master_access(const class Security_context  *, const string  &);

	const class Restrictions  restrictions(const class Security_context  *);

	void set_master_access(class Security_context *, ulong);

	void set_master_access(class Security_context *, ulong, const class Restrictions  &);

	bool has_account_assigned(const class Security_context  *);

	bool check_access(class Security_context *, ulong, const string  &, bool);

	ulong current_db_access(const class Security_context  *);

	void cache_current_db_access(class Security_context *, ulong);

	bool password_expired(const class Security_context  *);

	void set_password_expired(class Security_context *, bool);

	bool change_security_context(class Security_context *, class THD *, const LEX_CSTRING  &, const LEX_CSTRING  &, const char  *, class Security_context * *, bool);

	void restore_security_context(class Security_context *, class THD *, class Security_context *);

	bool user_matches(class Security_context *, class Security_context *);

	void logout(class Security_context *);

	bool account_is_locked(class Security_context *);

	void lock_account(class Security_context *, bool);

	void set_drop_policy(class Security_context *, const class function<void(Security_context*)>  &);

	void add_as_local_temp_privs(class Security_context *, const class vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11);

	bool check_in_local_temp_privs(class Security_context *, const string  &);

	bool has_drop_policy(class Security_context *);

	bool has_executed_drop_policy(class Security_context *);

	void execute_drop_policy(class Security_context *);

	bool is_access_restricted_on_db(const class Security_context  *, ulong, const string  &);

	void clear_db_restrictions(class Security_context *);

	void set_thd(class Security_context *, class THD *);

	class THD * get_thd(class Security_context *);

	void init(class Security_context *);

	void destroy(class Security_context *);

	void copy_security_ctx(class Security_context *, const class Security_context  &);

	ulong filter_access(const class Security_context  *, ulong, const string  &);

	void init_restrictions(class Security_context *, const class Restrictions  &);

	class pair<bool, bool> fetch_global_grant(class Security_context *, const class ACL_USER  &, const string  &, bool);

	bool has_table_access(class Security_context *, ulong, class TABLE_LIST *);

	class String              m_user;                /*     0    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_host;                /*    32    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) --- */
	class String              m_ip;                  /*    64    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_host_or_ip;          /*    96    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) --- */
	class String              m_external_user;       /*   128    32 */

	/* XXX last struct has 3 bytes of padding */

	char                       m_priv_user[96];      /*   160    96 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	size_t                     m_priv_user_length;   /*   256     8 */
	char                       m_proxy_user[357];    /*   264   357 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 9 boundary (576 bytes) was 48 bytes ago --- */
	size_t                     m_proxy_user_length;  /*   624     8 */
	char                       m_priv_host[256];     /*   632   256 */
	/* --- cacheline 13 boundary (832 bytes) was 56 bytes ago --- */
	size_t                     m_priv_host_length;   /*   888     8 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	ulong                      m_master_access;      /*   896     8 */
	ulong                      m_db_access;          /*   904     8 */
	bool                       m_password_expired;   /*   912     1 */

	/* XXX 7 bytes hole, try to pack */

	List_of_auth_id_refs       m_active_roles;       /*   920    24 */
	class Acl_map *            m_acl_map;            /*   944     8 */
	int                        m_map_checkout_count; /*   952     4 */
	bool                       m_is_locked;          /*   956     1 */
	bool                       m_is_skip_grants_user; /*   957     1 */
	bool                       m_executed_drop_policy; /*   958     1 */
	bool                       m_has_drop_policy;    /*   959     1 */
	/* --- cacheline 15 boundary (960 bytes) --- */
	class unique_ptr<std::function<void(Security_context*)>, std::default_delete<std::function<void(Security_context*)> > > m_drop_policy; /*   960     8 */
	class Restrictions        m_restrictions;        /*   968    64 */

	/* XXX last struct has 64 bytes of padding */

	/* --- cacheline 16 boundary (1024 bytes) was 8 bytes ago --- */
	class THD *                m_thd;                /*  1032     8 */

	/* size: 1040, cachelines: 17, members: 24 */
	/* sum members: 1030, holes: 2, sum holes: 10 */
	/* paddings: 6, sum paddings: 79 */
	/* last cacheline: 16 bytes */
};
class Auth_id {
public:

	void Auth_id(class Auth_id *);

	void Auth_id(class Auth_id *, const char  *, size_t, const char  *, size_t);

	void Auth_id(class Auth_id *, const Auth_id_ref  &);

	void Auth_id(class Auth_id *, const LEX_CSTRING  &, const LEX_CSTRING  &);

	void Auth_id(class Auth_id *, const string  &, const string  &);

	void Auth_id(class Auth_id *, const class LEX_USER  *);

	void Auth_id(class Auth_id *, const class ACL_USER  *);

	void ~Auth_id(class Auth_id *, int);

	void Auth_id(class Auth_id *, const class Auth_id  &);

	class Auth_id & operator=(class Auth_id *, const class Auth_id  &);

	bool operator<(const class Auth_id  *, const class Auth_id  &);

	void auth_str(const class Auth_id  *, string *);

	string auth_str(const class Auth_id  *);

	const string  & user(const class Auth_id  *);

	const string  & host(const class Auth_id  *);

	void create_key(class Auth_id *);

	string                     m_user;               /*     0    32 */
	string                     m_host;               /*    32    32 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	string                     m_key;                /*    64    32 */

	/* size: 96, cachelines: 2, members: 3 */
	/* last cacheline: 32 bytes */
};
struct LEX_USER {
	LEX_CSTRING                user;                 /*     0    16 */
	LEX_CSTRING                host;                 /*    16    16 */
	LEX_CSTRING                plugin;               /*    32    16 */
	LEX_CSTRING                auth;                 /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	LEX_CSTRING                current_auth;         /*    64    16 */
	bool                       uses_identified_by_clause; /*    80     1 */
	bool                       uses_identified_with_clause; /*    81     1 */
	bool                       uses_authentication_string_clause; /*    82     1 */
	bool                       uses_replace_clause;  /*    83     1 */
	bool                       retain_current_password; /*    84     1 */
	bool                       discard_old_password; /*    85     1 */
	bool                       has_password_generator; /*    86     1 */

	/* XXX 1 byte hole, try to pack */

	struct LEX_ALTER           alter_status;         /*    88    44 */
	class LEX_USER * alloc(class THD *, LEX_STRING *, LEX_STRING *);

	class LEX_USER * init(class LEX_USER *, class THD *, LEX_STRING *, LEX_STRING *);


	/* size: 136, cachelines: 3, members: 13 */
	/* sum members: 131, holes: 1, sum holes: 1 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct rw_pr_lock_t {
	native_mutex_t             lock;                 /*     0    40 */
	native_cond_t              no_active_readers;    /*    40    48 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	unsigned int               active_readers;       /*    88     4 */
	unsigned int               writers_waiting_readers; /*    92     4 */
	bool                       active_writer;        /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	my_thread_t                writer_thread;        /*   104     8 */

	/* size: 112, cachelines: 2, members: 6 */
	/* sum members: 105, holes: 1, sum holes: 7 */
	/* last cacheline: 48 bytes */
};
struct mysql_rwlock_t {
	native_rw_lock_t           m_rwlock;             /*     0    56 */
	class PSI_rwlock *         m_psi;                /*    56     8 */

	/* size: 64, cachelines: 1, members: 2 */
};
struct PSI_rwlock : PSI_instr {
	/* struct PSI_instr           <ancestor>; */     /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */

	/* BRAIN FART ALERT! 1 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 8 bits */
};
struct mysql_prlock_t {
	struct rw_pr_lock_t        m_prlock;             /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	class PSI_rwlock *         m_psi;                /*   112     8 */

	/* size: 120, cachelines: 2, members: 2 */
	/* last cacheline: 56 bytes */
};
struct PSI_rwlock_info_v1 {
	PSI_rwlock_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */
	int                        m_volatility;         /*    20     4 */
	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct PSI_rwlock_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */
	enum PSI_rwlock_operation  m_operation;          /*     4     4 */
	class PSI_rwlock *         m_rwlock;             /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	long long unsigned int     m_timer_start;        /*    24     8 */
	long long unsigned int     (*m_timer)(void);     /*    32     8 */
	void *                     m_wait;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct PSI_rwlock_service_v2 {
	register_rwlock_v1_t       register_rwlock;      /*     0     8 */
	init_rwlock_v1_t           init_rwlock;          /*     8     8 */
	destroy_rwlock_v1_t        destroy_rwlock;       /*    16     8 */
	start_rwlock_rdwait_v1_t   start_rwlock_rdwait;  /*    24     8 */
	end_rwlock_rdwait_v1_t     end_rwlock_rdwait;    /*    32     8 */
	start_rwlock_wrwait_v1_t   start_rwlock_wrwait;  /*    40     8 */
	end_rwlock_wrwait_v1_t     end_rwlock_wrwait;    /*    48     8 */
	unlock_rwlock_v2_t         unlock_rwlock;        /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
class Restrictions {
public:

	void Restrictions(class Restrictions *);

	void Restrictions(class Restrictions *, const class Restrictions  &);

	void Restrictions(class Restrictions *, );

	class Restrictions & operator=(class Restrictions *, const class Restrictions  &);

	class Restrictions & operator=(class Restrictions *, );

	bool has_more_db_restrictions(class Restrictions *, const class Restrictions  &, ulong);

	void ~Restrictions(class Restrictions *, int);

	const class DB_restrictions  & db(const class Restrictions  *);

	void set_db(class Restrictions *, const class DB_restrictions  &);

	void clear_db(class Restrictions *);

	bool is_empty(const class Restrictions  *);

	class DB_restrictions     m_db_restrictions;     /*     0     0 */

	/* size: 64, cachelines: 1, members: 1 */
	/* padding: 64 */
};
class Simple_cstring {
	const char  *              m_str;                /*     0     8 */
	size_t                     m_length;             /*     8     8 */
public:

	void set(class Simple_cstring *, const char  *, size_t);

	void Simple_cstring(class Simple_cstring *);

	void Simple_cstring(class Simple_cstring *, const char  *, size_t);

	void Simple_cstring(class Simple_cstring *, LEX_STRING);

	void Simple_cstring(class Simple_cstring *, LEX_CSTRING);

	void reset(class Simple_cstring *);

	void set(class Simple_cstring *, const char  *);

	const char  * ptr(const class Simple_cstring  *);

	bool is_set(const class Simple_cstring  *);

	size_t length(const class Simple_cstring  *);

	bool eq_bin(const class Simple_cstring  *, class Simple_cstring);

	void strcpy(const class Simple_cstring  *, char *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class String {
	char *                     m_ptr;                /*     0     8 */
	size_t                     m_length;             /*     8     8 */
	const class CHARSET_INFO  * m_charset;           /*    16     8 */
	uint32                     m_alloced_length;     /*    24     4 */
	bool                       m_is_alloced;         /*    28     1 */
public:

	void String(class String *);

	void String(class String *, size_t);

	void String(class String *, const char  *, const class CHARSET_INFO  *);

	void String(class String *, const char  *, size_t, const class CHARSET_INFO  *);

	void String(class String *, char *, size_t, const class CHARSET_INFO  *);

	void String(class String *, const class String  &);

	void String(class String *, );

	void * operator new(size_t, class MEM_ROOT *, const class nothrow_t  &);

	void operator delete(void *, size_t);

	void operator delete(void *, class MEM_ROOT *, const class nothrow_t  &);

	void ~String(class String *, int);

	void set_charset(class String *, const class CHARSET_INFO  *);

	const class CHARSET_INFO  * charset(const class String  *);

	size_t length(const class String  *);

	size_t alloced_length(const class String  *);

	const char  & operator[](const class String  *, size_t);

	char & operator[](class String *, size_t);

	void length(class String *, size_t);

	bool is_empty(const class String  *);

	void mark_as_const(class String *);

	const char  * ptr(const class String  *);

	char * ptr(class String *);

	char * c_ptr(class String *);

	char * c_ptr_quick(class String *);

	char * c_ptr_safe(class String *);

	LEX_STRING lex_string(class String *);

	LEX_CSTRING lex_cstring(const class String  *);

	void set(class String *, class String &, size_t, size_t);

	void set(class String *, char *, size_t, const class CHARSET_INFO  *);

	void set(class String *, const char  *, size_t, const class CHARSET_INFO  *);

	bool set_ascii(class String *, const char  *, size_t);

	void set_quick(class String *, char *, size_t, const class CHARSET_INFO  *);

	bool set_int(class String *, longlong, bool, const class CHARSET_INFO  *);

	bool set(class String *, longlong, const class CHARSET_INFO  *);

	bool set(class String *, ulonglong, const class CHARSET_INFO  *);

	bool set_real(class String *, double, uint, const class CHARSET_INFO  *);

	void chop(class String *);

	void mem_claim(class String *, bool);

	void mem_free(class String *);

	bool alloc(class String *, size_t);

	bool real_alloc(class String *, size_t);

	bool mem_realloc(class String *, size_t, bool);

	size_t next_realloc_exp_size(class String *, size_t);

	bool mem_realloc_exp(class String *, size_t);

	void shrink(class String *, size_t);

	bool is_alloced(const class String  *);

	class String & operator=(class String *, const class String  &);

	class String & operator=(class String *, );

	void takeover(class String *, class String &);

	bool copy(class String *);

	bool copy(class String *, const class String  &);

	bool copy(class String *, const char  *, size_t, const class CHARSET_INFO  *);

	bool needs_conversion(size_t, const class CHARSET_INFO  *, const class CHARSET_INFO  *, size_t *);

	bool needs_conversion(const class String  *, const class CHARSET_INFO  *);

	bool is_valid_string(const class String  *, const class CHARSET_INFO  *);

	bool needs_conversion_on_storage(size_t, const class CHARSET_INFO  *, const class CHARSET_INFO  *);

	bool copy_aligned(class String *, const char  *, size_t, size_t, const class CHARSET_INFO  *);

	bool set_or_copy_aligned(class String *, const char  *, size_t, const class CHARSET_INFO  *);

	bool copy(class String *, const char  *, size_t, const class CHARSET_INFO  *, const class CHARSET_INFO  *, uint *);

	bool append(class String *, const class String  &);

	bool append(class String *, const char  *);

	bool append(class String *, LEX_STRING *);

	bool append(class String *, class Simple_cstring);

	bool append(class String *, const char  *, size_t);

	bool append(class String *, const char  *, size_t, const class CHARSET_INFO  *);

	bool append_ulonglong(class String *, ulonglong);

	bool append_longlong(class String *, longlong);

	bool append_with_prefill(class String *, const char  *, size_t, size_t, char);

	bool append_parenthesized(class String *, int64_t);

	int strstr(const class String  *, const class String  &, size_t);

	int strrstr(const class String  *, const class String  &, size_t);

	class String substr(const class String  *, int, int);

	bool replace(class String *, size_t, size_t, const char  *, size_t);

	bool replace(class String *, size_t, size_t, const class String  &);

	bool append(class String *, char);

	bool fill(class String *, size_t, char);

	size_t numchars(const class String  *);

	size_t charpos(const class String  *, size_t, size_t);

	bool reserve(class String *, size_t);

	bool reserve(class String *, size_t, size_t);

	char * prep_append(class String *, size_t, size_t);

	bool append(class String *, const char  *, size_t, size_t);

	void print(const class String  *, class String *);

	void swap(class String *, class String &);

	bool uses_buffer_owned_by(const class String  *, const class String  *);

	bool is_ascii(const class String  *);

	char * dup(const class String  *, class MEM_ROOT *);


	/* size: 32, cachelines: 1, members: 5 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */
};
class List<LEX_USER> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<LEX_USER> *);

	void List(class List<LEX_USER> *, const class List<LEX_USER>  &);

	class List<LEX_USER> & operator=(class List<LEX_USER> *, const class List<LEX_USER>  &);

	void List(class List<LEX_USER> *, const class List<LEX_USER>  &, class MEM_ROOT *);

	bool push_back(class List<LEX_USER> *, class LEX_USER *);

	bool push_back(class List<LEX_USER> *, class LEX_USER *, class MEM_ROOT *);

	bool push_front(class List<LEX_USER> *, class LEX_USER *);

	bool push_front(class List<LEX_USER> *, class LEX_USER *, class MEM_ROOT *);

	class LEX_USER * head(class List<LEX_USER> *);

	const class LEX_USER  * head(const class List<LEX_USER>  *);

	class LEX_USER * * head_ref(class List<LEX_USER> *);

	class LEX_USER * pop(class List<LEX_USER> *);

	void concat(class List<LEX_USER> *, class List<LEX_USER> *);

	void disjoin(class List<LEX_USER> *, class List<LEX_USER> *);

	void prepend(class List<LEX_USER> *, class List<LEX_USER> *);

	void delete_elements(class List<LEX_USER> *);

	void destroy_elements(class List<LEX_USER> *);

	class LEX_USER * operator[](const class List<LEX_USER>  *, uint);

	void replace(class List<LEX_USER> *, uint, class LEX_USER *);

	bool swap_elts(class List<LEX_USER> *, uint, uint);

	typedef struct List_STL_Iterator<LEX_USER> iterator;

	iterator begin(class List<LEX_USER> *);

	iterator end(class List<LEX_USER> *);

	typedef struct List_STL_Iterator<const LEX_USER> const_iterator;

	const_iterator begin(const class List<LEX_USER>  *);

	const_iterator end(const class List<LEX_USER>  *);

	const_iterator cbegin(const class List<LEX_USER>  *);

	const_iterator cend(const class List<LEX_USER>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct TABLE {
	struct {
		class JOIN_TAB *           join_tab;             /*     0     8 */
		class QEP_TAB *            qep_tab;              /*     8     8 */
		enum thr_lock_type         lock_type;            /*    16     4 */
		enum thr_locked_row_action locked_row_action;    /*    20     4 */
		bool                       not_exists_optimize;  /*    24     1 */
		bool                       impossible_range;     /*    25     1 */

		/* size: 32, cachelines: 1, members: 6 */
		/* padding: 6 */
		/* last cacheline: 32 bytes */
	};

	class TABLE_SHARE *        s;                    /*     0     8 */
	class handler *            file;                 /*     8     8 */
	class TABLE *              next;                 /*    16     8 */
	class TABLE *              prev;                 /*    24     8 */
private:

	class TABLE *              cache_next;           /*    32     8 */
	class TABLE * *            cache_prev;           /*    40     8 */
	struct MY_BITMAP           fields_for_functional_indexes; /*    48    32 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class THD *                in_use;               /*    80     8 */
	class Field * *            field;                /*    88     8 */
	uint                       hidden_field_count;   /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	uchar *                    record[2];            /*   104    16 */
	uchar *                    write_row_record;     /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uchar *                    insert_values;        /*   128     8 */
	class Record_buffer       m_record_buffer;       /*   136    40 */

	/* XXX last struct has 7 bytes of padding */

	Key_map                    covering_keys;        /*   176     8 */
	Key_map                    quick_keys;           /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	Key_map                    merge_keys;           /*   192     8 */
	Key_map                    possible_quick_keys;  /*   200     8 */
	Key_map                    keys_in_use_for_query; /*   208     8 */
	Key_map                    keys_in_use_for_group_by; /*   216     8 */
	Key_map                    keys_in_use_for_order_by; /*   224     8 */
	class KEY *                key_info;             /*   232     8 */
	class KEY_PART_INFO *      base_key_parts;       /*   240     8 */
	class Field *              next_number_field;    /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	class Field *              found_next_number_field; /*   256     8 */
	class Field * *            vfield;               /*   264     8 */
	class Field * *            gen_def_fields_ptr;   /*   272     8 */
	class Field *              hash_field;           /*   280     8 */
	class Field *              fts_doc_id_field;     /*   288     8 */
	class Table_trigger_dispatcher * triggers;       /*   296     8 */
	class TABLE_LIST *         pos_in_table_list;    /*   304     8 */
	class TABLE_LIST *         pos_in_locked_tables; /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	class ORDER *              group;                /*   320     8 */
	const char  *              alias;                /*   328     8 */
	uchar *                    null_flags;           /*   336     8 */
	uchar *                    null_flags_saved;     /*   344     8 */
	struct MY_BITMAP           def_read_set;         /*   352    32 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	struct MY_BITMAP           def_write_set;        /*   384    32 */
	struct MY_BITMAP           tmp_set;              /*   416    32 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	struct MY_BITMAP           pack_row_tmp_set;     /*   448    32 */
	struct MY_BITMAP           cond_set;             /*   480    32 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	struct MY_BITMAP           def_fields_set_during_insert; /*   512    32 */
	class MY_BITMAP *          read_set;             /*   544     8 */
	class MY_BITMAP *          write_set;            /*   552     8 */
	class MY_BITMAP *          fields_set_during_insert; /*   560     8 */
	query_id_t                 query_id;             /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	ha_rows                    quick_rows[64];       /*   576   512 */
	/* --- cacheline 17 boundary (1088 bytes) --- */
	key_part_map               const_key_parts[64];  /*  1088   512 */
	/* --- cacheline 25 boundary (1600 bytes) --- */
	uint                       quick_key_parts[64];  /*  1600   256 */
	/* --- cacheline 29 boundary (1856 bytes) --- */
	uint                       quick_n_ranges[64];   /*  1856   256 */
	/* --- cacheline 33 boundary (2112 bytes) --- */
	ha_rows                    quick_condition_rows; /*  2112     8 */
	uint                       lock_position;        /*  2120     4 */
	uint                       lock_data_start;      /*  2124     4 */
	uint                       lock_count;           /*  2128     4 */
	uint                       db_stat;              /*  2132     4 */
	int                        current_lock;         /*  2136     4 */

	/* XXX 4 bytes hole, try to pack */

	Sql_table_check_constraint_list * table_check_constraint_list; /*  2144     8 */
	bool                       nullable;             /*  2152     1 */
	uint8                      m_status;             /*  2153     1 */
	bool                       null_row;             /*  2154     1 */
	bool                       copy_blobs;           /*  2155     1 */
	bool                       force_index;          /*  2156     1 */
	bool                       force_index_order;    /*  2157     1 */
	bool                       force_index_group;    /*  2158     1 */
	bool                       const_table;          /*  2159     1 */
	bool                       no_rows;              /*  2160     1 */
	bool                       key_read;             /*  2161     1 */
	bool                       no_keyread;           /*  2162     1 */
	bool                       no_replicate;         /*  2163     1 */
	bool                       no_cache;             /*  2164     1 */
	bool                       open_by_handler;      /*  2165     1 */
	bool                       autoinc_field_has_explicit_non_null_value; /*  2166     1 */
	bool                       alias_name_used;      /*  2167     1 */
	bool                       get_fields_in_item_tree; /*  2168     1 */
	bool                       m_invalid_dict;       /*  2169     1 */
	bool                       m_invalid_stats;      /*  2170     1 */
	bool                       created;              /*  2171     1 */
	bool                       materialized;         /*  2172     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 34 boundary (2176 bytes) --- */
	struct {
		class JOIN_TAB *   join_tab;             /*  2176     8 */
		class QEP_TAB *    qep_tab;              /*  2184     8 */
		enum thr_lock_type lock_type;            /*  2192     4 */
		enum thr_locked_row_action locked_row_action; /*  2196     4 */
		bool               not_exists_optimize;  /*  2200     1 */
		bool               impossible_range;     /*  2201     1 */
	} reginfo;                                       /*  2176    32 */

	/* XXX last struct has 6 bytes of padding */

	struct MEM_ROOT            mem_root;             /*  2208    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	class Blob_mem_storage *   blob_storage;         /*  2288     8 */
	class SortingIterator *    sorting_iterator;     /*  2296     8 */
	/* --- cacheline 36 boundary (2304 bytes) --- */
	class SortingIterator *    duplicate_removal_iterator; /*  2304     8 */
	class Sort_result         unique_result;         /*  2312    40 */
	class partition_info *     part_info;            /*  2352     8 */
	bool                       all_partitions_pruned_away; /*  2360     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 37 boundary (2368 bytes) --- */
	class MDL_ticket *         mdl_ticket;           /*  2368     8 */
	class Cost_model_table    m_cost_model;          /*  2376    24 */
	void reset(class TABLE *);

	void init(class TABLE *, class THD *, class TABLE_LIST *);

	bool init_tmp_table(class TABLE *, class THD *, class TABLE_SHARE *, class MEM_ROOT *, class CHARSET_INFO *, const char  *, class Field * *, uint *, bool);

	bool fill_item_list(const class TABLE  *, class mem_root_deque<Item*> *);

	void reset_item_list(const class TABLE  *, const class mem_root_deque<Item*>  &);

	void clear_column_bitmaps(class TABLE *);

	void prepare_for_position(class TABLE *);

	void mark_column_used(class TABLE *, class Field *, enum enum_mark_columns);

	void mark_columns_used_by_index_no_reset(const class TABLE  *, uint, class MY_BITMAP *, uint);

	void mark_columns_used_by_index(class TABLE *, uint);

	void mark_auto_increment_column(class TABLE *);

	void mark_columns_needed_for_update(class TABLE *, class THD *, bool);

	void mark_columns_needed_for_delete(class TABLE *, class THD *);

	void mark_columns_needed_for_insert(class TABLE *, class THD *);

	void mark_columns_per_binlog_row_image(class TABLE *, class THD *);

	void mark_generated_columns(class TABLE *, bool);

	void mark_gcol_in_maps(class TABLE *, const class Field  *);

	void mark_check_constraint_columns(class TABLE *, bool);

	void column_bitmaps_set(class TABLE *, class MY_BITMAP *, class MY_BITMAP *);

	void column_bitmaps_set_no_signal(class TABLE *, class MY_BITMAP *, class MY_BITMAP *);

	void use_all_columns(class TABLE *);

	void default_column_bitmaps(class TABLE *);

	void invalidate_dict(class TABLE *);

	void invalidate_stats(class TABLE *);

	bool has_invalid_dict(const class TABLE  *);

	bool has_invalid_stats(class TABLE *);

	class Field * * visible_field_ptr(const class TABLE  *);

	uint visible_field_count(const class TABLE  *);

	bool alloc_tmp_keys(class TABLE *, uint, uint, bool);

	bool add_tmp_key(class TABLE *, Field_map *, bool, bool);

	void copy_tmp_key(class TABLE *, int, bool);

	void drop_unused_tmp_keys(class TABLE *, bool);

	void set_keyread(class TABLE *, bool);

	bool index_contains_some_virtual_gcol(const class TABLE  *, uint);

	void update_const_key_parts(class TABLE *, class Item *);

	bool check_read_removal(class TABLE *, uint);

	ptrdiff_t default_values_offset(const class TABLE  *);

	bool has_storage_handler(const class TABLE  *);

	void set_storage_handler(class TABLE *, class handler *);

	bool is_created(const class TABLE  *);

	void set_created(class TABLE *);

	void set_deleted(class TABLE *);

	void set_nullable(class TABLE *);

	bool is_nullable(const class TABLE  *);

	bool has_gcol(const class TABLE  *);

	void set_not_started(class TABLE *);

	bool is_started(const class TABLE  *);

	void set_found_row(class TABLE *);

	void set_no_row(class TABLE *);

	void set_row_status_from_handler(class TABLE *, int);

	void set_null_row(class TABLE *);

	void reset_null_row(class TABLE *);

	void set_updated_row(class TABLE *);

	void set_deleted_row(class TABLE *);

	bool has_row(const class TABLE  *);

	bool has_null_row(const class TABLE  *);

	bool has_updated_row(const class TABLE  *);

	bool has_deleted_row(const class TABLE  *);

	void save_null_flags(class TABLE *);

	void restore_null_flags(class TABLE *);

	bool empty_result_table(class TABLE *);

	void init_cost_model(class TABLE *, const class Cost_model_server  *);

	const class Cost_model_table  * cost_model(const class TABLE  *);

	void refix_value_generator_items(class TABLE *, class THD *);

	void refix_inner_value_generator_items(class TABLE *, class Value_generator *);

	void cleanup_value_generator_items(class TABLE *);

	bool has_compressed_columns(const class TABLE  *);

	bool has_compressed_columns_with_dictionaries(const class TABLE  *);

	void update_compressed_columns_info(class TABLE *, const class List<Create_field>  &);

	void update_covering_prefix_keys(class TABLE *, class Field *, uint16, Key_map *);

	class MY_BITMAP *          m_partial_update_columns; /*  2400     8 */
	class Partial_update_info * m_partial_update_info; /*  2408     8 */
	bool                       should_binlog_drop_if_temp_flag; /*  2416     1 */

	/* XXX 7 bytes hole, try to pack */
	bool has_binary_diff_columns(const class TABLE  *);

	const Binary_diff_vector  * get_binary_diffs(const class TABLE  *, const class Field  *);

	bool mark_column_for_partial_update(class TABLE *, const class Field  *);

	bool is_marked_for_partial_update(const class TABLE  *, const class Field  *);

	bool has_columns_marked_for_partial_update(const class TABLE  *);

	bool setup_partial_update(class TABLE *, bool);

	bool setup_partial_update(class TABLE *);

	bool add_binary_diff(class TABLE *, const class Field  *, size_t, size_t);

	void clear_partial_update_diffs(class TABLE *);

	void cleanup_partial_update(class TABLE *);

	void disable_binary_diffs_for_current_row(class TABLE *, const class Field  *);

	void disable_logical_diffs_for_current_row(const class TABLE  *, const class Field  *);

	class String * get_partial_update_buffer(class TABLE *);

	void add_logical_diff(class TABLE *, const class Field_json  *, const class Json_seekable_path  &, enum enum_json_diff_operation, const class Json_wrapper  *);

	const class Json_diff_vector  * get_logical_diffs(const class TABLE  *, const class Field_json  *);

	bool is_binary_diff_enabled(const class TABLE  *, const class Field  *);

	bool is_logical_diff_enabled(const class TABLE  *, const class Field  *);

	void blobs_need_not_keep_old_value(class TABLE *);

	void set_binlog_drop_if_temp(class TABLE *, bool);

	bool should_binlog_drop_if_temp(const class TABLE  *);

	void set_tmp_dd_table_ptr(class TABLE *, const class Table  *);

	const class Table  * get_tmp_dd_table_ptr(const class TABLE  *);


	const class Table  *       tmp_dd_table_ptr;     /*  2424     8 */

	/* size: 2432, cachelines: 38, members: 92 */
	/* sum members: 2407, holes: 5, sum holes: 25 */
	/* paddings: 3, sum paddings: 17 */
};
struct TABLE_LIST {
	enum {
		OPEN_NORMAL     = 0,
		OPEN_IF_EXISTS  = 1,
		OPEN_FOR_CREATE = 2,
		OPEN_STUB       = 3,
	};

	void TABLE_LIST(class TABLE_LIST *);

	void TABLE_LIST(class TABLE_LIST *, class TABLE *);

	void TABLE_LIST(class TABLE_LIST *, const char  *, const char  *, enum thr_lock_type);

	void TABLE_LIST(class TABLE_LIST *, class TABLE *, const char  *, size_t, const char  *, size_t, const char  *, enum thr_lock_type);

	void TABLE_LIST(class TABLE_LIST *, const char  *, const char  *, const char  *, enum thr_lock_type);

	void TABLE_LIST(class TABLE_LIST *, class TABLE *, const char  *);

	void TABLE_LIST(class TABLE_LIST *, class TABLE *, const char  *, enum enum_mdl_type);

	void TABLE_LIST(class TABLE_LIST *, const char  *, const char  *, enum thr_lock_type, enum enum_mdl_type);

	void TABLE_LIST(class TABLE_LIST *, const char  *, size_t, const char  *, size_t, enum thr_lock_type, enum enum_mdl_type);

	void TABLE_LIST(class TABLE_LIST *, const char  *, size_t, const char  *, size_t, enum thr_lock_type);

	void TABLE_LIST(class TABLE_LIST *, const char  *, size_t, const char  *, size_t, const char  *, enum enum_mdl_type);

	void TABLE_LIST(class TABLE_LIST *, const char  *, size_t, const char  *, size_t, const char  *, enum thr_lock_type, enum enum_mdl_type);

	void TABLE_LIST(class TABLE_LIST *, const char  *, size_t, const char  *, size_t, const char  *, enum thr_lock_type);

	class TABLE_LIST * new_nested_join(class MEM_ROOT *, const char  *, class TABLE_LIST *, class mem_root_deque<TABLE_LIST*> *, class Query_block *);

	class Item * * join_cond_ref(class TABLE_LIST *);

	class Item * join_cond(const class TABLE_LIST  *);

	void set_join_cond(class TABLE_LIST *, class Item *);

	class Item * join_cond_optim(const class TABLE_LIST  *);

	void set_join_cond_optim(class TABLE_LIST *, class Item *);

	class Item * * join_cond_optim_ref(class TABLE_LIST *);

	bool is_sj_nest(const class TABLE_LIST  *);

	bool is_aj_nest(const class TABLE_LIST  *);

	bool is_sj_or_aj_nest(const class TABLE_LIST  *);

	void set_sj_or_aj_nest(class TABLE_LIST *);

	bool merge_underlying_tables(class TABLE_LIST *, class Query_block *);

	void reset(class TABLE_LIST *);

	int view_check_option(const class TABLE_LIST  *, class THD *);

	void cleanup_items(class TABLE_LIST *);

	void print(const class TABLE_LIST  *, const class THD  *, class String *, enum enum_query_type);

	bool check_single_table(class TABLE_LIST *, class TABLE_LIST * *, table_map);

	bool set_insert_values(class TABLE_LIST *, class MEM_ROOT *);

	class TABLE_LIST * first_leaf_for_name_resolution(class TABLE_LIST *);

	class TABLE_LIST * last_leaf_for_name_resolution(class TABLE_LIST *);

	bool is_leaf_for_name_resolution(const class TABLE_LIST  *);

	const class TABLE_LIST  * top_table(const class TABLE_LIST  *);

	class TABLE_LIST * top_table(class TABLE_LIST *);

	bool prepare_check_option(class TABLE_LIST *, class THD *, bool);

	bool merge_where(class TABLE_LIST *, class THD *);

	bool prepare_replace_filter(class TABLE_LIST *, class THD *);

	bool is_view(const class TABLE_LIST  *);

	bool is_derived(const class TABLE_LIST  *);

	bool is_view_or_derived(const class TABLE_LIST  *);

	bool is_table_function(const class TABLE_LIST  *);

	bool is_recursive_reference(const class TABLE_LIST  *);

	bool is_base_table(const class TABLE_LIST  *);

	bool set_recursive_reference(class TABLE_LIST *);

	bool is_internal(const class TABLE_LIST  *);

	bool is_placeholder(const class TABLE_LIST  *);

	bool is_mergeable(const class TABLE_LIST  *);

	bool materializable_is_const(const class TABLE_LIST  *);

	bool is_merged(const class TABLE_LIST  *);

	void set_merged(class TABLE_LIST *);

	bool uses_materialization(const class TABLE_LIST  *);

	void set_uses_materialization(class TABLE_LIST *);

	bool is_updatable(const class TABLE_LIST  *);

	void set_updatable(class TABLE_LIST *);

	bool is_insertable(const class TABLE_LIST  *);

	void set_insertable(class TABLE_LIST *);

	bool is_updated(const class TABLE_LIST  *);

	void set_updated(class TABLE_LIST *);

	bool is_inserted(const class TABLE_LIST  *);

	void set_inserted(class TABLE_LIST *);

	bool is_deleted(const class TABLE_LIST  *);

	void set_deleted(class TABLE_LIST *);

	void set_fulltext_searched(class TABLE_LIST *);

	bool is_fulltext_searched(const class TABLE_LIST  *);

	void set_readonly(class TABLE_LIST *);

	bool is_multiple_tables(const class TABLE_LIST  *);

	uint leaf_tables_count(const class TABLE_LIST  *);

	class TABLE_LIST * first_leaf_table(class TABLE_LIST *);

	class TABLE_LIST * any_outer_leaf_table(class TABLE_LIST *);

	void set_view_query(class TABLE_LIST *, class LEX *);

	class LEX * view_query(const class TABLE_LIST  *);

	void set_derived_query_expression(class TABLE_LIST *, class Query_expression *);

	class Query_expression * derived_query_expression(const class TABLE_LIST  *);

	bool resolve_derived(class TABLE_LIST *, class THD *, bool);

	bool optimize_derived(class TABLE_LIST *, class THD *);

	bool create_materialized_table(class TABLE_LIST *, class THD *);

	bool materialize_derived(class TABLE_LIST *, class THD *);

	bool can_push_condition_to_derived(class TABLE_LIST *, class THD *);

	class Item * get_derived_expr(class TABLE_LIST *, uint);

	class Item * get_clone_for_derived_expr(class TABLE_LIST *, class THD *, class Item *, class Name_resolution_context *);

	void cleanup_derived(class TABLE_LIST *, class THD *);

	bool prepare_security(class TABLE_LIST *, class THD *);

	class Security_context * find_view_security_context(class TABLE_LIST *, class THD *);

	bool prepare_view_security_context(class TABLE_LIST *, class THD *);

	bool process_index_hints(class TABLE_LIST *, const class THD  *, class TABLE *);

	bool is_table_ref_id_equal(const class TABLE_LIST  *, class TABLE_SHARE *);

	void set_table_ref_id(class TABLE_LIST *, class TABLE_SHARE *);

	void set_table_ref_id(class TABLE_LIST *, enum enum_table_ref_type, ulonglong);

	uint query_block_id(const class TABLE_LIST  *);

	uint query_block_id_for_explain(const class TABLE_LIST  *);

	const char  * get_db_name(const class TABLE_LIST  *);

	const char  * get_table_name(const class TABLE_LIST  *);

	int fetch_number_of_rows(class TABLE_LIST *);

	bool update_derived_keys(class TABLE_LIST *, class THD *, class Field *, class Item * *, uint, bool *);

	bool generate_keys(class TABLE_LIST *);

	bool setup_materialized_derived(class TABLE_LIST *, class THD *);

	bool setup_materialized_derived_tmp_table(class TABLE_LIST *, class THD *);

	bool setup_table_function(class TABLE_LIST *, class THD *);

	bool create_field_translation(class TABLE_LIST *, class THD *);

	class TABLE_LIST * outer_join_nest(const class TABLE_LIST  *);

	bool is_inner_table_of_outer_join(const class TABLE_LIST  *);

	const class TABLE_LIST  * updatable_base_table(const class TABLE_LIST  *);

	class TABLE_LIST * updatable_base_table(class TABLE_LIST *);

	void add_join_natural(class TABLE_LIST *, class TABLE_LIST *);

	void set_privileges(class TABLE_LIST *, ulong);

	bool save_properties(class TABLE_LIST *);

	void restore_properties(class TABLE_LIST *);

	class TABLE_LIST *         next_local;           /*     0     8 */
	class TABLE_LIST *         next_global;          /*     8     8 */
	class TABLE_LIST * *       prev_global;          /*    16     8 */
	const char  *              db;                   /*    24     8 */
	const char  *              table_name;           /*    32     8 */
	const char  *              alias;                /*    40     8 */
	LEX_CSTRING                target_tablespace_name; /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     option;               /*    64     8 */
	class Opt_hints_table *    opt_hints_table;      /*    72     8 */
	class Opt_hints_qb *       opt_hints_qb;         /*    80     8 */
	void set_lock(class TABLE_LIST *, const class Lock_descriptor  &);

	const class Lock_descriptor  & lock_descriptor(const class TABLE_LIST  *);

private:

	uint                       m_tableno;            /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	table_map                  m_map;                /*    96     8 */
	class Item *               m_join_cond;          /*   104     8 */
	bool                       m_is_sj_or_aj_nest;   /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	table_map                  sj_inner_tables;      /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	class TABLE_LIST *         natural_join;         /*   128     8 */
	bool                       is_natural_join;      /*   136     1 */

	/* XXX 7 bytes hole, try to pack */

	class List<String> *       join_using_fields;    /*   144     8 */
	class List<Natural_join_column> * join_columns;  /*   152     8 */
	bool                       is_join_columns_complete; /*   160     1 */

	/* XXX 7 bytes hole, try to pack */

	class TABLE_LIST *         next_name_resolution_table; /*   168     8 */
	class List<Index_hint> *   index_hints;          /*   176     8 */
	class TABLE *              table;                /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	class Table_id            table_id;              /*   192     8 */
	class Query_result_union * derived_result;       /*   200     8 */
	class TABLE_LIST *         correspondent_table;  /*   208     8 */
	class Table_function *     table_function;       /*   216     8 */
	class AccessPath *         access_path_for_derived; /*   224     8 */
	class Query_expression *   derived;              /*   232     8 */
	class Common_table_expr *  m_common_table_expr;  /*   240     8 */
	const Create_col_name_list  * m_derived_column_names; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	class ST_SCHEMA_TABLE *    schema_table;         /*   256     8 */
	class Query_block *        schema_query_block;   /*   264     8 */
	bool                       schema_table_reformed; /*   272     1 */

	/* XXX 7 bytes hole, try to pack */

	class Temp_table_param *   schema_table_param;   /*   280     8 */
	class Query_block *        query_block;          /*   288     8 */
	class LEX *                view;                 /*   296     8 */
	class Field_translator *   field_translation;    /*   304     8 */
	class Field_translator *   field_translation_end; /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	class TABLE_LIST *         merge_underlying_list; /*   320     8 */
	class mem_root_deque<TABLE_LIST*> * view_tables; /*   328     8 */
	class TABLE_LIST *         belong_to_view;       /*   336     8 */
	class TABLE_LIST *         referencing_view;     /*   344     8 */
	class TABLE_LIST *         parent_l;             /*   352     8 */
	class Security_context *   security_ctx;         /*   360     8 */
	class Security_context *   view_sctx;            /*   368     8 */
	class TABLE_LIST *         next_leaf;            /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	class Item *               derived_where_cond;   /*   384     8 */
	class Item *               check_option;         /*   392     8 */
	class Item *               replace_filter;       /*   400     8 */
	LEX_STRING                 select_stmt;          /*   408    16 */
	LEX_STRING                 source;               /*   424    16 */
	LEX_STRING                 timestamp;            /*   440    16 */
	/* --- cacheline 7 boundary (448 bytes) was 8 bytes ago --- */
	struct LEX_USER            definer;              /*   456   136 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 9 boundary (576 bytes) was 16 bytes ago --- */
	ulonglong                  updatable_view;       /*   592     8 */
	ulonglong                  algorithm;            /*   600     8 */
	ulonglong                  view_suid;            /*   608     8 */
	ulonglong                  with_check;           /*   616     8 */
	class Name_resolution_context * m_merged_derived_context; /*   624     8 */
	enum enum_view_algorithm   effective_algorithm;  /*   632     4 */
	struct Lock_descriptor     m_lock_descriptor;    /*   636     8 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 10 boundary (640 bytes) was 8 bytes ago --- */
	struct GRANT_INFO          grant;                /*   648    56 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	bool                       outer_join;           /*   704     1 */
	bool                       join_order_swapped;   /*   705     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       shared;               /*   708     4 */
	size_t                     db_length;            /*   712     8 */
	size_t                     table_name_length;    /*   720     8 */
	bool                       m_updatable;          /*   728     1 */
	bool                       m_insertable;         /*   729     1 */
	bool                       m_updated;            /*   730     1 */
	bool                       m_inserted;           /*   731     1 */
	bool                       m_deleted;            /*   732     1 */
	bool                       m_fulltext_searched;  /*   733     1 */
	bool                       straight;             /*   734     1 */
	bool                       updating;             /*   735     1 */
	bool                       ignore_leaves;        /*   736     1 */

	/* XXX 7 bytes hole, try to pack */

	table_map                  dep_tables;           /*   744     8 */
	table_map                  join_cond_dep_tables; /*   752     8 */
	class NESTED_JOIN *        nested_join;          /*   760     8 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	class TABLE_LIST *         embedding;            /*   768     8 */
	class mem_root_deque<TABLE_LIST*> * join_list;   /*   776     8 */
	bool                       cacheable_table;      /*   784     1 */

	/* XXX 3 bytes hole, try to pack */

	enum enum_open_type        open_type;            /*   788     4 */
	bool                       contain_auto_increment; /*   792     1 */
	bool                       check_option_processed; /*   793     1 */
	bool                       replace_filter_processed; /*   794     1 */

	/* XXX 1 byte hole, try to pack */

	enum enum_table_type       required_type;        /*   796     4 */
	char                       timestamp_buffer[20]; /*   800    20 */
	bool                       prelocking_placeholder; /*   820     1 */

	/* XXX 3 bytes hole, try to pack */

	enum {
		OPEN_NORMAL     = 0,
		OPEN_IF_EXISTS  = 1,
		OPEN_FOR_CREATE = 2,
		OPEN_STUB       = 3,
	} open_strategy;                                 /*   824     4 */
	bool                       internal_tmp_table;   /*   828     1 */
	bool                       is_alias;             /*   829     1 */
	bool                       is_fqtn;              /*   830     1 */
	bool                       m_was_scalar_subquery; /*   831     1 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	class View_creation_ctx *  view_creation_ctx;    /*   832     8 */
	LEX_CSTRING                view_client_cs_name;  /*   840    16 */
	LEX_CSTRING                view_connection_cl_name; /*   856    16 */
	LEX_STRING                 view_body_utf8;       /*   872    16 */
	bool                       is_system_view;       /*   888     1 */
	bool                       is_dd_ctx_table;      /*   889     1 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 14 boundary (896 bytes) --- */
	class List<Derived_key>   derived_key_list;      /*   896    24 */
	uint8                      trg_event_map;        /*   920     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       i_s_requested_object; /*   924     4 */
	bool                       has_db_lookup_value;  /*   928     1 */
	bool                       has_table_lookup_value; /*   929     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       table_open_method;    /*   932     4 */
	bool                       schema_table_filled;  /*   936     1 */

	/* XXX 7 bytes hole, try to pack */

	class MDL_request         mdl_request;           /*   944   448 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 21 boundary (1344 bytes) was 48 bytes ago --- */
	bool                       view_no_explain;      /*  1392     1 */

	/* XXX 7 bytes hole, try to pack */

	class List<String> *       partition_names;      /*  1400     8 */
	void set_tableno(class TABLE_LIST *, uint);

	uint tableno(const class TABLE_LIST  *);

	table_map map(const class TABLE_LIST  *);

	class Common_table_expr * common_table_expr(const class TABLE_LIST  *);

	void set_common_table_expr(class TABLE_LIST *, class Common_table_expr *);

	const Create_col_name_list  * derived_column_names(const class TABLE_LIST  *);

	void set_derived_column_names(class TABLE_LIST *, const Create_col_name_list  *);

	/* --- cacheline 22 boundary (1408 bytes) --- */
	class Item *               m_join_cond_optim;    /*  1408     8 */
	class COND_EQUAL *         cond_equal;           /*  1416     8 */
	bool                       optimized_away;       /*  1424     1 */
	bool                       derived_keys_ready;   /*  1425     1 */
	bool                       m_is_recursive_reference; /*  1426     1 */

	/* XXX 1 byte hole, try to pack */

	enum enum_table_ref_type   m_table_ref_type;     /*  1428     4 */
	ulonglong                  m_table_ref_version;  /*  1432     8 */
	Key_map                    covering_keys_saved;  /*  1440     8 */
	Key_map                    merge_keys_saved;     /*  1448     8 */
	Key_map                    keys_in_use_for_query_saved; /*  1456     8 */
	Key_map                    keys_in_use_for_group_by_saved; /*  1464     8 */
	/* --- cacheline 23 boundary (1472 bytes) --- */
	Key_map                    keys_in_use_for_order_by_saved; /*  1472     8 */
	bool                       nullable_saved;       /*  1480     1 */
	bool                       force_index_saved;    /*  1481     1 */
	bool                       force_index_order_saved; /*  1482     1 */
	bool                       force_index_group_saved; /*  1483     1 */

	/* XXX 4 bytes hole, try to pack */

	struct MY_BITMAP           lock_partitions_saved; /*  1488    32 */
	struct MY_BITMAP           read_set_saved;       /*  1520    32 */
	/* --- cacheline 24 boundary (1536 bytes) was 16 bytes ago --- */
	struct MY_BITMAP           write_set_saved;      /*  1552    32 */
	my_bitmap_map              read_set_small[2];    /*  1584     8 */
	my_bitmap_map              write_set_small[2];   /*  1592     8 */

	/* size: 1600, cachelines: 25, members: 131 */
	/* sum members: 1518, holes: 18, sum holes: 82 */
	/* paddings: 2, sum paddings: 8 */
};
struct My_free_functor {
	void operator()(const class My_free_functor  *, void *, size_t);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class Stateless_allocator<char, dd::String_type_alloc, My_free_functor> {
public:

	void Stateless_allocator(class Stateless_allocator<char, dd::String_type_alloc, My_free_functor> *);

	typedef char * pointer;

	pointer address(const class Stateless_allocator<char, dd::String_type_alloc, My_free_functor>  *, reference);

	typedef char & reference;

	typedef const char  * const_pointer;

	const_pointer address(const class Stateless_allocator<char, dd::String_type_alloc, My_free_functor>  *, const_reference);

	typedef const char  & const_reference;

	pointer allocate(class Stateless_allocator<char, dd::String_type_alloc, My_free_functor> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Stateless_allocator<char, dd::String_type_alloc, My_free_functor> *, pointer, size_type);

	void destroy(class Stateless_allocator<char, dd::String_type_alloc, My_free_functor> *, pointer);

	size_type max_size(const class Stateless_allocator<char, dd::String_type_alloc, My_free_functor>  *);

	typedef char value_type;

	struct rebind<char> {
		typedef struct Stateless_allocator<char, dd::String_type_alloc, My_free_functor> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class Discrete_interval {
	ulonglong                  interval_min;         /*     0     8 */
	ulonglong                  interval_values;      /*     8     8 */
	ulonglong                  interval_max;         /*    16     8 */
public:

	class Discrete_interval *  next;                 /*    24     8 */
	bool in_range(const class Discrete_interval  *, ulonglong);

	void replace(class Discrete_interval *, ulonglong, ulonglong, ulonglong);

	void Discrete_interval(class Discrete_interval *, ulonglong, ulonglong, ulonglong);

	void Discrete_interval(class Discrete_interval *);

	ulonglong minimum(const class Discrete_interval  *);

	ulonglong values(const class Discrete_interval  *);

	ulonglong maximum(const class Discrete_interval  *);

	bool merge_if_contiguous(class Discrete_interval *, ulonglong, ulonglong, ulonglong);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Discrete_intervals_list {
	class Discrete_interval   first_interval;        /*     0    32 */
	class Discrete_interval *  head;                 /*    32     8 */
	class Discrete_interval *  tail;                 /*    40     8 */
	class Discrete_interval *  current;              /*    48     8 */
	uint                       elements;             /*    56     4 */
	void operator=(class Discrete_intervals_list *, class Discrete_intervals_list &);

	bool append(class Discrete_intervals_list *, class Discrete_interval *);

	void copy_shallow(class Discrete_intervals_list *, const class Discrete_intervals_list  *);

	void Discrete_intervals_list(class Discrete_intervals_list *, const class Discrete_intervals_list  &);

public:

	void Discrete_intervals_list(class Discrete_intervals_list *);

	void clear(class Discrete_intervals_list *);

	void swap(class Discrete_intervals_list *, class Discrete_intervals_list *);

	const class Discrete_interval  * get_next(class Discrete_intervals_list *);

	void ~Discrete_intervals_list(class Discrete_intervals_list *, int);

	bool append(class Discrete_intervals_list *, ulonglong, ulonglong, ulonglong);

	ulonglong minimum(const class Discrete_intervals_list  *);

	ulonglong maximum(const class Discrete_intervals_list  *);

	uint nb_elements(const class Discrete_intervals_list  *);


	/* size: 64, cachelines: 1, members: 5 */
	/* padding: 4 */
};
class Locked_tables_list {
	struct MDL_ticket_pair {
		class MDL_ticket *         m_src;                /*     0     8 */
		class MDL_ticket *         m_dst;                /*     8     8 */

		/* size: 16, cachelines: 1, members: 2 */
		/* last cacheline: 16 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	struct MEM_ROOT            m_locked_tables_root; /*     0    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class TABLE_LIST *         m_locked_tables;      /*    80     8 */
	class TABLE_LIST * *       m_locked_tables_last; /*    88     8 */
	class TABLE * *            m_reopen_array;       /*    96     8 */
	size_t                     m_locked_tables_count; /*   104     8 */
	typedef struct vector<Locked_tables_list::MDL_ticket_pair, std::allocator<Locked_tables_list::MDL_ticket_pair> > MDL_ticket_pairs;

	MDL_ticket_pairs           m_rename_tablespace_mdls; /*   112    24 */
public:

	void Locked_tables_list(class Locked_tables_list *);

	void unlock_locked_tables(class Locked_tables_list *, class THD *);

	void ~Locked_tables_list(class Locked_tables_list *, int);

	bool init_locked_tables(class Locked_tables_list *, class THD *);

	class TABLE_LIST * locked_tables(const class Locked_tables_list  *);

	void unlink_from_list(class Locked_tables_list *, const class THD  *, class TABLE_LIST *, bool);

	void unlink_all_closed_tables(class Locked_tables_list *, class THD *, class MYSQL_LOCK *, size_t);

	bool reopen_tables(class Locked_tables_list *, class THD *);

	void rename_locked_table(class Locked_tables_list *, class TABLE_LIST *, const char  *, const char  *, class MDL_ticket *);

	void add_rename_tablespace_mdls(class Locked_tables_list *, class MDL_ticket *, class MDL_ticket *);

	void adjust_renamed_tablespace_mdls(class Locked_tables_list *, class MDL_context *);

	void discard_renamed_tablespace_mdls(class Locked_tables_list *);


	/* size: 136, cachelines: 3, members: 6 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 8 bytes */
};
struct MYSQL_LOCK {
	class TABLE * *            table;                /*     0     8 */
	uint                       table_count;          /*     8     4 */
	uint                       lock_count;           /*    12     4 */
	class THR_LOCK_DATA * *    locks;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
class MDL_context {
public:

	void MDL_context(class MDL_context *);

	void destroy(class MDL_context *);

	bool try_acquire_lock(class MDL_context *, class MDL_request *);

	bool acquire_lock(class MDL_context *, class MDL_request *, Timeout_type);

	bool acquire_locks(class MDL_context *, MDL_request_list *, Timeout_type);

	bool upgrade_shared_lock(class MDL_context *, class MDL_ticket *, enum enum_mdl_type, Timeout_type);

	bool clone_ticket(class MDL_context *, class MDL_request *);

	bool clone_tickets(class MDL_context *, const class MDL_context  *, enum enum_mdl_duration);

	void release_all_locks_for_name(class MDL_context *, class MDL_ticket *);

	void release_locks(class MDL_context *, class MDL_release_locks_visitor *);

	void release_lock(class MDL_context *, class MDL_ticket *);

	bool owns_equal_or_stronger_lock(class MDL_context *, const class MDL_key  *, enum enum_mdl_type);

	bool owns_equal_or_stronger_lock(class MDL_context *, enum enum_mdl_namespace, const char  *, const char  *, enum enum_mdl_type);

	bool find_lock_owner(class MDL_context *, const class MDL_key  *, class MDL_context_visitor *);

	bool has_lock(class MDL_context *, const class MDL_savepoint  &, class MDL_ticket *);

	bool has_locks(const class MDL_context  *);

	bool has_locks(const class MDL_context  *, enum enum_mdl_namespace);

	bool has_locks_waited_for(const class MDL_context  *);

	class MDL_savepoint mdl_savepoint(class MDL_context *);

	void set_explicit_duration_for_all_locks(class MDL_context *);

	void set_transaction_duration_for_all_locks(class MDL_context *);

	void set_lock_duration(class MDL_context *, class MDL_ticket *, enum enum_mdl_duration);

	void release_statement_locks(class MDL_context *);

	void release_transactional_locks(class MDL_context *);

	void rollback_to_savepoint(class MDL_context *, const class MDL_savepoint  &);

	class MDL_context_owner * get_owner(const class MDL_context  *);

	uint get_deadlock_weight(const class MDL_context  *);

	void init(class MDL_context *, class MDL_context_owner *);

	void set_needs_thr_lock_abort(class MDL_context *, bool);

	bool get_needs_thr_lock_abort(const class MDL_context  *);

	void set_force_dml_deadlock_weight(class MDL_context *, bool);

	uint get_random(class MDL_context *);

	class THD * get_thd(const class MDL_context  *);

	class MDL_wait            m_wait;                /*     0   112 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	class MDL_ticket_store    m_ticket_store;        /*   112    80 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	class MDL_context_owner *  m_owner;              /*   192     8 */
	bool                       m_needs_thr_lock_abort; /*   200     1 */
	bool                       m_force_dml_deadlock_weight; /*   201     1 */

	/* XXX 6 bytes hole, try to pack */

	struct mysql_prlock_t      m_LOCK_waiting_for;   /*   208   120 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	class MDL_wait_for_subgraph * m_waiting_for;     /*   328     8 */
	class LF_PINS *            m_pins;               /*   336     8 */
	uint                       m_rand_state;         /*   344     4 */
	class MDL_ticket * find_ticket(class MDL_context *, class MDL_request *, enum enum_mdl_duration *);

	void release_locks_stored_before(class MDL_context *, enum enum_mdl_duration, class MDL_ticket *);

	void release_lock(class MDL_context *, enum enum_mdl_duration, class MDL_ticket *);

	bool try_acquire_lock_impl(class MDL_context *, class MDL_request *, class MDL_ticket * *);

	void materialize_fast_path_locks(class MDL_context *);

	bool fix_pins(class MDL_context *);

	void find_deadlock(class MDL_context *);

	bool visit_subgraph(class MDL_context *, class MDL_wait_for_graph_visitor *);

	void will_wait_for(class MDL_context *, class MDL_wait_for_subgraph *);

	void done_waiting_for(class MDL_context *);

	void lock_deadlock_victim(class MDL_context *);

	void unlock_deadlock_victim(class MDL_context *);

	void MDL_context(class MDL_context *, const class MDL_context  &);

	class MDL_context & operator=(class MDL_context *, class MDL_context &);

	void ~MDL_context(class MDL_context *, int);


	/* size: 352, cachelines: 6, members: 9 */
	/* sum members: 342, holes: 1, sum holes: 6 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 32 bytes */
};
struct PSI_metadata_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_metadata_lock *  m_metadata_lock;      /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	long long unsigned int     m_timer_start;        /*    24     8 */
	long long unsigned int     (*m_timer)(void);     /*    32     8 */
	void *                     m_wait;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct MDL_key {
	enum enum_mdl_namespace {
		GLOBAL            = 0,
		BACKUP_LOCK       = 1,
		TABLESPACE        = 2,
		SCHEMA            = 3,
		TABLE             = 4,
		FUNCTION          = 5,
		PROCEDURE         = 6,
		TRIGGER           = 7,
		EVENT             = 8,
		COMMIT            = 9,
		USER_LEVEL_LOCK   = 10,
		LOCKING_SERVICE   = 11,
		SRID              = 12,
		ACL_CACHE         = 13,
		COLUMN_STATISTICS = 14,
		RESOURCE_GROUPS   = 15,
		FOREIGN_KEY       = 16,
		CHECK_CONSTRAINT  = 17,
		BACKUP_TABLES     = 18,
		NAMESPACE_END     = 19,
	};

	/* tag__fprintf: const_type tag not supported! */;

	void init_psi_keys(void);

	const uchar  * ptr(const class MDL_key  *);

	uint length(const class MDL_key  *);

	const char  * db_name(const class MDL_key  *);

	uint db_name_length(const class MDL_key  *);

	const char  * name(const class MDL_key  *);

	uint name_length(const class MDL_key  *);

	const char  * col_name(const class MDL_key  *);

	uint col_name_length(const class MDL_key  *);

	enum enum_mdl_namespace mdl_namespace(const class MDL_key  *);

	void mdl_key_init(class MDL_key *, enum enum_mdl_namespace, const char  *, const char  *);

	void mdl_key_init(class MDL_key *, enum enum_mdl_namespace, const char  *, const char  *, const char  *);

	void mdl_key_init(class MDL_key *, enum enum_mdl_namespace, const char  *, const char  *, size_t, const char  *);

	void mdl_key_init(class MDL_key *, enum enum_mdl_namespace, const char  *, size_t, size_t);

	void mdl_key_init(class MDL_key *, const class MDL_key  *);

	void reset(class MDL_key *);

	bool is_equal(const class MDL_key  *, const class MDL_key  *);

	int cmp(const class MDL_key  *, const class MDL_key  *);

	void MDL_key(class MDL_key *, const class MDL_key  &);

	class MDL_key & operator=(class MDL_key *, const class MDL_key  &);

	void MDL_key(class MDL_key *, enum enum_mdl_namespace, const char  *, const char  *);

	void MDL_key(class MDL_key *);

	const PSI_stage_info  * get_wait_state_name(const class MDL_key  *);

private:

	bool use_normalized_object_name(const class MDL_key  *);

	uint16                     m_length;             /*     0     2 */
	uint16                     m_db_name_length;     /*     2     2 */
	uint16                     m_object_name_length; /*     4     2 */
	char                       m_ptr[387];           /*     6   387 */

	/* Bitfield combined with previous fields */

	static PSI_stage_info             m_namespace_to_wait_state_name[19]; /*     0     0 */

	/* size: 394, cachelines: 7, members: 4, static members: 1 */
	/* padding: 1 */
	/* last cacheline: 10 bytes */
};
class I_P_List_null_counter {
protected:

	void reset(class I_P_List_null_counter *);

	void inc(class I_P_List_null_counter *);

	void dec(class I_P_List_null_counter *);

	void swap(class I_P_List_null_counter *, class I_P_List_null_counter &);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List_counter {
	uint                       m_counter;            /*     0     4 */
protected:

	void I_P_List_counter(class I_P_List_counter *);

	void reset(class I_P_List_counter *);

	void inc(class I_P_List_counter *);

	void dec(class I_P_List_counter *);

	void swap(class I_P_List_counter *, class I_P_List_counter &);

public:

	uint elements(const class I_P_List_counter  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class MDL_request {
public:

	enum enum_mdl_type         type;                 /*     0     4 */
	enum enum_mdl_duration     duration;             /*     4     4 */
	class MDL_request *        next_in_list;         /*     8     8 */
	class MDL_request * *      prev_in_list;         /*    16     8 */
	class MDL_ticket *         ticket;               /*    24     8 */
	struct MDL_key             key;                  /*    32   394 */

	/* XXX last struct has 1 byte of padding */
	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 6 boundary (384 bytes) was 48 bytes ago --- */
	const char  *              m_src_file;           /*   432     8 */
	uint                       m_src_line;           /*   440     4 */
	void * operator new(size_t, class MEM_ROOT *, const class nothrow_t  &);

	void operator delete(void *, class MEM_ROOT *, const class nothrow_t  &);

	void init_with_source(class MDL_request *, enum enum_mdl_namespace, const char  *, const char  *, enum enum_mdl_type, enum enum_mdl_duration, const char  *, uint);

	void init_by_key_with_source(class MDL_request *, const class MDL_key  *, enum enum_mdl_type, enum enum_mdl_duration, const char  *, uint);

	void init_by_part_key_with_source(class MDL_request *, enum enum_mdl_namespace, const char  *, size_t, size_t, enum enum_mdl_type, enum enum_mdl_duration, const char  *, uint);

	void set_type(class MDL_request *, enum enum_mdl_type);

	bool is_write_lock_request(const class MDL_request  *);

	bool is_ddl_or_lock_tables_lock_request(const class MDL_request  *);

	void MDL_request(class MDL_request *);

	void MDL_request(class MDL_request *, const class MDL_request  &);

	void MDL_request(class MDL_request *, );

	class MDL_request & operator=(class MDL_request *, );


	/* size: 448, cachelines: 7, members: 8 */
	/* sum members: 438, holes: 1, sum holes: 6 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 1 */
};
class MDL_ticket_store {
	struct MDL_ticket_handle {
		enum enum_mdl_duration     m_dur;                /*     0     4 */

		/* XXX 4 bytes hole, try to pack */

		class MDL_ticket *         m_ticket;             /*     8     8 */
		void MDL_ticket_handle(class MDL_ticket_handle *);

		void MDL_ticket_handle(class MDL_ticket_handle *, class MDL_ticket *, enum enum_mdl_duration);


		/* size: 16, cachelines: 1, members: 2 */
		/* sum members: 12, holes: 1, sum holes: 4 */
		/* last cacheline: 16 bytes */
	};

	struct Duration {
		Ticket_p_list              m_ticket_list;        /*     0     8 */
		class MDL_ticket *         m_mat_front;          /*     8     8 */

		/* size: 16, cachelines: 1, members: 2 */
		/* last cacheline: 16 bytes */
	};

	typedef struct I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_null_counter, I_P_List_no_push_back<MDL_ticket> > Ticket_p_list;

	struct Hash {
		size_t operator()(const class Hash  *, const class MDL_key  *);


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	struct Key_equal {
		bool operator()(const class Key_equal  *, const class MDL_key  *, const class MDL_key  *);


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	struct Duration            m_durations[3];       /*     0    48 */
	const size_t               THRESHOLD;            /*    48     8 */
	const size_t               INITIAL_BUCKET_COUNT; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	size_t                     m_count;              /*    64     8 */
	class unique_ptr<std::unordered_multimap<const MDL_key*, MDL_ticket_store::MDL_ticket_handle, MDL_ticket_store::Hash, MDL_ticket_store::Key_equal, std::allocator<std::pair<const MDL_key* const, MDL_ticket_store::MDL_ticket_handle> > >, std::default_delete<std::unordered_multimap<const MDL_key*, MDL_ticket_store::MDL_ticket_handle, MDL_ticket_store::Hash, MDL_ticket_store::Key_equal, std::allocator<std::pair<const MDL_key* const, MDL_ticket_store::MDL_ticket_handle> > > > > m_map; /*    72     8 */
	class MDL_ticket_handle find_in_lists(const class MDL_ticket_store  *, const class MDL_request  &);

	class MDL_ticket_handle find_in_hash(const class MDL_ticket_store  *, const class MDL_request  &);

public:

	void MDL_ticket_store(class MDL_ticket_store *);

	bool is_empty(const class MDL_ticket_store  *);

	bool is_empty(const class MDL_ticket_store  *, int);

	class MDL_ticket * front(class MDL_ticket_store *, int);

	void push_front(class MDL_ticket_store *, enum enum_mdl_duration, class MDL_ticket *);

	void remove(class MDL_ticket_store *, enum enum_mdl_duration, class MDL_ticket *);

	typedef Iterator List_iterator;

	List_iterator list_iterator(const class MDL_ticket_store  *, int);

	void move_all_to_explicit_duration(class MDL_ticket_store *);

	void move_explicit_to_transaction_duration(class MDL_ticket_store *);

	class MDL_ticket_handle find(const class MDL_ticket_store  *, const class MDL_request  &);

	void set_materialized(class MDL_ticket_store *);

	class MDL_ticket * materialized_front(class MDL_ticket_store *, int);

	void ~MDL_ticket_store(class MDL_ticket_store *, int);


	/* size: 80, cachelines: 2, members: 5 */
	/* last cacheline: 16 bytes */
};
class I_P_List_no_push_back<MDL_ticket> {
protected:

	void I_P_List_no_push_back(class I_P_List_no_push_back<MDL_ticket> *, class MDL_ticket * *);

	void set_last(class I_P_List_no_push_back<MDL_ticket> *, class MDL_ticket * *);

	void swap(class I_P_List_no_push_back<MDL_ticket> *, class I_P_List_no_push_back<MDL_ticket> &);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_null_counter, I_P_List_no_push_back<MDL_ticket> > : public I_P_List_null_counter, public I_P_List_no_push_back<MDL_ticket> {
public:

	/* class I_P_List_null_counter <ancestor>; */    /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	/* class I_P_List_no_push_back<MDL_ticket> <ancestor>; */ /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class MDL_ticket *         m_first;              /*     0     8 */
	void I_P_List(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	void clear(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	bool is_empty(const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_);

	void push_front(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *);

	void push_back(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *);

	void insert_after(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *, class MDL_ticket *);

	void remove(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *);

	class MDL_ticket * front(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	const class MDL_ticket  * front(const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_);

	class MDL_ticket * pop_front(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	void swap(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	typedef struct I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_null_counter, I_P_List_no_push_back<MDL_ticket> > > Iterator;


	/* size: 8, cachelines: 1, members: 3 */
	/* paddings: 2, sum paddings: 2 */
	/* last cacheline: 8 bytes */
};
struct I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context> {
	class MDL_ticket * * next_ptr(class MDL_ticket *);

	const class MDL_ticket  * const * next_ptr(const class MDL_ticket  *);

	class MDL_ticket * * * prev_ptr(class MDL_ticket *);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_null_counter, I_P_List_no_push_back<MDL_ticket> > > {
	const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_ list; /*     0     8 */
	class MDL_ticket *         current;              /*     8     8 */
public:

	void I_P_List_iterator(class I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket, const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_);

	void I_P_List_iterator(class I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket, const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_, class MDL_ticket *);

	void init(class I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket, const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_);

	class MDL_ticket * operator++(class I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket, int);

	class MDL_ticket * operator++(class I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket);

	void rewind(class I_P_List_iterator<MDL_ticket, I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class MDL_savepoint {
public:

	void MDL_savepoint(class MDL_savepoint *);

	void MDL_savepoint(class MDL_savepoint *, class MDL_ticket *, class MDL_ticket *);

	class MDL_ticket *         m_stmt_ticket;        /*     0     8 */
	class MDL_ticket *         m_trans_ticket;       /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class MDL_wait {
	enum enum_wait_status {
		WS_EMPTY = 0,
		GRANTED  = 1,
		VICTIM   = 2,
		TIMEOUT  = 3,
		KILLED   = 4,
	};

public:

	void MDL_wait(class MDL_wait *);

	void ~MDL_wait(class MDL_wait *, int);

	bool set_status(class MDL_wait *, enum enum_wait_status);

	enum enum_wait_status get_status(class MDL_wait *);

	void reset_status(class MDL_wait *);

	enum enum_wait_status timed_wait(class MDL_wait *, class MDL_context_owner *, class timespec *, bool, const PSI_stage_info  *);

	struct mysql_mutex_t       m_LOCK_wait_status;   /*     0    48 */
	struct mysql_cond_t        m_COND_wait_status;   /*    48    56 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	enum enum_wait_status      m_wait_status;        /*   104     4 */

	/* size: 112, cachelines: 2, members: 3 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
class MDL_context_owner {
public:

	void MDL_context_owner(class MDL_context_owner *, const class MDL_context_owner  &);

	void MDL_context_owner(class MDL_context_owner *);

	class MDL_context_owner & operator=(class MDL_context_owner *, const class MDL_context_owner  &);

	int ()(void) * *           _vptr.MDL_context_owner; /*     0     8 */
	virtual void ~MDL_context_owner(class MDL_context_owner *, int);

	virtual void enter_cond(class MDL_context_owner *, class mysql_cond_t *, class mysql_mutex_t *, const PSI_stage_info  *, PSI_stage_info *, const char  *, const char  *, int);

	virtual void exit_cond(class MDL_context_owner *, const PSI_stage_info  *, const char  *, const char  *, int);

	virtual int is_killed(const class MDL_context_owner  *);

	virtual bool is_connected(class MDL_context_owner *);

	virtual bool might_have_commit_order_waiters(const class MDL_context_owner  *);

	virtual class THD * get_thd(class MDL_context_owner *);

	virtual void notify_shared_lock(class MDL_context_owner *, class MDL_context_owner *, bool);

	virtual bool notify_hton_pre_acquire_exclusive(class MDL_context_owner *, const class MDL_key  *, bool *);

	virtual void notify_hton_post_release_exclusive(class MDL_context_owner *, const class MDL_key  *);

	virtual uint get_rand_seed(const class MDL_context_owner  *);

	/* vtable has 10 entries: {
	   [2] = enter_cond((null)), 
	   [3] = exit_cond((null)), 
	   [4] = is_killed((null)), 
	   [5] = is_connected((null)), 
	   [6] = might_have_commit_order_waiters((null)), 
	   [7] = get_thd((null)), 
	   [8] = notify_shared_lock((null)), 
	   [9] = notify_hton_pre_acquire_exclusive((null)), 
	   [10] = notify_hton_post_release_exclusive((null)), 
	   [11] = get_rand_seed((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class MDL_context_visitor {
public:

	void MDL_context_visitor(class MDL_context_visitor *, const class MDL_context_visitor  &);

	void MDL_context_visitor(class MDL_context_visitor *);

	int ()(void) * *           _vptr.MDL_context_visitor; /*     0     8 */
	virtual void ~MDL_context_visitor(class MDL_context_visitor *, int);

	virtual void visit_context(class MDL_context_visitor *, const class MDL_context  *);

	/* vtable has 1 entries: {
	   [2] = visit_context((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct LF_PINS {
	struct atomic<void*>       pin[4];               /*     0    32 */
	class LF_PINBOX *          pinbox;               /*    32     8 */
	void *                     purgatory;            /*    40     8 */
	uint64                     purgatory_count;      /*    48     8 */
	struct atomic<long unsigned int> link __attribute__((__aligned__(8))); /*    56     8 */

	/* size: 64, cachelines: 1, members: 5 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class Cost_model_table {
public:

	void Cost_model_table(class Cost_model_table *);

	void init(class Cost_model_table *, const class Cost_model_server  *, const class TABLE  *);

	double row_evaluate_cost(const class Cost_model_table  *, double);

	double key_compare_cost(const class Cost_model_table  *, double);

	double io_block_read_cost(const class Cost_model_table  *, double);

	double buffer_block_read_cost(const class Cost_model_table  *, double);

	double page_read_cost(const class Cost_model_table  *, double);

	double page_read_cost_index(const class Cost_model_table  *, uint, double);

	double disk_seek_base_cost(const class Cost_model_table  *);

	double disk_seek_prop_cost(const class Cost_model_table  *);

	double disk_seek_cost(const class Cost_model_table  *, double);

protected:

	const class Cost_model_server  * m_cost_model_server; /*     0     8 */
	const class SE_cost_constants  * m_se_cost_constants; /*     8     8 */
	const class TABLE  *       m_table;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Prealloced_array<Opt_trace_stmt*, 16> {
	struct External {
		class Opt_trace_stmt * *   m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Opt_trace_stmt *     m_buff[16];           /*     0   128 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	class Opt_trace_stmt * * buffer(class Prealloced_array<Opt_trace_stmt*, 16> *);

	class Opt_trace_stmt * const * buffer(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	void set_size(class Prealloced_array<Opt_trace_stmt*, 16> *, size_t);

	void adjust_size(class Prealloced_array<Opt_trace_stmt*, 16> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16> *, const class Prealloced_array<Opt_trace_stmt*, 16>  &);

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16> *, );

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Opt_trace_stmt * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16> *, class initializer_list<Opt_trace_stmt*>);

	class Prealloced_array<Opt_trace_stmt*, 16> & operator=(class Prealloced_array<Opt_trace_stmt*, 16> *, const class Prealloced_array<Opt_trace_stmt*, 16>  &);

	class Prealloced_array<Opt_trace_stmt*, 16> & operator=(class Prealloced_array<Opt_trace_stmt*, 16> *, );

	void ~Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16> *, int);

	size_t capacity(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	size_t element_size(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	bool empty(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	size_t size(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	class Opt_trace_stmt * & at(class Prealloced_array<Opt_trace_stmt*, 16> *, size_t);

	class Opt_trace_stmt * const & at(const class Prealloced_array<Opt_trace_stmt*, 16>  *, size_t);

	class Opt_trace_stmt * & operator[](class Prealloced_array<Opt_trace_stmt*, 16> *, size_t);

	class Opt_trace_stmt * const & operator[](const class Prealloced_array<Opt_trace_stmt*, 16>  *, size_t);

	class Opt_trace_stmt * & back(class Prealloced_array<Opt_trace_stmt*, 16> *);

	class Opt_trace_stmt * const & back(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	class Opt_trace_stmt * & front(class Prealloced_array<Opt_trace_stmt*, 16> *);

	class Opt_trace_stmt * const & front(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	typedef class Opt_trace_stmt * * iterator;

	iterator begin(class Prealloced_array<Opt_trace_stmt*, 16> *);

	iterator end(class Prealloced_array<Opt_trace_stmt*, 16> *);

	const_iterator begin(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	const_iterator end(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	const_iterator cbegin(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	const_iterator cend(const class Prealloced_array<Opt_trace_stmt*, 16>  *);

	bool assign_at(class Prealloced_array<Opt_trace_stmt*, 16> *, size_t, const value_type  &);

	typedef class Opt_trace_stmt * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Opt_trace_stmt*, 16> *, size_t);

	bool push_back(class Prealloced_array<Opt_trace_stmt*, 16> *, class Opt_trace_stmt * const &);

	bool push_back(class Prealloced_array<Opt_trace_stmt*, 16> *, );

	void pop_back(class Prealloced_array<Opt_trace_stmt*, 16> *);

	iterator insert(class Prealloced_array<Opt_trace_stmt*, 16> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Opt_trace_stmt*, 16> *, const_iterator, );

	class pair<Opt_trace_stmt**, bool> insert_unique(class Prealloced_array<Opt_trace_stmt*, 16> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Opt_trace_stmt*, 16> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Opt_trace_stmt*, 16>  *, const value_type  &);

	iterator erase(class Prealloced_array<Opt_trace_stmt*, 16> *, const_iterator);

	iterator erase(class Prealloced_array<Opt_trace_stmt*, 16> *, size_t);

	void erase_at_end(class Prealloced_array<Opt_trace_stmt*, 16> *, const_iterator);

	iterator erase(class Prealloced_array<Opt_trace_stmt*, 16> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Opt_trace_stmt*, 16> *, class Prealloced_array<Opt_trace_stmt*, 16> &);

	void shrink_to_fit(class Prealloced_array<Opt_trace_stmt*, 16> *);

	void resize(class Prealloced_array<Opt_trace_stmt*, 16> *, size_t, class Opt_trace_stmt * const &);

	void clear(class Prealloced_array<Opt_trace_stmt*, 16> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Opt_trace_stmt * m_buff[16];       /*     8   128 */
	};                                               /*     8   128 */

	/* size: 136, cachelines: 3, members: 3, static members: 2 */
	/* last cacheline: 8 bytes */
};
class Opt_trace_context {
	enum feature_value {
		GREEDY_SEARCH      = 1,
		RANGE_OPTIMIZER    = 2,
		DYNAMIC_RANGE      = 4,
		REPEATED_SUBSELECT = 8,
		MISC               = 128,
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Opt_trace_context_impl {
	public:

		void Opt_trace_context_impl(class Opt_trace_context_impl *);

		void disable_I_S_for_this_and_children(class Opt_trace_context_impl *);

		void restore_I_S(class Opt_trace_context_impl *);

		class Opt_trace_stmt *     current_stmt_in_gen;  /*     0     8 */
		Opt_trace_stmt_array       stack_of_current_stmts; /*     8   136 */
		/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
		Opt_trace_stmt_array       all_stmts_for_I_S;    /*   144   136 */
		/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
		Opt_trace_stmt_array       all_stmts_to_del;     /*   280   136 */
		/* --- cacheline 6 boundary (384 bytes) was 32 bytes ago --- */
		bool                       end_marker;           /*   416     1 */
		bool                       one_line;             /*   417     1 */

		/* XXX 2 bytes hole, try to pack */

		enum feature_value         features;             /*   420     4 */
		long int                   offset;               /*   424     8 */
		long int                   limit;                /*   432     8 */
		size_t                     max_mem_size;         /*   440     8 */
		/* --- cacheline 7 boundary (448 bytes) --- */
		long int                   since_offset_0;       /*   448     8 */

		/* size: 456, cachelines: 8, members: 11 */
		/* sum members: 454, holes: 1, sum holes: 2 */
		/* last cacheline: 8 bytes */
	};

public:

	void Opt_trace_context(class Opt_trace_context *);

	void ~Opt_trace_context(class Opt_trace_context *, int);

	bool start(class Opt_trace_context *, bool, bool, bool, bool, long int, long int, ulong, ulonglong);

	void end(class Opt_trace_context *);

	bool is_started(const class Opt_trace_context  *);

	bool support_I_S(const class Opt_trace_context  *);

	void set_query(class Opt_trace_context *, const char  *, size_t, const class CHARSET_INFO  *);

	void reset(class Opt_trace_context *);

	bool get_end_marker(const class Opt_trace_context  *);

	bool get_one_line(const class Opt_trace_context  *);

	static const char  *              flag_names[0]; /*     0     0 */
	static const char  *              feature_names[0]; /*     0     0 */
	void missing_privilege(class Opt_trace_context *);

	static const enum feature_value   default_features; /*     0     0 */
	bool feature_enabled(const class Opt_trace_context  *, enum feature_value);

	class Opt_trace_stmt * get_current_stmt_in_gen(class Opt_trace_context *);

	const class Opt_trace_stmt  * get_next_stmt_for_I_S(const class Opt_trace_context  *, long int *);

	void disable_I_S_for_this_and_children(class Opt_trace_context *);

	void restore_I_S(class Opt_trace_context *);

	class Opt_trace_context_impl * pimpl;            /*     0     8 */
	int                        I_S_disabled;         /*     8     4 */
	void purge_stmts(class Opt_trace_context *, bool);

	size_t allowed_mem_size_for_current_stmt(const class Opt_trace_context  *);

	void Opt_trace_context(class Opt_trace_context *, const class Opt_trace_context  &);

	class Opt_trace_context & operator=(class Opt_trace_context *, const class Opt_trace_context  &);


	/* size: 16, cachelines: 1, members: 2, static members: 3 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct PSI_cond_info_v1 {
	PSI_cond_key *             m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */
	int                        m_volatility;         /*    20     4 */
	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct PSI_cond_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */
	enum PSI_cond_operation    m_operation;          /*     4     4 */
	class PSI_cond *           m_cond;               /*     8     8 */
	class PSI_mutex *          m_mutex;              /*    16     8 */
	class PSI_thread *         m_thread;             /*    24     8 */
	long long unsigned int     m_timer_start;        /*    32     8 */
	long long unsigned int     (*m_timer)(void);     /*    40     8 */
	void *                     m_wait;               /*    48     8 */

	/* size: 56, cachelines: 1, members: 8 */
	/* last cacheline: 56 bytes */
};
struct PSI_cond_service_v1 {
	register_cond_v1_t         register_cond;        /*     0     8 */
	init_cond_v1_t             init_cond;            /*     8     8 */
	destroy_cond_v1_t          destroy_cond;         /*    16     8 */
	signal_cond_v1_t           signal_cond;          /*    24     8 */
	broadcast_cond_v1_t        broadcast_cond;       /*    32     8 */
	start_cond_wait_v1_t       start_cond_wait;      /*    40     8 */
	end_cond_wait_v1_t         end_cond_wait;        /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
class Checkable_rwlock {
public:

	void Checkable_rwlock(class Checkable_rwlock *, PSI_rwlock_key);

	void ~Checkable_rwlock(class Checkable_rwlock *, int);

	void rdlock(class Checkable_rwlock *);

	void wrlock(class Checkable_rwlock *);

	void unlock(class Checkable_rwlock *);

	bool is_wrlock(class Checkable_rwlock *);

	int trywrlock(class Checkable_rwlock *);

	int tryrdlock(class Checkable_rwlock *);

	void assert_some_lock(const class Checkable_rwlock  *);

	void assert_some_rdlock(const class Checkable_rwlock  *);

	void assert_some_wrlock(const class Checkable_rwlock  *);

	void assert_no_wrlock(const class Checkable_rwlock  *);

	void assert_no_rdlock(const class Checkable_rwlock  *);

	void assert_no_lock(const class Checkable_rwlock  *);

	bool                       m_is_write_lock;      /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	struct mysql_rwlock_t      m_rwlock;             /*     8    64 */

	/* size: 72, cachelines: 2, members: 2 */
	/* sum members: 65, holes: 1, sum holes: 7 */
	/* last cacheline: 8 bytes */
};
class Gtid_mode {
	enum value_type {
		OFF            = 0,
		DEFAULT        = 0,
		OFF_PERMISSIVE = 1,
		ON_PERMISSIVE  = 2,
		ON             = 3,
	};

	struct atomic<int>         m_atomic_mode __attribute__((__aligned__(4))); /*     0     4 */
public:

	void Gtid_mode(class Gtid_mode *);

	static ulong                      sysvar_mode;   /*     0     0 */
	static const char  *              names[0];      /*     0     0 */
	static class Checkable_rwlock    lock;           /*     0     0 */
	void set(class Gtid_mode *, enum value_type);

	enum value_type get(const class Gtid_mode  *);

	class pair<bool, Gtid_mode::value_type> from_string(string);

	const char  * to_string(enum value_type);


	/* size: 4, cachelines: 1, members: 1, static members: 3 */
	/* forced alignments: 1 */
	/* last cacheline: 4 bytes */
} __attribute__((__aligned__(4)));
class Sid_map {
	struct Node {
		rpl_sidno                  sidno;                /*     0     4 */
		rpl_sid                    sid;                  /*     4    16 */

		/* size: 20, cachelines: 1, members: 2 */
		/* last cacheline: 20 bytes */
	};

public:

	void Sid_map(class Sid_map *, class Checkable_rwlock *);

	void ~Sid_map(class Sid_map *, int);

	enum enum_return_status clear(class Sid_map *);

	rpl_sidno add_sid(class Sid_map *, const rpl_sid  &);

	rpl_sidno sid_to_sidno(const class Sid_map  *, const rpl_sid  &);

	const rpl_sid  & sidno_to_sid(const class Sid_map  *, rpl_sidno, bool);

	rpl_sidno get_sorted_sidno(const class Sid_map  *, rpl_sidno);

	rpl_sidno get_max_sidno(const class Sid_map  *);

	class Checkable_rwlock * get_sid_lock(const class Sid_map  *);

	enum enum_return_status copy(class Sid_map *, class Sid_map *);

	const uchar  * sid_map_get_key(const uchar  *, size_t *);

	enum enum_return_status add_node(class Sid_map *, rpl_sidno, const rpl_sid  &);

	class Checkable_rwlock *   sid_lock;             /*     0     8 */
	class Prealloced_array<Sid_map::Node*, 8> _sidno_to_sid; /*     8    72 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class malloc_unordered_map<binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter>, binary_log::Hash_Uuid, std::equal_to<binary_log::Uuid> > _sid_to_sidno; /*    80    64 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class Prealloced_array<int, 8> _sorted;          /*   144    40 */

	/* size: 184, cachelines: 3, members: 4 */
	/* last cacheline: 56 bytes */
};
class Prealloced_array<Sid_map::Node*, 8> {
	struct External {
		class Node * *             m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Node *               m_buff[8];            /*     0    64 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Sid_map::Node*, 8>  *);

	class Node * * buffer(class Prealloced_array<Sid_map::Node*, 8> *);

	class Node * const * buffer(const class Prealloced_array<Sid_map::Node*, 8>  *);

	void set_size(class Prealloced_array<Sid_map::Node*, 8> *, size_t);

	void adjust_size(class Prealloced_array<Sid_map::Node*, 8> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8> *, const class Prealloced_array<Sid_map::Node*, 8>  &);

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8> *, );

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Node * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8> *, class initializer_list<Sid_map::Node*>);

	class Prealloced_array<Sid_map::Node*, 8> & operator=(class Prealloced_array<Sid_map::Node*, 8> *, const class Prealloced_array<Sid_map::Node*, 8>  &);

	class Prealloced_array<Sid_map::Node*, 8> & operator=(class Prealloced_array<Sid_map::Node*, 8> *, );

	void ~Prealloced_array(class Prealloced_array<Sid_map::Node*, 8> *, int);

	size_t capacity(const class Prealloced_array<Sid_map::Node*, 8>  *);

	size_t element_size(const class Prealloced_array<Sid_map::Node*, 8>  *);

	bool empty(const class Prealloced_array<Sid_map::Node*, 8>  *);

	size_t size(const class Prealloced_array<Sid_map::Node*, 8>  *);

	class Node * & at(class Prealloced_array<Sid_map::Node*, 8> *, size_t);

	class Node * const & at(const class Prealloced_array<Sid_map::Node*, 8>  *, size_t);

	class Node * & operator[](class Prealloced_array<Sid_map::Node*, 8> *, size_t);

	class Node * const & operator[](const class Prealloced_array<Sid_map::Node*, 8>  *, size_t);

	class Node * & back(class Prealloced_array<Sid_map::Node*, 8> *);

	class Node * const & back(const class Prealloced_array<Sid_map::Node*, 8>  *);

	class Node * & front(class Prealloced_array<Sid_map::Node*, 8> *);

	class Node * const & front(const class Prealloced_array<Sid_map::Node*, 8>  *);

	typedef class Node * * iterator;

	iterator begin(class Prealloced_array<Sid_map::Node*, 8> *);

	iterator end(class Prealloced_array<Sid_map::Node*, 8> *);

	const_iterator begin(const class Prealloced_array<Sid_map::Node*, 8>  *);

	const_iterator end(const class Prealloced_array<Sid_map::Node*, 8>  *);

	const_iterator cbegin(const class Prealloced_array<Sid_map::Node*, 8>  *);

	const_iterator cend(const class Prealloced_array<Sid_map::Node*, 8>  *);

	bool assign_at(class Prealloced_array<Sid_map::Node*, 8> *, size_t, const value_type  &);

	typedef class Node * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Sid_map::Node*, 8> *, size_t);

	bool push_back(class Prealloced_array<Sid_map::Node*, 8> *, class Node * const &);

	bool push_back(class Prealloced_array<Sid_map::Node*, 8> *, );

	void pop_back(class Prealloced_array<Sid_map::Node*, 8> *);

	iterator insert(class Prealloced_array<Sid_map::Node*, 8> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Sid_map::Node*, 8> *, const_iterator, );

	class pair<Sid_map::Node**, bool> insert_unique(class Prealloced_array<Sid_map::Node*, 8> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Sid_map::Node*, 8> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Sid_map::Node*, 8>  *, const value_type  &);

	iterator erase(class Prealloced_array<Sid_map::Node*, 8> *, const_iterator);

	iterator erase(class Prealloced_array<Sid_map::Node*, 8> *, size_t);

	void erase_at_end(class Prealloced_array<Sid_map::Node*, 8> *, const_iterator);

	iterator erase(class Prealloced_array<Sid_map::Node*, 8> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Sid_map::Node*, 8> *, class Prealloced_array<Sid_map::Node*, 8> &);

	void shrink_to_fit(class Prealloced_array<Sid_map::Node*, 8> *);

	void resize(class Prealloced_array<Sid_map::Node*, 8> *, size_t, class Node * const &);

	void clear(class Prealloced_array<Sid_map::Node*, 8> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Node *       m_buff[8];            /*     8    64 */
	};                                               /*     8    64 */

	/* size: 72, cachelines: 2, members: 3, static members: 2 */
	/* last cacheline: 8 bytes */
};
class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > >  *, reference);

	typedef class pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > & reference;

	typedef const class pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > >  *, const_reference);

	typedef const class pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >, true> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >, true> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free, reference);

	typedef class _Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >, true> & reference;

	typedef const class _Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >, true>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free, const_reference);

	typedef const class _Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >, true>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_delet, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_delet, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_delet, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_delet, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free);

	typedef struct _Hash_node<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> >, true> value_type;


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node_base*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node_base * * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node_base*>  *, reference);

	typedef class _Hash_node_base * & reference;

	typedef class _Hash_node_base * const * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node_base*>  *, const_reference);

	typedef class _Hash_node_base * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node_base*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node_base*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node_base*> *, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node_base*> *, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node_base*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node_base*>  *);

	void Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char>, Sroutine_hash_entry*>, true> >(class Malloc_allocator<std::__detail::_Hash_node_base*> *, const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	void Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char>, Prepared_statement*>, true> >(class Malloc_allocator<std::__detail::_Hash_node_base*> *, const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	void Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement> >, false> >(class Malloc_allocator<std::__detail::_Hash_node_base*> *, const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, s);

	void Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> >(class Malloc_allocator<std::__detail::_Hash_node_base*> *, const class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false>);

	void Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char>, User_level_lock*>, true> >(class Malloc_allocator<std::__detail::_Hash_node_base*> *, const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	void Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char>, std::unique_ptr<TABLE_LIST, My_free_deleter> >, true> >(class Malloc_allocator<std::__detail::_Hash_node_base*> *, const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	void Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char>, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> >, true> >(class Malloc_allocator<std::__detail::_Hash_node_base*> *, const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class malloc_unordered_map<binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter>, binary_log::Hash_Uuid, std::equal_to<binary_log::Uuid> > : public unordered_map<binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter>, binary_log::Hash_Uuid, std::equal_to<binary_log::Uuid>, Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > > > {
public:

	/* class unordered_map<binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter>, binary_log::Hash_Uuid, std::equal_to<binary_log::Uuid>, Malloc_allocator<std::pair<const binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter> > > > <ancestor>; */ /*     0    64 */
	void malloc_unordered_map(class malloc_unordered_map<binary_log::Uuid, std::unique_ptr<Sid_map::Node, My_free_deleter>, binary_log::Hash_Uuid, std::equal, PSI_memory_key);


	/* size: 64, cachelines: 1, members: 1 */

	/* BRAIN FART ALERT! 64 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 512 bits */
};
class Prealloced_array<int, 8> {
	struct External {
		int *                      m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		int                        m_buff[8];            /*     0    32 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<int, 8>  *);

	int * buffer(class Prealloced_array<int, 8> *);

	const int  * buffer(const class Prealloced_array<int, 8>  *);

	void set_size(class Prealloced_array<int, 8> *, size_t);

	void adjust_size(class Prealloced_array<int, 8> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<int, 8> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<int, 8> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<int, 8> *, const class Prealloced_array<int, 8>  &);

	void Prealloced_array(class Prealloced_array<int, 8> *, );

	void Prealloced_array(class Prealloced_array<int, 8> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const int  * const_iterator;

	void Prealloced_array(class Prealloced_array<int, 8> *, class initializer_list<int>);

	class Prealloced_array<int, 8> & operator=(class Prealloced_array<int, 8> *, const class Prealloced_array<int, 8>  &);

	class Prealloced_array<int, 8> & operator=(class Prealloced_array<int, 8> *, );

	void ~Prealloced_array(class Prealloced_array<int, 8> *, int);

	size_t capacity(const class Prealloced_array<int, 8>  *);

	size_t element_size(const class Prealloced_array<int, 8>  *);

	bool empty(const class Prealloced_array<int, 8>  *);

	size_t size(const class Prealloced_array<int, 8>  *);

	int & at(class Prealloced_array<int, 8> *, size_t);

	const int  & at(const class Prealloced_array<int, 8>  *, size_t);

	int & operator[](class Prealloced_array<int, 8> *, size_t);

	const int  & operator[](const class Prealloced_array<int, 8>  *, size_t);

	int & back(class Prealloced_array<int, 8> *);

	const int  & back(const class Prealloced_array<int, 8>  *);

	int & front(class Prealloced_array<int, 8> *);

	const int  & front(const class Prealloced_array<int, 8>  *);

	typedef int * iterator;

	iterator begin(class Prealloced_array<int, 8> *);

	iterator end(class Prealloced_array<int, 8> *);

	const_iterator begin(const class Prealloced_array<int, 8>  *);

	const_iterator end(const class Prealloced_array<int, 8>  *);

	const_iterator cbegin(const class Prealloced_array<int, 8>  *);

	const_iterator cend(const class Prealloced_array<int, 8>  *);

	bool assign_at(class Prealloced_array<int, 8> *, size_t, const value_type  &);

	typedef int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<int, 8> *, size_t);

	bool push_back(class Prealloced_array<int, 8> *, const int  &);

	bool push_back(class Prealloced_array<int, 8> *, );

	void pop_back(class Prealloced_array<int, 8> *);

	iterator insert(class Prealloced_array<int, 8> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<int, 8> *, const_iterator, );

	class pair<int*, bool> insert_unique(class Prealloced_array<int, 8> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<int, 8> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<int, 8>  *, const value_type  &);

	iterator erase(class Prealloced_array<int, 8> *, const_iterator);

	iterator erase(class Prealloced_array<int, 8> *, size_t);

	void erase_at_end(class Prealloced_array<int, 8> *, const_iterator);

	iterator erase(class Prealloced_array<int, 8> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<int, 8> *, class Prealloced_array<int, 8> &);

	void shrink_to_fit(class Prealloced_array<int, 8> *);

	void resize(class Prealloced_array<int, 8> *, size_t, const int  &);

	void clear(class Prealloced_array<int, 8> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		int                m_buff[8];            /*     8    32 */
	};                                               /*     8    32 */

	/* size: 40, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 40 bytes */
};
class Mutex_cond_array {
	struct Mutex_cond {
		struct mysql_mutex_t       mutex;                /*     0    48 */
		struct mysql_cond_t        cond;                 /*    48    56 */

		/* size: 104, cachelines: 2, members: 2 */
		/* last cacheline: 40 bytes */
	};

public:

	void Mutex_cond_array(class Mutex_cond_array *, class Checkable_rwlock *);

	void ~Mutex_cond_array(class Mutex_cond_array *, int);

	void lock(const class Mutex_cond_array  *, int);

	void unlock(const class Mutex_cond_array  *, int);

	void broadcast(const class Mutex_cond_array  *, int);

	void assert_owner(const class Mutex_cond_array  *, int);

	void assert_not_owner(const class Mutex_cond_array  *, int);

	bool wait(const class Mutex_cond_array  *, const class THD  *, int, class timespec *);

	void enter_cond(const class Mutex_cond_array  *, class THD *, int, PSI_stage_info *, PSI_stage_info *);

	int get_max_index(const class Mutex_cond_array  *);

	enum enum_return_status ensure_index(class Mutex_cond_array *, int);

	bool is_thd_killed(const class Mutex_cond_array  *, const class THD  *);

	class Mutex_cond * get_mutex_cond(const class Mutex_cond_array  *, int);

	class Checkable_rwlock *   global_lock;          /*     0     8 */
	class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> m_array; /*     8    72 */

	/* size: 80, cachelines: 2, members: 2 */
	/* last cacheline: 16 bytes */
};
class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> {
	struct External {
		class Mutex_cond * *       m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Mutex_cond *         m_buff[8];            /*     0    64 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	class Mutex_cond * * buffer(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	class Mutex_cond * const * buffer(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	void set_size(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, size_t);

	void adjust_size(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  &);

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, );

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Mutex_cond * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, class initializer_list<Mutex_cond_array::Mutex_cond*>);

	class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> & operator=(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  &);

	class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> & operator=(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, );

	void ~Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, int);

	size_t capacity(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	size_t element_size(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	bool empty(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	size_t size(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	class Mutex_cond * & at(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, size_t);

	class Mutex_cond * const & at(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *, size_t);

	class Mutex_cond * & operator[](class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, size_t);

	class Mutex_cond * const & operator[](const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *, size_t);

	class Mutex_cond * & back(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	class Mutex_cond * const & back(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	class Mutex_cond * & front(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	class Mutex_cond * const & front(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	typedef class Mutex_cond * * iterator;

	iterator begin(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	iterator end(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	const_iterator begin(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	const_iterator end(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	const_iterator cbegin(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	const_iterator cend(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *);

	bool assign_at(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, size_t, const value_type  &);

	typedef class Mutex_cond * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, size_t);

	bool push_back(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, class Mutex_cond * const &);

	bool push_back(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, );

	void pop_back(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	iterator insert(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const_iterator, );

	class pair<Mutex_cond_array::Mutex_cond**, bool> insert_unique(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8>  *, const value_type  &);

	iterator erase(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const_iterator);

	iterator erase(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, size_t);

	void erase_at_end(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const_iterator);

	iterator erase(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> &);

	void shrink_to_fit(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	void resize(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *, size_t, class Mutex_cond * const &);

	void clear(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Mutex_cond * m_buff[8];            /*     8    64 */
	};                                               /*     8    64 */

	/* size: 72, cachelines: 2, members: 3, static members: 2 */
	/* last cacheline: 8 bytes */
};
struct Gtid {
	rpl_sidno                  sidno;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	rpl_gno                    gno;                  /*     8     8 */
	void clear(class Gtid *);

	void set(class Gtid *, rpl_sidno, rpl_gno);

	bool is_empty(const class Gtid  *);


	/* Bitfield combined with previous fields */

	static const int                  MAX_TEXT_LENGTH = 56; /*     0     0 */
	bool is_valid(const char  *);

	int to_string(const class Gtid  *, const rpl_sid  &, char *);

	int to_string(const class Gtid  *, const class Sid_map  *, char *, bool);

	bool equals(const class Gtid  *, const class Gtid  &);

	enum enum_return_status parse(class Gtid *, class Sid_map *, const char  *);

	void dbug_print(const class Gtid  *, const class Sid_map  *, const char  *, bool);


	/* size: 16, cachelines: 1, members: 2, static members: 1 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
class Gtid_set {
	struct String_format {
		const char  *              begin;                /*     0     8 */
		const char  *              end;                  /*     8     8 */
		const char  *              sid_gno_separator;    /*    16     8 */
		const char  *              gno_start_end_separator; /*    24     8 */
		const char  *              gno_gno_separator;    /*    32     8 */
		const char  *              gno_sid_separator;    /*    40     8 */
		const char  *              empty_set_string;     /*    48     8 */
		const int                  begin_length;         /*    56     4 */
		const int                  end_length;           /*    60     4 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		const int                  sid_gno_separator_length; /*    64     4 */
		const int                  gno_start_end_separator_length; /*    68     4 */
		const int                  gno_gno_separator_length; /*    72     4 */
		const int                  gno_sid_separator_length; /*    76     4 */
		const int                  empty_set_string_length; /*    80     4 */

		/* size: 88, cachelines: 2, members: 14 */
		/* padding: 4 */
		/* last cacheline: 24 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	struct Interval {
		rpl_gno                    start;                /*     0     8 */
		rpl_gno                    end;                  /*     8     8 */
		bool equals(const class Interval  *, const class Interval  &);

		class Interval *           next;                 /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> {
	public:

		void Interval_iterator_base(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *, const class Gtid_set  *, rpl_sidno);

		void Interval_iterator_base(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *, const class Gtid_set  *);

		void init(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *, const class Gtid_set  *, rpl_sidno);

		void next(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *);

		const class Interval  * get(const class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*>  *);

	protected:

		const class Interval  * *  p;                    /*     0     8 */

		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Const_interval_iterator : public Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> {
	public:

		/* class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> <ancestor>; */ /*     0     8 */
		void Const_interval_iterator(class Const_interval_iterator *, const class Gtid_set  *, rpl_sidno);

		void Const_interval_iterator(class Const_interval_iterator *, const class Gtid_set  *);


		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */

		/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
	};

	class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> {
	public:

		void Interval_iterator_base(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *, class Gtid_set *, rpl_sidno);

		void Interval_iterator_base(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *, class Gtid_set *);

		void init(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *, class Gtid_set *, rpl_sidno);

		void next(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *);

		class Interval * get(const class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*>  *);

	protected:

		class Interval * *         p;                    /*     0     8 */

		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Interval_iterator : public Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> {
	public:

		/* class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> <ancestor>; */ /*     0     8 */
		void Interval_iterator(class Interval_iterator *, class Gtid_set *, rpl_sidno);

		void Interval_iterator(class Interval_iterator *, class Gtid_set *);

		void set(class Interval_iterator *, class Interval *);

		void insert(class Interval_iterator *, class Interval *);

		void remove(class Interval_iterator *, class Gtid_set *);


		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */

		/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
	};

	struct Interval_chunk {
		class Interval_chunk *     next;                 /*     0     8 */
		struct Interval            intervals[1];         /*     8    24 */

		/* size: 32, cachelines: 1, members: 2 */
		/* last cacheline: 32 bytes */
	};

	class Free_intervals_lock {
	public:

		void Free_intervals_lock(class Free_intervals_lock *, class Gtid_set *);

		void lock_if_not_locked(class Free_intervals_lock *);

		void unlock_if_locked(class Free_intervals_lock *);

		void ~Free_intervals_lock(class Free_intervals_lock *, int);

		class Gtid_set *           gtid_set;             /*     0     8 */
		bool                       locked;               /*     8     1 */

		/* size: 16, cachelines: 1, members: 2 */
		/* padding: 7 */
		/* last cacheline: 16 bytes */
	};

public:

	static PSI_mutex_key              key_gtid_executed_free_intervals_mutex; /*     0     0 */
	void Gtid_set(class Gtid_set *, class Sid_map *, class Checkable_rwlock *);

	void Gtid_set(class Gtid_set *, class Sid_map *, const char  *, enum enum_return_status *, class Checkable_rwlock *);

	void init(class Gtid_set *);

	void ~Gtid_set(class Gtid_set *, int);

	void clear(class Gtid_set *);

	void clear_set_and_sid_map(class Gtid_set *);

	void _add_gtid(class Gtid_set *, rpl_sidno, rpl_gno);

	void _remove_gtid(class Gtid_set *, rpl_sidno, rpl_gno);

	void _add_gtid(class Gtid_set *, const class Gtid  &);

	void _remove_gtid(class Gtid_set *, const class Gtid  &);

	enum enum_return_status add_gtid_set(class Gtid_set *, const class Gtid_set  *);

	void remove_gtid_set(class Gtid_set *, const class Gtid_set  *);

	void remove_intervals_for_sidno(class Gtid_set *, class Gtid_set *, rpl_sidno);

	enum enum_return_status add_gtid_text(class Gtid_set *, const char  *, bool *, bool *);

	enum enum_return_status add_gtid_encoding(class Gtid_set *, const uchar  *, size_t, size_t *);

	bool contains_gtid(const class Gtid_set  *, rpl_sidno, rpl_gno);

	bool contains_gtid(const class Gtid_set  *, const class Gtid  &);

	rpl_gno get_last_gno(const class Gtid_set  *, rpl_sidno);

	rpl_sidno get_max_sidno(const class Gtid_set  *);

	enum enum_return_status ensure_sidno(class Gtid_set *, rpl_sidno);

	bool is_subset(const class Gtid_set  *, const class Gtid_set  *);

	bool is_subset_not_equals(const class Gtid_set  *, const class Gtid_set  *);

	bool is_subset_for_sid(const class Gtid_set  *, const class Gtid_set  *, rpl_sidno, rpl_sidno);

	bool is_intersection_nonempty(const class Gtid_set  *, const class Gtid_set  *);

	enum enum_return_status intersection(class Gtid_set *, const class Gtid_set  *, class Gtid_set *);

	bool is_empty(const class Gtid_set  *);

	bool is_size_greater_than_or_equal(const class Gtid_set  *, ulonglong);

	ulonglong get_gtid_count(const class Gtid_set  *, rpl_sidno);

	bool contains_sidno(const class Gtid_set  *, rpl_sidno);

	bool is_valid(const char  *);

	size_t get_string_length(const class Gtid_set  *, const class String_format  *);

	size_t to_string(const class Gtid_set  *, char *, bool, const class String_format  *);

	long int to_string(const class Gtid_set  *, char * *, bool, const class String_format  *);

	void dbug_print(const class Gtid_set  *, const char  *, bool, const class String_format  *);

	void get_gtid_intervals(const class Gtid_set  *, class list<Gtid_interval, std::allocator<Gtid_interval> > *);

	static const struct String_format default_string_format; /*     0     0 */
	static const struct String_format sql_string_format; /*     0     0 */
	static const struct String_format commented_string_format; /*     0     0 */
	class Sid_map * get_sid_map(const class Gtid_set  *);

	void add_interval_memory(class Gtid_set *, int, class Interval *);

	void encode(const class Gtid_set  *, uchar *);

	size_t get_encoded_length(const class Gtid_set  *);

	static const int                  CHUNK_GROW_SIZE = 8; /*     0     0 */
	bool sidno_equals(const class Gtid_set  *, rpl_sidno, const class Gtid_set  *, rpl_sidno);

	bool equals(const class Gtid_set  *, const class Gtid_set  *);

	int get_n_intervals(const class Gtid_set  *, rpl_sidno);

	int get_n_intervals(const class Gtid_set  *);

	void create_new_chunk(class Gtid_set *, int);

	void get_free_interval(class Gtid_set *, class Interval * *);

	void put_free_interval(class Gtid_set *, class Interval *);

	void add_interval_memory_lock_taken(class Gtid_set *, int, class Interval *);

	class Checkable_rwlock *   sid_lock;             /*     0     8 */
	struct mysql_mutex_t       free_intervals_mutex; /*     8    48 */
	void assert_free_intervals_locked(class Gtid_set *);

	void add_gno_interval(class Gtid_set *, class Interval_iterator *, rpl_gno, rpl_gno, class Free_intervals_lock *);

	void remove_gno_interval(class Gtid_set *, class Interval_iterator *, rpl_gno, rpl_gno, class Free_intervals_lock *);

	void add_gno_intervals(class Gtid_set *, rpl_sidno, class Const_interval_iterator, class Free_intervals_lock *);

	void remove_gno_intervals(class Gtid_set *, rpl_sidno, class Const_interval_iterator, class Free_intervals_lock *);

	bool is_interval_subset(class Const_interval_iterator *, class Const_interval_iterator *);

	bool is_interval_intersection_nonempty(class Const_interval_iterator *, class Const_interval_iterator *);

	class Sid_map *            sid_map;              /*    56     8 */
	class Prealloced_array<Gtid_set::Interval*, 8> m_intervals; /*    64    72 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	class Interval *           free_intervals;       /*   136     8 */
	class Interval_chunk *     chunks;               /*   144     8 */
	bool                       has_cached_string_length; /*   152     1 */

	/* XXX 7 bytes hole, try to pack */

	size_t                     cached_string_length; /*   160     8 */
	const class String_format  * cached_string_format; /*   168     8 */

	/* size: 176, cachelines: 3, members: 9, static members: 5 */
	/* sum members: 169, holes: 1, sum holes: 7 */
	/* last cacheline: 48 bytes */
};
class Prealloced_array<Gtid_set::Interval*, 8> {
	struct External {
		class Interval * *         m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Interval *           m_buff[8];            /*     0    64 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	class Interval * * buffer(class Prealloced_array<Gtid_set::Interval*, 8> *);

	class Interval * const * buffer(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	void set_size(class Prealloced_array<Gtid_set::Interval*, 8> *, size_t);

	void adjust_size(class Prealloced_array<Gtid_set::Interval*, 8> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8> *, const class Prealloced_array<Gtid_set::Interval*, 8>  &);

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8> *, );

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Interval * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8> *, class initializer_list<Gtid_set::Interval*>);

	class Prealloced_array<Gtid_set::Interval*, 8> & operator=(class Prealloced_array<Gtid_set::Interval*, 8> *, const class Prealloced_array<Gtid_set::Interval*, 8>  &);

	class Prealloced_array<Gtid_set::Interval*, 8> & operator=(class Prealloced_array<Gtid_set::Interval*, 8> *, );

	void ~Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8> *, int);

	size_t capacity(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	size_t element_size(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	bool empty(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	size_t size(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	class Interval * & at(class Prealloced_array<Gtid_set::Interval*, 8> *, size_t);

	class Interval * const & at(const class Prealloced_array<Gtid_set::Interval*, 8>  *, size_t);

	class Interval * & operator[](class Prealloced_array<Gtid_set::Interval*, 8> *, size_t);

	class Interval * const & operator[](const class Prealloced_array<Gtid_set::Interval*, 8>  *, size_t);

	class Interval * & back(class Prealloced_array<Gtid_set::Interval*, 8> *);

	class Interval * const & back(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	class Interval * & front(class Prealloced_array<Gtid_set::Interval*, 8> *);

	class Interval * const & front(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	typedef class Interval * * iterator;

	iterator begin(class Prealloced_array<Gtid_set::Interval*, 8> *);

	iterator end(class Prealloced_array<Gtid_set::Interval*, 8> *);

	const_iterator begin(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	const_iterator end(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	const_iterator cbegin(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	const_iterator cend(const class Prealloced_array<Gtid_set::Interval*, 8>  *);

	bool assign_at(class Prealloced_array<Gtid_set::Interval*, 8> *, size_t, const value_type  &);

	typedef class Interval * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Gtid_set::Interval*, 8> *, size_t);

	bool push_back(class Prealloced_array<Gtid_set::Interval*, 8> *, class Interval * const &);

	bool push_back(class Prealloced_array<Gtid_set::Interval*, 8> *, );

	void pop_back(class Prealloced_array<Gtid_set::Interval*, 8> *);

	iterator insert(class Prealloced_array<Gtid_set::Interval*, 8> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Gtid_set::Interval*, 8> *, const_iterator, );

	class pair<Gtid_set::Interval**, bool> insert_unique(class Prealloced_array<Gtid_set::Interval*, 8> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Gtid_set::Interval*, 8> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Gtid_set::Interval*, 8>  *, const value_type  &);

	iterator erase(class Prealloced_array<Gtid_set::Interval*, 8> *, const_iterator);

	iterator erase(class Prealloced_array<Gtid_set::Interval*, 8> *, size_t);

	void erase_at_end(class Prealloced_array<Gtid_set::Interval*, 8> *, const_iterator);

	iterator erase(class Prealloced_array<Gtid_set::Interval*, 8> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Gtid_set::Interval*, 8> *, class Prealloced_array<Gtid_set::Interval*, 8> &);

	void shrink_to_fit(class Prealloced_array<Gtid_set::Interval*, 8> *);

	void resize(class Prealloced_array<Gtid_set::Interval*, 8> *, size_t, class Interval * const &);

	void clear(class Prealloced_array<Gtid_set::Interval*, 8> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Interval *   m_buff[8];            /*     8    64 */
	};                                               /*     8    64 */

	/* size: 72, cachelines: 2, members: 3, static members: 2 */
	/* last cacheline: 8 bytes */
};
struct Gtid_set_or_null {
	class Gtid_set *           gtid_set;             /*     0     8 */
	bool                       is_non_null;          /*     8     1 */
	class Gtid_set * get_gtid_set(const class Gtid_set_or_null  *);

	class Gtid_set * set_non_null(class Gtid_set_or_null *, class Sid_map *);

	void set_null(class Gtid_set_or_null *);


	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
class Owned_gtids {
	struct Node {
		rpl_gno                    gno;                  /*     0     8 */
		my_thread_id               owner;                /*     8     4 */

		/* size: 16, cachelines: 1, members: 2 */
		/* padding: 4 */
		/* last cacheline: 16 bytes */
	};

public:

	void Owned_gtids(class Owned_gtids *, class Checkable_rwlock *);

	void ~Owned_gtids(class Owned_gtids *, int);

	enum enum_return_status add_gtid_owner(class Owned_gtids *, const class Gtid  &, my_thread_id);

	void get_gtids(const class Owned_gtids  *, class Gtid_set &);

	void remove_gtid(class Owned_gtids *, const class Gtid  &, my_thread_id);

	enum enum_return_status ensure_sidno(class Owned_gtids *, rpl_sidno);

	bool is_intersection_nonempty(const class Owned_gtids  *, const class Gtid_set  *);

	bool is_empty(const class Owned_gtids  *);

	rpl_sidno get_max_sidno(const class Owned_gtids  *);

	int to_string(const class Owned_gtids  *, char *);

	size_t get_max_string_length(const class Owned_gtids  *);

	bool thread_owns_anything(const class Owned_gtids  *, my_thread_id);

	void dbug_print(const class Owned_gtids  *, const char  *);

	bool is_owned_by(const class Owned_gtids  *, const class Gtid  &, my_thread_id);

	class Checkable_rwlock *   sid_lock;             /*     0     8 */
	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ get_hash(const class Owned_gtids  *, rpl_sidno);

	bool contains_gtid(const class Owned_gtids  *, const class Gtid  &);

	class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int> >*, 8> sidno_to_hash; /*     8    72 */

	/* size: 80, cachelines: 2, members: 2 */
	/* last cacheline: 16 bytes */
};
class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int> >*, 8> {
	struct External {
		class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ m_array_ptr; /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ m_buff[8]; /*     0    64 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ buffer(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ buffer(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	void set_size(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , size_t);

	void adjust_size(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , PSI_memory_key);

	void Prealloced_array(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	void Prealloced_array(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , );

	void Prealloced_array(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , PSI_memory_key, const_iterator, const_iterator);

	typedef class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int> > * const * const_iterator;

	void Prealloced_array(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , class initializer_list<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long  operator=(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long  operator=(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , );

	void ~Prealloced_array(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , int);

	size_t capacity(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	size_t element_size(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	bool empty(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	size_t size(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ at(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , size_t);

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ at(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash, size_t);

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ operator[](class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , size_t);

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ operator[](const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash, size_t);

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ back(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ back(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ front(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ front(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	typedef class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int> > * * iterator;

	iterator begin(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	iterator end(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	const_iterator begin(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	const_iterator end(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	const_iterator cbegin(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	const_iterator cend(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash);

	bool assign_at(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , size_t, const value_type  &);

	typedef class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int> > * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , size_t);

	bool push_back(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_);

	bool push_back(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , );

	void pop_back(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	iterator insert(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const_iterator, );

	class pair<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::e insert_unique(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const value_type  &);

	size_type count_unique(const class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash, const value_type  &);

	iterator erase(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const_iterator);

	iterator erase(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , size_t);

	void erase_at_end(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const_iterator);

	iterator erase(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , const_iterator, const_iterator);

	void swap(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	void shrink_to_fit(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	void resize(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long , size_t, class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_);

	void clear(class Prealloced_array<malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long );

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_ m_buff[8]; /*     8    64 */
	};                                               /*     8    64 */

	/* size: 72, cachelines: 2, members: 3, static members: 2 */
	/* last cacheline: 8 bytes */
};
class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int> > : public unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int>, Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > > > {
public:

	/* class unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_to<long int>, Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > > > <ancestor>; */ /*     0    64 */
	void malloc_unordered_multimap(class malloc_unordered_multimap<long int, std::unique_ptr<Owned_gtids::Node, My_free_deleter>, std::hash<long int>, std::equal_, PSI_memory_key);


	/* size: 64, cachelines: 1, members: 1 */

	/* BRAIN FART ALERT! 64 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 512 bits */
};
class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > >  *, reference);

	typedef class pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > & reference;

	typedef const class pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > >  *, const_reference);

	typedef const class pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >, false> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >, false> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_del, reference);

	typedef class _Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >, false> & reference;

	typedef const class _Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >, false>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_del, const_reference);

	typedef const class _Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >, false>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> , PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> , size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> , pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> , pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_del);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_del);

	typedef struct _Hash_node<std::pair<long int const, std::unique_ptr<Owned_gtids::Node, My_free_deleter> >, false> value_type;


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Prealloced_array<bool, 8> {
	struct External {
		bool *                     m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		bool                       m_buff[8];            /*     0     8 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<bool, 8>  *);

	bool * buffer(class Prealloced_array<bool, 8> *);

	const bool  * buffer(const class Prealloced_array<bool, 8>  *);

	void set_size(class Prealloced_array<bool, 8> *, size_t);

	void adjust_size(class Prealloced_array<bool, 8> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<bool, 8> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<bool, 8> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<bool, 8> *, const class Prealloced_array<bool, 8>  &);

	void Prealloced_array(class Prealloced_array<bool, 8> *, );

	void Prealloced_array(class Prealloced_array<bool, 8> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const bool  * const_iterator;

	void Prealloced_array(class Prealloced_array<bool, 8> *, class initializer_list<bool>);

	class Prealloced_array<bool, 8> & operator=(class Prealloced_array<bool, 8> *, const class Prealloced_array<bool, 8>  &);

	class Prealloced_array<bool, 8> & operator=(class Prealloced_array<bool, 8> *, );

	void ~Prealloced_array(class Prealloced_array<bool, 8> *, int);

	size_t capacity(const class Prealloced_array<bool, 8>  *);

	size_t element_size(const class Prealloced_array<bool, 8>  *);

	bool empty(const class Prealloced_array<bool, 8>  *);

	size_t size(const class Prealloced_array<bool, 8>  *);

	bool & at(class Prealloced_array<bool, 8> *, size_t);

	const bool  & at(const class Prealloced_array<bool, 8>  *, size_t);

	bool & operator[](class Prealloced_array<bool, 8> *, size_t);

	const bool  & operator[](const class Prealloced_array<bool, 8>  *, size_t);

	bool & back(class Prealloced_array<bool, 8> *);

	const bool  & back(const class Prealloced_array<bool, 8>  *);

	bool & front(class Prealloced_array<bool, 8> *);

	const bool  & front(const class Prealloced_array<bool, 8>  *);

	typedef bool * iterator;

	iterator begin(class Prealloced_array<bool, 8> *);

	iterator end(class Prealloced_array<bool, 8> *);

	const_iterator begin(const class Prealloced_array<bool, 8>  *);

	const_iterator end(const class Prealloced_array<bool, 8>  *);

	const_iterator cbegin(const class Prealloced_array<bool, 8>  *);

	const_iterator cend(const class Prealloced_array<bool, 8>  *);

	bool assign_at(class Prealloced_array<bool, 8> *, size_t, const value_type  &);

	typedef bool value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<bool, 8> *, size_t);

	bool push_back(class Prealloced_array<bool, 8> *, const bool  &);

	bool push_back(class Prealloced_array<bool, 8> *, );

	void pop_back(class Prealloced_array<bool, 8> *);

	iterator insert(class Prealloced_array<bool, 8> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<bool, 8> *, const_iterator, );

	class pair<bool*, bool> insert_unique(class Prealloced_array<bool, 8> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<bool, 8> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<bool, 8>  *, const value_type  &);

	iterator erase(class Prealloced_array<bool, 8> *, const_iterator);

	iterator erase(class Prealloced_array<bool, 8> *, size_t);

	void erase_at_end(class Prealloced_array<bool, 8> *, const_iterator);

	iterator erase(class Prealloced_array<bool, 8> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<bool, 8> *, class Prealloced_array<bool, 8> &);

	void shrink_to_fit(class Prealloced_array<bool, 8> *);

	void resize(class Prealloced_array<bool, 8> *, size_t, const bool  &);

	void clear(class Prealloced_array<bool, 8> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		bool               m_buff[8];            /*     8     8 */
	};                                               /*     8    24 */

	/* size: 32, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 32 bytes */
};
class Gtid_state {
public:

	void Gtid_state(class Gtid_state *, class Checkable_rwlock *, class Sid_map *);

	int init(class Gtid_state *);

	int clear(class Gtid_state *, class THD *);

	bool is_executed(const class Gtid_state  *, const class Gtid  &);

	bool is_owned(const class Gtid_state  *, const class Gtid  &);

	enum enum_return_status acquire_ownership(class Gtid_state *, class THD *, const class Gtid  &);

	void update_commit_group(class Gtid_state *, class THD *);

	void update_on_commit(class Gtid_state *, class THD *);

	void update_on_rollback(class Gtid_state *, class THD *);

	void acquire_anonymous_ownership(class Gtid_state *);

	void release_anonymous_ownership(class Gtid_state *);

	int32 get_anonymous_ownership_count(class Gtid_state *);

	void begin_automatic_gtid_violating_transaction(class Gtid_state *);

	void end_automatic_gtid_violating_transaction(class Gtid_state *);

	int32 get_automatic_gtid_violating_transaction_count(class Gtid_state *);

	void begin_anonymous_gtid_violating_transaction(class Gtid_state *);

	void end_anonymous_gtid_violating_transaction(class Gtid_state *);

	void end_gtid_violating_transaction(class Gtid_state *, class THD *);

	int32 get_anonymous_gtid_violating_transaction_count(class Gtid_state *);

	void begin_gtid_wait(class Gtid_state *);

	void end_gtid_wait(class Gtid_state *);

	int32 get_gtid_wait_count(class Gtid_state *);

	rpl_gno get_automatic_gno(const class Gtid_state  *, rpl_sidno);

	rpl_gno                    next_free_gno;        /*     0     8 */
	rpl_gno get_last_executed_gno(const class Gtid_state  *, rpl_sidno);

	enum enum_return_status generate_automatic_gtid(class Gtid_state *, class THD *, rpl_sidno, rpl_gno, rpl_sidno *);

	void lock_sidno(class Gtid_state *, rpl_sidno);

	void unlock_sidno(class Gtid_state *, rpl_sidno);

	void broadcast_sidno(class Gtid_state *, rpl_sidno);

	void assert_sidno_lock_owner(const class Gtid_state  *, rpl_sidno);

	bool wait_for_sidno(class Gtid_state *, class THD *, rpl_sidno, class timespec *);

	bool wait_for_gtid(class Gtid_state *, class THD *, const class Gtid  &, class timespec *);

	bool wait_for_gtid_set(class Gtid_state *, class THD *, class Gtid_set *, double);

	void lock_sidnos(class Gtid_state *, const class Gtid_set  *);

	void unlock_sidnos(class Gtid_state *, const class Gtid_set  *);

	void broadcast_sidnos(class Gtid_state *, const class Gtid_set  *);

	enum enum_return_status ensure_sidno(class Gtid_state *);

	enum enum_return_status add_lost_gtids(class Gtid_state *, class Gtid_set *, bool);

	void update_prev_gtids(class Gtid_state *, class Gtid_set *);

	const class Gtid_set  * get_lost_gtids(const class Gtid_state  *);

	const class Gtid_set  * get_executed_gtids(const class Gtid_state  *);

	const class Gtid_set  * get_gtids_only_in_table(const class Gtid_state  *);

	const class Gtid_set  * get_previous_gtids_logged(const class Gtid_state  *);

	const class Owned_gtids  * get_owned_gtids(const class Gtid_state  *);

	rpl_sidno get_server_sidno(const class Gtid_state  *);

	const rpl_sid  & get_server_sid(const class Gtid_state  *);

	void dbug_print(const class Gtid_state  *, const char  *);

	int save(class Gtid_state *, class THD *);

	int save(class Gtid_state *, const class Gtid_set  *);

	int save_gtids_of_last_binlog_into_table(class Gtid_state *);

	int read_gtid_executed_from_table(class Gtid_state *);

	int compress(class Gtid_state *, class THD *);

	int warn_or_err_on_modify_gtid_table(class Gtid_state *, class THD *, class TABLE_LIST *);

	void get_snapshot_gtid_executed(class Gtid_state *, string &);

	void update_gtids_impl(class Gtid_state *, class THD *, bool);

	void unlock_owned_sidnos(class Gtid_state *, const class THD  *);

	void broadcast_owned_sidnos(class Gtid_state *, const class THD  *);

	class Checkable_rwlock *   sid_lock;             /*     8     8 */
	class Sid_map *            sid_map;              /*    16     8 */
	class Mutex_cond_array    sid_locks;             /*    24    80 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	class Gtid_set            lost_gtids;            /*   104   176 */
	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	class Gtid_set            executed_gtids;        /*   280   176 */
	/* --- cacheline 7 boundary (448 bytes) was 8 bytes ago --- */
	class Gtid_set            gtids_only_in_table;   /*   456   176 */
	/* --- cacheline 9 boundary (576 bytes) was 56 bytes ago --- */
	class Gtid_set            previous_gtids_logged; /*   632   176 */
	/* --- cacheline 12 boundary (768 bytes) was 40 bytes ago --- */
	class Owned_gtids         owned_gtids;           /*   808    80 */
	/* --- cacheline 13 boundary (832 bytes) was 56 bytes ago --- */
	rpl_sidno                  server_sidno;         /*   888     4 */
	struct atomic<int>         atomic_anonymous_gtid_count __attribute__((__aligned__(4))); /*   892     4 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	struct atomic<int>         atomic_automatic_gtid_violation_count __attribute__((__aligned__(4))); /*   896     4 */
	struct atomic<int>         atomic_anonymous_gtid_violation_count __attribute__((__aligned__(4))); /*   900     4 */
	struct atomic<int>         atomic_gtid_wait_count __attribute__((__aligned__(4))); /*   904     4 */

	/* XXX 4 bytes hole, try to pack */
	bool update_gtids_impl_check_skip_gtid_rollback(class Gtid_state *, class THD *);

	bool update_gtids_impl_do_nothing(class Gtid_state *, class THD *);

	bool update_gtids_impl_begin(class Gtid_state *, class THD *);

	void update_gtids_impl_own_gtid_set(class Gtid_state *, class THD *, bool);

	void update_gtids_impl_lock_sidno(class Gtid_state *, rpl_sidno);

	void update_gtids_impl_lock_sidnos(class Gtid_state *, class THD *);

	void update_gtids_impl_own_gtid(class Gtid_state *, class THD *, bool);

	void update_gtids_impl_broadcast_and_unlock_sidno(class Gtid_state *, rpl_sidno);

	void update_gtids_impl_broadcast_and_unlock_sidnos(class Gtid_state *);

	void update_gtids_impl_own_anonymous(class Gtid_state *, class THD *, bool *);

	void update_gtids_impl_own_nothing(class Gtid_state *, class THD *);

	void update_gtids_impl_end(class Gtid_state *, class THD *, bool);


	class Prealloced_array<bool, 8> commit_group_sidnos; /*   912    32 */
	enum enum_return_status ensure_commit_group_sidnos(class Gtid_state *, rpl_sidno);


	/* size: 944, cachelines: 15, members: 15 */
	/* sum members: 940, holes: 1, sum holes: 4 */
	/* forced alignments: 4 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
struct Gtid_specification {
	enum enum_gtid_type        type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct Gtid                gtid;                 /*     8    16 */
	void set(class Gtid_specification *, rpl_sidno, rpl_gno);

	void set(class Gtid_specification *, const class Gtid  &);

	void set_automatic(class Gtid_specification *);

	void set_anonymous(class Gtid_specification *);

	void set_not_yet_determined(class Gtid_specification *);

	void set_undefined(class Gtid_specification *);

	bool equals(const class Gtid_specification  *, const class Gtid_specification  &);

	bool equals(const class Gtid_specification  *, const class Gtid  &);

	enum enum_return_status parse(class Gtid_specification *, class Sid_map *, const char  *);

	bool is_valid(const char  *);


	/* Bitfield combined with previous fields */

	static const int                  MAX_TEXT_LENGTH = 56; /*     0     0 */
	int to_string(const class Gtid_specification  *, const class Sid_map  *, char *, bool);

	int to_string(const class Gtid_specification  *, const rpl_sid  *, char *);

	void dbug_print(const class Gtid_specification  *, const char  *, bool);


	/* size: 24, cachelines: 1, members: 2, static members: 1 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct st_plugin_int {
	LEX_CSTRING                name;                 /*     0    16 */
	class st_mysql_plugin *    plugin;               /*    16     8 */
	class st_plugin_dl *       plugin_dl;            /*    24     8 */
	uint                       state;                /*    32     4 */
	uint                       ref_count;            /*    36     4 */
	void *                     data;                 /*    40     8 */
	struct MEM_ROOT            mem_root;             /*    48    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) --- */
	class sys_var *            system_vars;          /*   128     8 */
	enum enum_plugin_load_option load_option;        /*   136     4 */

	/* size: 144, cachelines: 3, members: 9 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 16 bytes */
};
struct st_mysql_plugin {
	int                        type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     info;                 /*     8     8 */
	const char  *              name;                 /*    16     8 */
	const char  *              author;               /*    24     8 */
	const char  *              descr;                /*    32     8 */
	int                        license;              /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	int                        (*init)(MYSQL_PLUGIN); /*    48     8 */
	int                        (*check_uninstall)(MYSQL_PLUGIN); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        (*deinit)(MYSQL_PLUGIN); /*    64     8 */
	unsigned int               version;              /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	class SHOW_VAR *           status_vars;          /*    80     8 */
	class SYS_VAR * *          system_vars;          /*    88     8 */
	void *                     __reserved1;          /*    96     8 */
	long unsigned int          flags;                /*   104     8 */

	/* size: 112, cachelines: 2, members: 14 */
	/* sum members: 100, holes: 3, sum holes: 12 */
	/* last cacheline: 48 bytes */
};
struct st_plugin_dl {
	LEX_STRING                 dl;                   /*     0    16 */
	void *                     handle;               /*    16     8 */
	class st_mysql_plugin *    plugins;              /*    24     8 */
	int                        version;              /*    32     4 */
	uint                       ref_count;            /*    36     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
class Prealloced_array<st_plugin_int*, 2> {
	struct External {
		class st_plugin_int * *    m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class st_plugin_int *      m_buff[2];            /*     0    16 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<st_plugin_int*, 2>  *);

	class st_plugin_int * * buffer(class Prealloced_array<st_plugin_int*, 2> *);

	class st_plugin_int * const * buffer(const class Prealloced_array<st_plugin_int*, 2>  *);

	void set_size(class Prealloced_array<st_plugin_int*, 2> *, size_t);

	void adjust_size(class Prealloced_array<st_plugin_int*, 2> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2> *, const class Prealloced_array<st_plugin_int*, 2>  &);

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2> *, );

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class st_plugin_int * const * const_iterator;

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2> *, class initializer_list<st_plugin_int*>);

	class Prealloced_array<st_plugin_int*, 2> & operator=(class Prealloced_array<st_plugin_int*, 2> *, const class Prealloced_array<st_plugin_int*, 2>  &);

	class Prealloced_array<st_plugin_int*, 2> & operator=(class Prealloced_array<st_plugin_int*, 2> *, );

	void ~Prealloced_array(class Prealloced_array<st_plugin_int*, 2> *, int);

	size_t capacity(const class Prealloced_array<st_plugin_int*, 2>  *);

	size_t element_size(const class Prealloced_array<st_plugin_int*, 2>  *);

	bool empty(const class Prealloced_array<st_plugin_int*, 2>  *);

	size_t size(const class Prealloced_array<st_plugin_int*, 2>  *);

	class st_plugin_int * & at(class Prealloced_array<st_plugin_int*, 2> *, size_t);

	class st_plugin_int * const & at(const class Prealloced_array<st_plugin_int*, 2>  *, size_t);

	class st_plugin_int * & operator[](class Prealloced_array<st_plugin_int*, 2> *, size_t);

	class st_plugin_int * const & operator[](const class Prealloced_array<st_plugin_int*, 2>  *, size_t);

	class st_plugin_int * & back(class Prealloced_array<st_plugin_int*, 2> *);

	class st_plugin_int * const & back(const class Prealloced_array<st_plugin_int*, 2>  *);

	class st_plugin_int * & front(class Prealloced_array<st_plugin_int*, 2> *);

	class st_plugin_int * const & front(const class Prealloced_array<st_plugin_int*, 2>  *);

	typedef class st_plugin_int * * iterator;

	iterator begin(class Prealloced_array<st_plugin_int*, 2> *);

	iterator end(class Prealloced_array<st_plugin_int*, 2> *);

	const_iterator begin(const class Prealloced_array<st_plugin_int*, 2>  *);

	const_iterator end(const class Prealloced_array<st_plugin_int*, 2>  *);

	const_iterator cbegin(const class Prealloced_array<st_plugin_int*, 2>  *);

	const_iterator cend(const class Prealloced_array<st_plugin_int*, 2>  *);

	bool assign_at(class Prealloced_array<st_plugin_int*, 2> *, size_t, const value_type  &);

	typedef class st_plugin_int * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<st_plugin_int*, 2> *, size_t);

	bool push_back(class Prealloced_array<st_plugin_int*, 2> *, class st_plugin_int * const &);

	bool push_back(class Prealloced_array<st_plugin_int*, 2> *, );

	void pop_back(class Prealloced_array<st_plugin_int*, 2> *);

	iterator insert(class Prealloced_array<st_plugin_int*, 2> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<st_plugin_int*, 2> *, const_iterator, );

	class pair<st_plugin_int**, bool> insert_unique(class Prealloced_array<st_plugin_int*, 2> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<st_plugin_int*, 2> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<st_plugin_int*, 2>  *, const value_type  &);

	iterator erase(class Prealloced_array<st_plugin_int*, 2> *, const_iterator);

	iterator erase(class Prealloced_array<st_plugin_int*, 2> *, size_t);

	void erase_at_end(class Prealloced_array<st_plugin_int*, 2> *, const_iterator);

	iterator erase(class Prealloced_array<st_plugin_int*, 2> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<st_plugin_int*, 2> *, class Prealloced_array<st_plugin_int*, 2> &);

	void shrink_to_fit(class Prealloced_array<st_plugin_int*, 2> *);

	void resize(class Prealloced_array<st_plugin_int*, 2> *, size_t, class st_plugin_int * const &);

	void clear(class Prealloced_array<st_plugin_int*, 2> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class st_plugin_int * m_buff[2];         /*     8    16 */
	};                                               /*     8    24 */

	/* size: 32, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 32 bytes */
};
class Plugin_array : public Prealloced_array<st_plugin_int*, 2> {
public:

	/* class Prealloced_array<st_plugin_int*, 2> <ancestor>; */ /*     0    32 */
	void Plugin_array(class Plugin_array *, PSI_memory_key);

	bool exists(class Plugin_array *, plugin_ref);

	void ~Plugin_array(class Plugin_array *, int);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
struct fragmentation_stats_t {
	ulonglong                  scan_pages_contiguous; /*     0     8 */
	ulonglong                  scan_pages_disjointed; /*     8     8 */
	ulonglong                  scan_pages_total_seek_distance; /*    16     8 */
	ulonglong                  scan_data_size;       /*    24     8 */
	ulonglong                  scan_deleted_recs_size; /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct System_variables {
	ulong                      dynamic_variables_version; /*     0     8 */
	char *                     dynamic_variables_ptr; /*     8     8 */
	uint                       dynamic_variables_head; /*    16     4 */
	uint                       dynamic_variables_size; /*    20     4 */
	class LIST *               dynamic_variables_allocs; /*    24     8 */
	ulonglong                  max_heap_table_size;  /*    32     8 */
	ulonglong                  tmp_table_size;       /*    40     8 */
	ulonglong                  long_query_time;      /*    48     8 */
	bool                       end_markers_in_json;  /*    56     1 */
	bool                       windowing_use_high_precision; /*    57     1 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  optimizer_switch;     /*    64     8 */
	ulonglong                  optimizer_trace;      /*    72     8 */
	ulonglong                  optimizer_trace_features; /*    80     8 */
	long int                   optimizer_trace_offset; /*    88     8 */
	long int                   optimizer_trace_limit; /*    96     8 */
	ulong                      optimizer_trace_max_mem_size; /*   104     8 */
	sql_mode_t                 sql_mode;             /*   112     8 */
	ulonglong                  option_bits;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ha_rows                    select_limit;         /*   128     8 */
	ha_rows                    max_join_size;        /*   136     8 */
	ulong                      auto_increment_increment; /*   144     8 */
	ulong                      auto_increment_offset; /*   152     8 */
	ulong                      bulk_insert_buff_size; /*   160     8 */
	uint                       eq_range_index_dive_limit; /*   168     4 */
	uint                       cte_max_recursion_depth; /*   172     4 */
	ulonglong                  histogram_generation_max_mem_size; /*   176     8 */
	ulong                      join_buff_size;       /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	ulong                      lock_wait_timeout;    /*   192     8 */
	ulong                      max_allowed_packet;   /*   200     8 */
	ulong                      max_error_count;      /*   208     8 */
	ulong                      max_length_for_sort_data; /*   216     8 */
	ulong                      max_points_in_geometry; /*   224     8 */
	ulong                      max_sort_length;      /*   232     8 */
	ulong                      max_insert_delayed_threads; /*   240     8 */
	ulong                      min_examined_row_limit; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	ulong                      net_buffer_length;    /*   256     8 */
	ulong                      net_interactive_timeout; /*   264     8 */
	ulong                      net_read_timeout;     /*   272     8 */
	ulong                      net_retry_count;      /*   280     8 */
	ulong                      net_wait_timeout;     /*   288     8 */
	ulong                      net_write_timeout;    /*   296     8 */
	ulong                      optimizer_prune_level; /*   304     8 */
	ulong                      optimizer_search_depth; /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	ulonglong                  parser_max_mem_size;  /*   320     8 */
	ulong                      range_optimizer_max_mem_size; /*   328     8 */
	ulong                      preload_buff_size;    /*   336     8 */
	ulong                      profiling_history_size; /*   344     8 */
	ulong                      read_buff_size;       /*   352     8 */
	ulong                      read_rnd_buff_size;   /*   360     8 */
	ulong                      div_precincrement;    /*   368     8 */
	ulong                      sortbuff_size;        /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	ulong                      max_sp_recursion_depth; /*   384     8 */
	ulong                      default_week_format;  /*   392     8 */
	ulong                      max_seeks_for_key;    /*   400     8 */
	ulong                      range_alloc_block_size; /*   408     8 */
	ulong                      query_alloc_block_size; /*   416     8 */
	ulong                      query_prealloc_size;  /*   424     8 */
	ulong                      trans_alloc_block_size; /*   432     8 */
	ulong                      trans_prealloc_size;  /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	ulong                      group_concat_max_len; /*   448     8 */
	ulong                      binlog_format;        /*   456     8 */
	ulong                      rbr_exec_mode_options; /*   464     8 */
	bool                       binlog_direct_non_trans_update; /*   472     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      binlog_row_image;     /*   480     8 */
	bool                       binlog_trx_compression; /*   488     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      binlog_trx_compression_type; /*   496     8 */
	uint                       binlog_trx_compression_level_zstd; /*   504     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 8 boundary (512 bytes) --- */
	ulonglong                  binlog_row_value_options; /*   512     8 */
	bool                       sql_log_bin;          /*   520     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      transaction_write_set_extraction; /*   528     8 */
	ulong                      completion_type;      /*   536     8 */
	ulong                      transaction_isolation; /*   544     8 */
	ulong                      updatable_views_with_limit; /*   552     8 */
	uint                       max_user_connections; /*   560     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      my_aes_mode;          /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	ulong                      ssl_fips_mode;        /*   576     8 */
	ulong                      resultset_metadata;   /*   584     8 */
	my_thread_id               pseudo_thread_id;     /*   592     4 */
	bool                       transaction_read_only; /*   596     1 */
	bool                       low_priority_updates; /*   597     1 */
	bool                       new_mode;             /*   598     1 */
	bool                       keep_files_on_create; /*   599     1 */
	bool                       old_alter_table;      /*   600     1 */
	bool                       big_tables;           /*   601     1 */

	/* XXX 6 bytes hole, try to pack */

	plugin_ref                 table_plugin;         /*   608     8 */
	plugin_ref                 temp_table_plugin;    /*   616     8 */
	const class CHARSET_INFO  * character_set_filesystem; /*   624     8 */
	const class CHARSET_INFO  * character_set_client; /*   632     8 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	const class CHARSET_INFO  * character_set_results; /*   640     8 */
	const class CHARSET_INFO  * collation_server;    /*   648     8 */
	const class CHARSET_INFO  * collation_database;  /*   656     8 */
	const class CHARSET_INFO  * collation_connection; /*   664     8 */
	class MY_LOCALE *          lc_messages;          /*   672     8 */
	class MY_LOCALE *          lc_time_names;        /*   680     8 */
	class Time_zone *          time_zone;            /*   688     8 */
	bool                       explicit_defaults_for_timestamp; /*   696     1 */
	bool                       sysdate_is_now;       /*   697     1 */
	bool                       binlog_rows_query_log_events; /*   698     1 */
	bool                       binlog_ddl_skip_rewrite; /*   699     1 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 11 boundary (704 bytes) --- */
	ulong                      log_slow_rate_limit;  /*   704     8 */
	ulonglong                  log_slow_filter;      /*   712     8 */
	ulonglong                  log_slow_verbosity;   /*   720     8 */
	ulong                      innodb_io_reads;      /*   728     8 */
	ulonglong                  innodb_io_read;       /*   736     8 */
	uint64_t                   innodb_io_reads_wait_timer; /*   744     8 */
	uint64_t                   innodb_lock_que_wait_timer; /*   752     8 */
	uint64_t                   innodb_innodb_que_wait_timer; /*   760     8 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	ulong                      innodb_page_access;   /*   768     8 */
	double                     long_query_time_double; /*   776     8 */
	bool                       pseudo_replica_mode;  /*   784     1 */

	/* XXX 7 bytes hole, try to pack */

	struct Gtid_specification  gtid_next;            /*   792    24 */
	struct Gtid_set_or_null    gtid_next_list;       /*   816    16 */

	/* XXX last struct has 7 bytes of padding */

	/* --- cacheline 13 boundary (832 bytes) --- */
	ulong                      session_track_gtids;  /*   832     8 */
	ulong                      max_execution_time;   /*   840     8 */
	char *                     track_sysvars_ptr;    /*   848     8 */
	bool                       session_track_schema; /*   856     1 */
	bool                       session_track_state_change; /*   857     1 */
	bool                       expand_fast_index_creation; /*   858     1 */

	/* XXX 1 byte hole, try to pack */

	uint                       threadpool_high_prio_tickets; /*   860     4 */
	ulong                      threadpool_high_prio_mode; /*   864     8 */
	ulong                      session_track_transaction_info; /*   872     8 */
	ulong                      information_schema_stats_expiry; /*   880     8 */
	bool                       show_create_table_verbosity; /*   888     1 */
	bool                       show_old_temporals;   /*   889     1 */
	bool                       ft_query_extra_word_chars; /*   890     1 */

	/* XXX 5 bytes hole, try to pack */

	/* --- cacheline 14 boundary (896 bytes) --- */
	ulonglong                  original_commit_timestamp; /*   896     8 */
	ulong                      internal_tmp_mem_storage_engine; /*   904     8 */
	const class CHARSET_INFO  * default_collation_for_utf8mb4; /*   912     8 */
	ulong                      use_secondary_engine; /*   920     8 */
	double                     secondary_engine_cost_threshold; /*   928     8 */
	ulong                      group_replication_consistency; /*   936     8 */
	bool                       sql_require_primary_key; /*   944     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   original_server_version; /*   948     4 */
	uint32_t                   immediate_server_version; /*   952     4 */
	bool                       print_identified_with_as_hex; /*   956     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 15 boundary (960 bytes) --- */
	ulong                      default_table_encryption; /*   960     8 */
	bool                       show_create_table_skip_secondary_engine; /*   968     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   generated_random_password_length; /*   972     4 */
	bool                       require_row_format;   /*   976     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      select_into_buffer_size; /*   984     8 */
	bool                       select_into_disk_sync; /*   992     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       select_into_disk_sync_delay; /*   996     4 */
	ulong                      terminology_use_previous; /*  1000     8 */

	/* size: 1008, cachelines: 16, members: 143 */
	/* sum members: 931, holes: 16, sum holes: 77 */
	/* paddings: 1, sum paddings: 7 */
	/* last cacheline: 48 bytes */
};
struct LIST {
	class LIST *               prev;                 /*     0     8 */
	class LIST *               next;                 /*     8     8 */
	void *                     data;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct System_status_var {
	ulonglong                  created_tmp_disk_tables; /*     0     8 */
	ulonglong                  created_tmp_tables;   /*     8     8 */
	ulonglong                  ha_commit_count;      /*    16     8 */
	ulonglong                  ha_delete_count;      /*    24     8 */
	ulonglong                  ha_read_first_count;  /*    32     8 */
	ulonglong                  ha_read_last_count;   /*    40     8 */
	ulonglong                  ha_read_key_count;    /*    48     8 */
	ulonglong                  ha_read_next_count;   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  ha_read_prev_count;   /*    64     8 */
	ulonglong                  ha_read_rnd_count;    /*    72     8 */
	ulonglong                  ha_read_rnd_next_count; /*    80     8 */
	ulonglong                  ha_multi_range_read_init_count; /*    88     8 */
	ulonglong                  ha_rollback_count;    /*    96     8 */
	ulonglong                  ha_update_count;      /*   104     8 */
	ulonglong                  ha_write_count;       /*   112     8 */
	ulonglong                  ha_prepare_count;     /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ulonglong                  ha_discover_count;    /*   128     8 */
	ulonglong                  ha_savepoint_count;   /*   136     8 */
	ulonglong                  ha_savepoint_rollback_count; /*   144     8 */
	ulonglong                  ha_external_lock_count; /*   152     8 */
	ulonglong                  opened_tables;        /*   160     8 */
	ulonglong                  opened_shares;        /*   168     8 */
	ulonglong                  table_open_cache_hits; /*   176     8 */
	ulonglong                  table_open_cache_misses; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	ulonglong                  table_open_cache_overflows; /*   192     8 */
	ulonglong                  select_full_join_count; /*   200     8 */
	ulonglong                  select_full_range_join_count; /*   208     8 */
	ulonglong                  select_range_count;   /*   216     8 */
	ulonglong                  select_range_check_count; /*   224     8 */
	ulonglong                  select_scan_count;    /*   232     8 */
	ulonglong                  long_query_count;     /*   240     8 */
	ulonglong                  filesort_merge_passes; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	ulonglong                  filesort_range_count; /*   256     8 */
	ulonglong                  filesort_rows;        /*   264     8 */
	ulonglong                  filesort_scan_count;  /*   272     8 */
	ulonglong                  com_stmt_prepare;     /*   280     8 */
	ulonglong                  com_stmt_reprepare;   /*   288     8 */
	ulonglong                  com_stmt_execute;     /*   296     8 */
	ulonglong                  com_stmt_send_long_data; /*   304     8 */
	ulonglong                  com_stmt_fetch;       /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	ulonglong                  com_stmt_reset;       /*   320     8 */
	ulonglong                  com_stmt_close;       /*   328     8 */
	ulonglong                  bytes_received;       /*   336     8 */
	ulonglong                  bytes_sent;           /*   344     8 */
	ulonglong                  net_buffer_length;    /*   352     8 */
	ulonglong                  max_execution_time_exceeded; /*   360     8 */
	ulonglong                  max_execution_time_set; /*   368     8 */
	ulonglong                  max_execution_time_set_failed; /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	ulonglong                  questions;            /*   384     8 */
	ulonglong                  secondary_engine_execution_count; /*   392     8 */
	ulong                      com_other;            /*   400     8 */
	ulong                      com_stat[167];        /*   408  1336 */
	/* --- cacheline 27 boundary (1728 bytes) was 16 bytes ago --- */
	double                     last_query_cost;      /*  1744     8 */
	ulonglong                  last_query_partial_plans; /*  1752     8 */
	struct fragmentation_stats_t fragmentation_stats; /*  1760    40 */

	/* size: 1800, cachelines: 29, members: 55 */
	/* last cacheline: 8 bytes */
};
class Dependency_tracker_ctx {
public:

	void Dependency_tracker_ctx(class Dependency_tracker_ctx *);

	void set_last_session_sequence_number(class Dependency_tracker_ctx *, int64);

	int64 get_last_session_sequence_number(class Dependency_tracker_ctx *);

	int64                      m_last_session_sequence_number; /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Rpl_thd_context {
	class Session_consistency_gtids_ctx m_session_gtids_ctx; /*     0     0 */

	/* XXX 40 bytes hole, try to pack */

	class Dependency_tracker_ctx m_dependency_tracker_ctx; /*    40     8 */
	class Last_used_gtid_tracker_ctx m_last_used_gtid_tracker_ctx; /*    48     0 */

	/* XXX 16 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	class Transaction_compression_ctx m_transaction_compression_ctx; /*    64     0 */

	/* XXX 16 bytes hole, try to pack */

	enum enum_rpl_channel_type rpl_channel_type;     /*    80     4 */
	void Rpl_thd_context(class Rpl_thd_context *, const class Rpl_thd_context  &);

	class Rpl_thd_context & operator=(class Rpl_thd_context *, const class Rpl_thd_context  &);

public:

	void Rpl_thd_context(class Rpl_thd_context *);

	class Session_consistency_gtids_ctx & session_gtids_ctx(class Rpl_thd_context *);

	class Dependency_tracker_ctx & dependency_tracker_ctx(class Rpl_thd_context *);

	class Last_used_gtid_tracker_ctx & last_used_gtid_tracker_ctx(class Rpl_thd_context *);

	enum enum_rpl_channel_type get_rpl_channel_type(class Rpl_thd_context *);

	void set_rpl_channel_type(class Rpl_thd_context *, enum enum_rpl_channel_type);

	class Transaction_compression_ctx & transaction_compression_ctx(class Rpl_thd_context *);

	void ~Rpl_thd_context(class Rpl_thd_context *, int);


	/* size: 88, cachelines: 2, members: 5 */
	/* sum members: 12, holes: 3, sum holes: 72 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct Lock_descriptor {
	enum thr_lock_type         type;                 /*     0     4 */
	enum thr_locked_row_action action;               /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct THR_LOCK_INFO {
	my_thread_id               thread_id;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class mysql_cond_t *       suspend;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct THR_LOCK_DATA {
	class THR_LOCK_INFO *      owner;                /*     0     8 */
	class THR_LOCK_DATA *      next;                 /*     8     8 */
	class THR_LOCK_DATA * *    prev;                 /*    16     8 */
	class THR_LOCK *           lock;                 /*    24     8 */
	class mysql_cond_t *       cond;                 /*    32     8 */
	enum thr_lock_type         type;                 /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     status_param;         /*    48     8 */
	void *                     debug_print_param;    /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class PSI_table *          m_psi;                /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* sum members: 68, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct THR_LOCK {
	LIST                       list;                 /*     0    24 */
	struct mysql_mutex_t       mutex;                /*    24    48 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	struct st_lock_list        read_wait;            /*    72    16 */
	struct st_lock_list        read;                 /*    88    16 */
	struct st_lock_list        write_wait;           /*   104    16 */
	struct st_lock_list        write;                /*   120    16 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	ulong                      write_lock_count;     /*   136     8 */
	uint                       read_no_write_count;  /*   144     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*get_status)(void *, int); /*   152     8 */
	void                       (*copy_status)(void *, void *); /*   160     8 */
	void                       (*update_status)(void *); /*   168     8 */
	void                       (*restore_status)(void *); /*   176     8 */
	bool                       (*check_status)(void *); /*   184     8 */

	/* size: 192, cachelines: 3, members: 13 */
	/* sum members: 188, holes: 1, sum holes: 4 */
};
struct st_lock_list {
	class THR_LOCK_DATA *      data;                 /*     0     8 */
	class THR_LOCK_DATA * *    last;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Session_tracker {
	class State_tracker *      m_trackers[5];        /*     0    40 */
public:

	void Session_tracker(class Session_tracker *, const class Session_tracker  &);

	class Session_tracker & operator=(class Session_tracker *, const class Session_tracker  &);

	void Session_tracker(class Session_tracker *);

	void ~Session_tracker(class Session_tracker *, int);

	void init(class Session_tracker *, const class CHARSET_INFO  *);

	void enable(class Session_tracker *, class THD *);

	bool server_boot_verify(class Session_tracker *, const class CHARSET_INFO  *, LEX_STRING);

	class State_tracker * get_tracker(const class Session_tracker  *, enum enum_session_tracker);

	bool enabled_any(class Session_tracker *);

	bool changed_any(class Session_tracker *);

	void store(class Session_tracker *, class THD *, class String &);

	void deinit(class Session_tracker *);

	void claim_memory_ownership(class Session_tracker *, bool);


	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
class State_tracker {
public:

	void State_tracker(class State_tracker *, const class State_tracker  &);

	int ()(void) * *           _vptr.State_tracker;  /*     0     8 */
protected:

	bool                       m_enabled;            /*     8     1 */
	bool                       m_changed;            /*     9     1 */
public:

	void State_tracker(class State_tracker *);

	virtual void ~State_tracker(class State_tracker *, int);

	bool is_enabled(const class State_tracker  *);

	bool is_changed(const class State_tracker  *);

	virtual bool enable(class State_tracker *, class THD *);

	virtual bool check(class State_tracker *, class THD *, class set_var *);

	virtual bool update(class State_tracker *, class THD *);

	virtual bool store(class State_tracker *, class THD *, class String &);

	virtual void mark_as_changed(class State_tracker *, class THD *, LEX_CSTRING *);

	virtual void claim_memory_ownership(class State_tracker *, bool);

	/* vtable has 6 entries: {
	   [2] = enable((null)), 
	   [3] = check((null)), 
	   [4] = update((null)), 
	   [5] = store((null)), 
	   [6] = mark_as_changed((null)), 
	   [7] = claim_memory_ownership((null)), 
	} */
	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct user_resources {
	uint                       questions;            /*     0     4 */
	uint                       updates;              /*     4     4 */
	uint                       conn_per_hour;        /*     8     4 */
	uint                       user_conn;            /*    12     4 */
	uint                       specified_limits;     /*    16     4 */

	/* size: 20, cachelines: 1, members: 5 */
	/* last cacheline: 20 bytes */
};
struct sql_digest_state {
	int                        m_last_id_index;      /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	sql_digest_storage         m_digest_storage;     /*     8    72 */
	void reset(class sql_digest_state *, unsigned char *, uint);

	bool is_empty(class sql_digest_state *);

	void sql_digest_state(class sql_digest_state *);


	/* size: 80, cachelines: 2, members: 2 */
	/* sum members: 76, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct list_node {
	class list_node *          next;                 /*     0     8 */
	void *                     info;                 /*     8     8 */
	void list_node(class list_node *, void *, class list_node *);

	void list_node(class list_node *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class base_list {
protected:

	class list_node *          first;                /*     0     8 */
	class list_node * *        last;                 /*     8     8 */
public:

	uint                       elements;             /*    16     4 */
	bool operator==(const class base_list  *, const class base_list  &);

	void clear(class base_list *);

	void base_list(class base_list *);

	void base_list(class base_list *, const class base_list  &);

	class base_list & operator=(class base_list *, const class base_list  &);

	void base_list(class base_list *, const class base_list  &, class MEM_ROOT *);

	bool push_back(class base_list *, void *);

	bool push_back(class base_list *, void *, class MEM_ROOT *);

	bool push_front(class base_list *, void *);

	bool push_front(class base_list *, void *, class MEM_ROOT *);

	void remove(class base_list *, class list_node * *);

	void concat(class base_list *, class base_list *);

	void * pop(class base_list *);

	void disjoin(class base_list *, class base_list *);

	void prepend(class base_list *, class base_list *);

	void swap(class base_list *, class base_list &);

	class list_node * last_node(class base_list *);

	class list_node * first_node(class base_list *);

	void * head(class base_list *);

	const void  * head(const class base_list  *);

	void * * head_ref(class base_list *);

	bool is_empty(const class base_list  *);

	class list_node * last_ref(class base_list *);

	uint size(const class base_list  *);

protected:

	void after(class base_list *, void *, class list_node *);

	bool after(class base_list *, void *, class list_node *, class MEM_ROOT *);


	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
class base_list_iterator {
protected:

	class base_list *          list;                 /*     0     8 */
	class list_node * *        el;                   /*     8     8 */
	class list_node * *        prev;                 /*    16     8 */
	class list_node *          current;              /*    24     8 */
	void sublist(class base_list_iterator *, class base_list &, uint);

public:

	void base_list_iterator(class base_list_iterator *);

	void base_list_iterator(class base_list_iterator *, class base_list &);

	void init(class base_list_iterator *, class base_list &);

	void * next(class base_list_iterator *);

	void * next_fast(class base_list_iterator *);

	void rewind(class base_list_iterator *);

	void * replace(class base_list_iterator *, void *);

	void * replace(class base_list_iterator *, class base_list &);

	void remove(class base_list_iterator *);

	void after(class base_list_iterator *, void *);

	bool after(class base_list_iterator *, void *, class MEM_ROOT *);

	void * * ref(class base_list_iterator *);

	bool is_last(class base_list_iterator *);

	bool is_before_first(const class base_list_iterator  *);

	bool prepend(class base_list_iterator *, void *, class MEM_ROOT *);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class ilink<i_string> {
	class i_string * *         prev;                 /*     0     8 */
	class i_string *           next;                 /*     8     8 */
public:

	void ilink(class ilink<i_string> *);

	void unlink(class ilink<i_string> *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class i_string : public ilink<i_string> {
public:

	/* class ilink<i_string>     <ancestor>; */      /*     0    16 */
	const char  *              ptr;                  /*    16     8 */
	void i_string(class i_string *);

	void i_string(class i_string *, const char  *);


	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class Sql_condition {
	enum enum_severity_level {
		SL_NOTE      = 0,
		SL_WARNING   = 1,
		SL_ERROR     = 2,
		SEVERITY_END = 3,
	};

public:

	const char  * message_text(const class Sql_condition  *);

	size_t message_octet_length(const class Sql_condition  *);

	const char  * returned_sqlstate(const class Sql_condition  *);

	uint mysql_errno(const class Sql_condition  *);

	enum enum_severity_level severity(const class Sql_condition  *);

	void Sql_condition(class Sql_condition *, class MEM_ROOT *);

	void Sql_condition(class Sql_condition *, class MEM_ROOT *, uint, const char  *, enum enum_severity_level, const char  *);

	void ~Sql_condition(class Sql_condition *, int);

	void copy_opt_attributes(class Sql_condition *, const class Sql_condition  *);

	void set_message_text(class Sql_condition *, const char  *);

	void set_returned_sqlstate(class Sql_condition *, const char  *);

	void set_class_origins(class Sql_condition *);

	class String              m_class_origin;        /*     0    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_subclass_origin;     /*    32    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) --- */
	class String              m_constraint_catalog;  /*    64    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_constraint_schema;   /*    96    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) --- */
	class String              m_constraint_name;     /*   128    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_catalog_name;        /*   160    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 3 boundary (192 bytes) --- */
	class String              m_schema_name;         /*   192    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_table_name;          /*   224    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 4 boundary (256 bytes) --- */
	class String              m_column_name;         /*   256    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_cursor_name;         /*   288    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 5 boundary (320 bytes) --- */
	class String              m_message_text;        /*   320    32 */

	/* XXX last struct has 3 bytes of padding */

	uint                       m_mysql_errno;        /*   352     4 */
	char                       m_returned_sqlstate[6]; /*   356     6 */

	/* XXX 2 bytes hole, try to pack */

	enum enum_severity_level   m_severity_level;     /*   364     4 */
	class Sql_condition *      m_next_condition;     /*   368     8 */
	class Sql_condition * *    m_prev_condition;     /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	class MEM_ROOT *           m_mem_root;           /*   384     8 */

	/* size: 392, cachelines: 7, members: 17 */
	/* sum members: 390, holes: 1, sum holes: 2 */
	/* paddings: 11, sum paddings: 33 */
	/* last cacheline: 8 bytes */
};
class ErrConvString {
	char                       err_buffer[512];      /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	size_t                     buf_length;           /*   512     8 */
public:

	void ErrConvString(class ErrConvString *, const class String  *);

	void ErrConvString(class ErrConvString *, const char  *, size_t);

	void ErrConvString(class ErrConvString *, const char  *, size_t, const class CHARSET_INFO  *);

	void ErrConvString(class ErrConvString *, longlong);

	void ErrConvString(class ErrConvString *, longlong, bool);

	void ErrConvString(class ErrConvString *, double);

	void ErrConvString(class ErrConvString *, const class my_decimal  *);

	void ErrConvString(class ErrConvString *, const class MYSQL_TIME  *, uint);

	const char  * ptr(const class ErrConvString  *);

	size_t length(const class ErrConvString  *);


	/* size: 520, cachelines: 9, members: 2 */
	/* last cacheline: 8 bytes */
};
class my_decimal : public decimal_t {
public:

	/* struct decimal_t           <ancestor>; */     /*     0    24 */
	decimal_digit_t            buffer[9];            /*    24    36 */
	void my_decimal(class my_decimal *, const class my_decimal  &);

	class my_decimal & operator=(class my_decimal *, const class my_decimal  &);

	void init(class my_decimal *);

	void my_decimal(class my_decimal *);

	void sanity_check(const class my_decimal  *);

	bool sign(const class my_decimal  *);

	void sign(class my_decimal *, bool);

	uint precision(const class my_decimal  *);

	void swap(class my_decimal *, class my_decimal &);

	int check_result(const class my_decimal  *, uint, int);


	/* size: 64, cachelines: 1, members: 2 */
	/* padding: 4 */

	/* BRAIN FART ALERT! 64 bytes != 36 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct MYSQL_TIME {
	unsigned int               year;                 /*     0     4 */
	unsigned int               month;                /*     4     4 */
	unsigned int               day;                  /*     8     4 */
	unsigned int               hour;                 /*    12     4 */
	unsigned int               minute;               /*    16     4 */
	unsigned int               second;               /*    20     4 */
	long unsigned int          second_part;          /*    24     8 */
	bool                       neg;                  /*    32     1 */

	/* XXX 3 bytes hole, try to pack */

	enum enum_mysql_timestamp_type time_type;        /*    36     4 */
	int                        time_zone_displacement; /*    40     4 */

	/* size: 48, cachelines: 1, members: 10 */
	/* sum members: 41, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
class I_P_List_fast_push_back<Sql_condition> {
	class Sql_condition * *    m_last;               /*     0     8 */
protected:

	void I_P_List_fast_push_back(class I_P_List_fast_push_back<Sql_condition> *, class Sql_condition * *);

	void set_last(class I_P_List_fast_push_back<Sql_condition> *, class Sql_condition * *);

	class Sql_condition * * get_last(const class I_P_List_fast_push_back<Sql_condition>  *);

	void swap(class I_P_List_fast_push_back<Sql_condition> *, class I_P_List_fast_push_back<Sql_condition> &);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > : public I_P_List_counter, public I_P_List_fast_push_back<Sql_condition> {
public:

	/* class I_P_List_counter    <ancestor>; */      /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	/* class I_P_List_fast_push_back<Sql_condition> <ancestor>; */ /*     8     8 */
	class Sql_condition *      m_first;              /*    16     8 */
	void I_P_List(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	void clear(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	bool is_empty(const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	void push_front(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *);

	void push_back(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *);

	void insert_after(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *, class Sql_condition *);

	void remove(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *);

	class Sql_condition * front(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	const class Sql_condition  * front(const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	class Sql_condition * pop_front(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	void swap(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	typedef struct I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > > Const_Iterator;


	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 8, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 8 (member bytes) + 0 (member bits) + 4 (byte holes) + 0 (bit holes), diff = 96 bits */
};
struct I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition> {
	class Sql_condition * * next_ptr(class Sql_condition *);

	const class Sql_condition  * const * next_ptr(const class Sql_condition  *);

	class Sql_condition * * * prev_ptr(class Sql_condition *);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > > {
	const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co list; /*     0     8 */
	const class Sql_condition  * current;            /*     8     8 */
public:

	void I_P_List_iterator(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	void I_P_List_iterator(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co, const class Sql_condition  *);

	void init(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	const class Sql_condition  * operator++(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, int);

	const class Sql_condition  * operator++(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con);

	void rewind(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Diagnostics_area {
	enum enum_diagnostics_status {
		DA_EMPTY    = 0,
		DA_OK       = 1,
		DA_EOF      = 2,
		DA_ERROR    = 3,
		DA_DISABLED = 4,
	};

public:

	void Diagnostics_area(class Diagnostics_area *, bool);

	void ~Diagnostics_area(class Diagnostics_area *, int);

	void set_overwrite_status(class Diagnostics_area *, bool);

	bool is_sent(const class Diagnostics_area  *);

	void set_is_sent(class Diagnostics_area *, bool);

	void set_ok_status(class Diagnostics_area *, ulonglong, ulonglong, const char  *);

	void set_eof_status(class Diagnostics_area *, class THD *);

	void set_error_status(class Diagnostics_area *, class THD *, uint);

	void set_error_status(class Diagnostics_area *, uint, const char  *, const char  *);

	void disable_status(class Diagnostics_area *);

	void reset_diagnostics_area(class Diagnostics_area *);

	bool is_set(const class Diagnostics_area  *);

	bool is_error(const class Diagnostics_area  *);

	bool is_eof(const class Diagnostics_area  *);

	bool is_ok(const class Diagnostics_area  *);

	bool is_disabled(const class Diagnostics_area  *);

	enum enum_diagnostics_status status(const class Diagnostics_area  *);

	const char  * message_text(const class Diagnostics_area  *);

	uint mysql_errno(const class Diagnostics_area  *);

	const char  * returned_sqlstate(const class Diagnostics_area  *);

	ulonglong affected_rows(const class Diagnostics_area  *);

	ulonglong last_insert_id(const class Diagnostics_area  *);

	uint last_statement_cond_count(const class Diagnostics_area  *);

	ulong current_statement_cond_count(const class Diagnostics_area  *);

	void reset_statement_cond_count(class Diagnostics_area *);

	bool has_sql_condition(const class Diagnostics_area  *, const char  *, size_t);

	bool has_sql_condition(const class Diagnostics_area  *, uint);

	void reset_condition_info(class Diagnostics_area *, class THD *);

	ulong current_row_for_condition(const class Diagnostics_area  *);

	void inc_current_row_for_condition(class Diagnostics_area *);

	void set_current_row_for_condition(class Diagnostics_area *, ulong);

	void reset_current_row_for_condition(class Diagnostics_area *);

	ulong error_count(const class Diagnostics_area  *, class THD *);

	ulong warn_count(const class Diagnostics_area  *, class THD *);

	uint cond_count(const class Diagnostics_area  *);

	typedef Const_Iterator Sql_condition_iterator;

	Sql_condition_iterator sql_conditions(const class Diagnostics_area  *);

	const char  * get_first_condition_message(class Diagnostics_area *);

	void reserve_number_of_conditions(class Diagnostics_area *, class THD *, uint);

	class Sql_condition * push_warning(class Diagnostics_area *, class THD *, uint, const char  *, enum enum_severity_level, const char  *);

	void mark_preexisting_sql_conditions(class Diagnostics_area *);

	void copy_new_sql_conditions(class Diagnostics_area *, class THD *, const class Diagnostics_area  *);

	void copy_sql_conditions_from_da(class Diagnostics_area *, class THD *, const class Diagnostics_area  *);

	void copy_non_errors_from_da(class Diagnostics_area *, class THD *, const class Diagnostics_area  *);

	class Sql_condition * error_condition(const class Diagnostics_area  *);

	class Sql_condition * push_warning(class Diagnostics_area *, class THD *, const class Sql_condition  *);

	void push_diagnostics_area(class Diagnostics_area *, class THD *, class Diagnostics_area *, bool);

	class Diagnostics_area * pop_diagnostics_area(class Diagnostics_area *);

	const class Diagnostics_area  * stacked_da(const class Diagnostics_area  *);

	class Diagnostics_area *   m_stacked_da;         /*     0     8 */
	struct MEM_ROOT            m_condition_root;     /*     8    80 */

	/* XXX last struct has 4 bytes of padding */
	typedef struct I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > Sql_condition_list;


	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	Sql_condition_list         m_conditions_list;    /*    88    24 */
	class List<const Sql_condition> m_preexisting_sql_conditions; /*   112    24 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	bool                       m_is_sent;            /*   136     1 */
	bool                       m_can_overwrite_status; /*   137     1 */
	bool                       m_allow_unlimited_conditions; /*   138     1 */

	/* XXX 1 byte hole, try to pack */

	enum enum_diagnostics_status m_status;           /*   140     4 */
	char                       m_message_text[512];  /*   144   512 */
	/* --- cacheline 10 boundary (640 bytes) was 16 bytes ago --- */
	char                       m_returned_sqlstate[6]; /*   656     6 */

	/* XXX 2 bytes hole, try to pack */

	uint                       m_mysql_errno;        /*   664     4 */

	/* XXX 4 bytes hole, try to pack */

	ulonglong                  m_affected_rows;      /*   672     8 */
	ulonglong                  m_last_insert_id;     /*   680     8 */
	uint                       m_last_statement_cond_count; /*   688     4 */
	uint                       m_current_statement_cond_count; /*   692     4 */
	uint                       m_current_statement_cond_count_by_qb[3]; /*   696    12 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 11 boundary (704 bytes) was 8 bytes ago --- */
	ulong                      m_current_row_for_condition; /*   712     8 */
	ulong                      m_saved_error_count;  /*   720     8 */
	ulong                      m_saved_warn_count;   /*   728     8 */

	/* size: 736, cachelines: 12, members: 19 */
	/* sum members: 725, holes: 4, sum holes: 11 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 32 bytes */
};
class List<const Sql_condition> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<const Sql_condition> *);

	void List(class List<const Sql_condition> *, const class List<const Sql_condition>  &);

	class List<const Sql_condition> & operator=(class List<const Sql_condition> *, const class List<const Sql_condition>  &);

	void List(class List<const Sql_condition> *, const class List<const Sql_condition>  &, class MEM_ROOT *);

	bool push_back(class List<const Sql_condition> *, const class Sql_condition  *);

	bool push_back(class List<const Sql_condition> *, const class Sql_condition  *, class MEM_ROOT *);

	bool push_front(class List<const Sql_condition> *, const class Sql_condition  *);

	bool push_front(class List<const Sql_condition> *, const class Sql_condition  *, class MEM_ROOT *);

	const class Sql_condition  * head(class List<const Sql_condition> *);

	const class Sql_condition  * head(const class List<const Sql_condition>  *);

	const class Sql_condition  * * head_ref(class List<const Sql_condition> *);

	const class Sql_condition  * pop(class List<const Sql_condition> *);

	void concat(class List<const Sql_condition> *, class List<const Sql_condition> *);

	void disjoin(class List<const Sql_condition> *, class List<const Sql_condition> *);

	void prepend(class List<const Sql_condition> *, class List<const Sql_condition> *);

	void delete_elements(class List<const Sql_condition> *);

	void destroy_elements(class List<const Sql_condition> *);

	const class Sql_condition  * operator[](const class List<const Sql_condition>  *, uint);

	void replace(class List<const Sql_condition> *, uint, const class Sql_condition  *);

	bool swap_elts(class List<const Sql_condition> *, uint, uint);

	typedef struct List_STL_Iterator<const Sql_condition> iterator;

	iterator begin(class List<const Sql_condition> *);

	iterator end(class List<const Sql_condition> *);

	typedef struct List_STL_Iterator<const Sql_condition> const_iterator;

	const_iterator begin(const class List<const Sql_condition>  *);

	const_iterator end(const class List<const Sql_condition>  *);

	const_iterator cbegin(const class List<const Sql_condition>  *);

	const_iterator cend(const class List<const Sql_condition>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<char** const, std::unique_ptr<char, My_free_deleter> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > >  *, reference);

	typedef class pair<char** const, std::unique_ptr<char, My_free_deleter> > & reference;

	typedef const class pair<char** const, std::unique_ptr<char, My_free_deleter> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > >  *, const_reference);

	typedef const class pair<char** const, std::unique_ptr<char, My_free_deleter> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > >  *);

	void Malloc_allocator<void*>(class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > *, const class Malloc_allocator<void*>  &);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false>, reference);

	typedef class _Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> & reference;

	typedef const class _Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false>, const_reference);

	typedef const class _Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false>);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false>);

	typedef struct _Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> value_type;

	struct rebind<std::__detail::_Hash_node_base*> {
		typedef struct Malloc_allocator<std::__detail::_Hash_node_base*> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	void Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > >(class Malloc_allocator<std::__detail::_Hash_node<std::pair<char** const, std::unique_ptr<char, My_free_deleter> >, false> > *, const class Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > >  &);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class malloc_unordered_map<char**, std::unique_ptr<char, My_free_deleter>, std::hash<char**>, std::equal_to<char**> > : public unordered_map<char**, std::unique_ptr<char, My_free_deleter>, std::hash<char**>, std::equal_to<char**>, Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > > {
public:

	/* class unordered_map<char**, std::unique_ptr<char, My_free_deleter>, std::hash<char**>, std::equal_to<char**>, Malloc_allocator<std::pair<char** const, std::unique_ptr<char, My_free_deleter> > > > <ancestor>; */ /*     0    64 */
	void malloc_unordered_map(class malloc_unordered_map<char**, std::unique_ptr<char, My_free_deleter>, std::hash<char**>, std::equal_to<char**> > *, PSI_memory_key);

	void ~malloc_unordered_map(class malloc_unordered_map<char**, std::unique_ptr<char, My_free_deleter>, std::hash<char**>, std::equal_to<char**> > *, int);


	/* size: 64, cachelines: 1, members: 1 */

	/* BRAIN FART ALERT! 64 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 512 bits */
};
class Session_sysvar_resource_manager {
	class malloc_unordered_map<char**, std::unique_ptr<char, My_free_deleter>, std::hash<char**>, std::equal_to<char**> > m_sysvar_string_alloc_hash; /*     0    64 */
public:

	bool init(class Session_sysvar_resource_manager *, char * *);

	bool update(class Session_sysvar_resource_manager *, char * *, char *, size_t);

	void claim_memory_ownership(class Session_sysvar_resource_manager *, bool);

	void deinit(class Session_sysvar_resource_manager *);

	void ~Session_sysvar_resource_manager(class Session_sysvar_resource_manager *, int);

	void Session_sysvar_resource_manager(class Session_sysvar_resource_manager *);


	/* size: 64, cachelines: 1, members: 1 */
};
struct Transaction_termination_ctx {
	long unsigned int          m_thread_id;          /*     0     8 */
	unsigned int               m_flags;              /*     8     4 */
	bool                       m_rollback_transaction; /*    12     1 */
	bool                       m_generated_gtid;     /*    13     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        m_sidno;              /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    m_gno;                /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* sum members: 26, holes: 2, sum holes: 6 */
	/* last cacheline: 32 bytes */
};
struct rpl_transaction_ctx_service_st {
	int                        (*set_transaction_ctx)(class Transaction_termination_ctx); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct xid_t {
private:

	long int                   formatID;             /*     0     8 */
	long int                   gtrid_length;         /*     8     8 */
	long int                   bqual_length;         /*    16     8 */
	char                       data[128];            /*    24   128 */
	void xid_t(class xid_t *);

	long int get_format_id(const class xid_t  *);

	void set_format_id(class xid_t *, long int);

	long int get_gtrid_length(const class xid_t  *);

	void set_gtrid_length(class xid_t *, long int);

	long int get_bqual_length(const class xid_t  *);

	void set_bqual_length(class xid_t *, long int);

	const char  * get_data(const class xid_t  *);

	void set_data(class xid_t *, const void  *, long int);

	void reset(class xid_t *);

	void set(class xid_t *, long int, const char  *, long int, const char  *, long int);

	my_xid get_my_xid(const class xid_t  *);

	uchar * key(class xid_t *);

	const uchar  * key(const class xid_t  *);

	uint key_length(const class xid_t  *);


	/* Bitfield combined with previous fields */

	static const uint                 ser_buf_size = 297; /*     0     0 */
	char * serialize(const class xid_t  *, char *);

	bool eq(const class xid_t  *, const class xid_t  *);

	bool is_null(const class xid_t  *);

	void set(class xid_t *, const class xid_t  *);

	void set(class xid_t *, my_xid);

	void null(class xid_t *);


	/* size: 152, cachelines: 3, members: 4, static members: 1 */
	/* last cacheline: 24 bytes */
};
struct st_xarecover_txn {
	XID                        id;                   /*     0   152 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	class List<st_handler_tablename> * mod_tables;   /*   152     8 */

	/* size: 160, cachelines: 3, members: 2 */
	/* last cacheline: 32 bytes */
};
class XID_STATE {
	enum xa_states {
		XA_NOTR          = 0,
		XA_ACTIVE        = 1,
		XA_IDLE          = 2,
		XA_PREPARED      = 3,
		XA_ROLLBACK_ONLY = 4,
	};

	static const char  *              xa_state_names[0]; /*     0     0 */
	XID                        m_xid;                /*     0   152 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	class mutex               m_xa_lock;             /*   152    40 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	enum xa_states             xa_state;             /*   192     4 */
	bool                       in_recovery;          /*   196     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       rm_error;             /*   200     4 */
	bool                       m_is_binlogged;       /*   204     1 */
public:

	void XID_STATE(class XID_STATE *);

	class mutex & get_xa_lock(class XID_STATE *);

	void set_state(class XID_STATE *, enum xa_states);

	enum xa_states get_state(class XID_STATE *);

	bool has_state(const class XID_STATE  *, enum xa_states);

	const char  * state_name(const class XID_STATE  *);

	const XID  * get_xid(const class XID_STATE  *);

	XID * get_xid(class XID_STATE *);

	bool has_same_xid(const class XID_STATE  *, const XID  *);

	void set_query_id(class XID_STATE *, query_id_t);

	void set_error(class XID_STATE *, class THD *);

	void reset_error(class XID_STATE *);

	void cleanup(class XID_STATE *);

	void reset(class XID_STATE *);

	void start_normal_xa(class XID_STATE *, const XID  *);

	void start_recovery_xa(class XID_STATE *, const XID  *, bool);

	bool is_in_recovery(const class XID_STATE  *);

	bool is_binlogged(const class XID_STATE  *);

	void set_binlogged(class XID_STATE *);

	void unset_binlogged(class XID_STATE *);

	void store_xid_info(const class XID_STATE  *, class Protocol *, bool);

	bool xa_trans_rolled_back(class XID_STATE *);

	bool check_xa_idle_or_prepared(const class XID_STATE  *, bool);

	bool check_has_uncommitted_xa(const class XID_STATE  *);

	bool check_in_xa(const class XID_STATE  *, bool);


	/* size: 208, cachelines: 4, members: 6, static members: 1 */
	/* sum members: 202, holes: 1, sum holes: 3 */
	/* padding: 3 */
	/* last cacheline: 16 bytes */
};
class Protocol {
	enum enum_protocol_type {
		PROTOCOL_TEXT   = 0,
		PROTOCOL_BINARY = 1,
		PROTOCOL_LOCAL  = 2,
		PROTOCOL_ERROR  = 3,
		PROTOCOL_PLUGIN = 4,
	};

	enum {
		SEND_NUM_ROWS = 1,
		SEND_DEFAULTS = 2,
		SEND_EOF      = 4,
	};

public:

	void Protocol(class Protocol *, const class Protocol  &);

	void Protocol(class Protocol *);

	int ()(void) * *           _vptr.Protocol;       /*     0     8 */
	class Protocol *           m_previous_protocol;  /*     8     8 */
	virtual void ~Protocol(class Protocol *, int);

	class Protocol * pop_protocol(class Protocol *);

	void push_protocol(class Protocol *, class Protocol *);

	virtual int read_packet(class Protocol *);

	virtual int get_command(class Protocol *, union COM_DATA *, enum enum_server_command *);

	virtual enum enum_protocol_type type(const class Protocol  *);

	virtual enum enum_vio_type connection_type(const class Protocol  *);

	virtual bool store_null(class Protocol *);

	virtual bool store_tiny(class Protocol *, longlong, uint32);

	virtual bool store_short(class Protocol *, longlong, uint32);

	virtual bool store_long(class Protocol *, longlong, uint32);

	virtual bool store_longlong(class Protocol *, longlong, bool, uint32);

	virtual bool store_decimal(class Protocol *, const class my_decimal  *, uint, uint);

	virtual bool store_string(class Protocol *, const char  *, size_t, const class CHARSET_INFO  *);

	virtual bool store_float(class Protocol *, float, uint32, uint32);

	virtual bool store_double(class Protocol *, double, uint32, uint32);

	virtual bool store_datetime(class Protocol *, const MYSQL_TIME  &, uint);

	virtual bool store_date(class Protocol *, const MYSQL_TIME  &);

	virtual bool store_time(class Protocol *, const MYSQL_TIME  &, uint);

	virtual bool store_field(class Protocol *, const class Field  *);

	bool store(class Protocol *, int);

	bool store(class Protocol *, uint32);

	bool store(class Protocol *, longlong);

	bool store(class Protocol *, ulonglong);

	bool store_tiny(class Protocol *, longlong);

	bool store_short(class Protocol *, longlong);

	bool store_long(class Protocol *, longlong);

	bool store_longlong(class Protocol *, longlong, bool);

	bool store(class Protocol *, const char  *, const class CHARSET_INFO  *);

	bool store(class Protocol *, class String *);

	bool store(class Protocol *, const LEX_STRING  &, const class CHARSET_INFO  *);

	virtual ulong get_client_capabilities(class Protocol *);

	virtual bool has_client_capability(class Protocol *, long unsigned int);

	virtual bool connection_alive(const class Protocol  *);

	virtual void start_row(class Protocol *);

	virtual bool end_row(class Protocol *);

	virtual void abort_row(class Protocol *);

	virtual void end_partial_result_set(class Protocol *);

	virtual int shutdown(class Protocol *, bool);

	virtual uint get_rw_status(class Protocol *);

	virtual bool get_compression(class Protocol *);

	virtual char * get_compression_algorithm(class Protocol *);

	virtual uint get_compression_level(class Protocol *);

	virtual bool start_result_metadata(class Protocol *, uint, uint, const class CHARSET_INFO  *);

	virtual bool send_field_metadata(class Protocol *, class Send_field *, const class CHARSET_INFO  *);

	virtual bool end_result_metadata(class Protocol *);

	virtual bool send_ok(class Protocol *, uint, uint, ulonglong, ulonglong, const char  *);

	virtual bool send_eof(class Protocol *, uint, uint);

	virtual bool send_error(class Protocol *, uint, const char  *, const char  *);

	virtual bool flush(class Protocol *);

	virtual bool store_ps_status(class Protocol *, ulong, uint, uint, ulong);

	virtual bool send_parameters(class Protocol *, class List<Item_param> *, bool);

	/* vtable has 38 entries: {
	   [2] = read_packet((null)), 
	   [3] = get_command((null)), 
	   [4] = type((null)), 
	   [5] = connection_type((null)), 
	   [6] = store_null((null)), 
	   [7] = store_tiny((null)), 
	   [8] = store_short((null)), 
	   [9] = store_long((null)), 
	   [10] = store_longlong((null)), 
	   [11] = store_decimal((null)), 
	   [12] = store_string((null)), 
	   [13] = store_float((null)), 
	   [14] = store_double((null)), 
	   [15] = store_datetime((null)), 
	   [16] = store_date((null)), 
	   [17] = store_time((null)), 
	   [18] = store_field((null)), 
	   [19] = get_client_capabilities((null)), 
	   [20] = has_client_capability((null)), 
	   [21] = connection_alive((null)), 
	   [22] = start_row((null)), 
	   [23] = end_row((null)), 
	   [24] = abort_row((null)), 
	   [25] = end_partial_result_set((null)), 
	   [26] = shutdown((null)), 
	   [27] = get_rw_status((null)), 
	   [28] = get_compression((null)), 
	   [29] = get_compression_algorithm((null)), 
	   [30] = get_compression_level((null)), 
	   [31] = start_result_metadata((null)), 
	   [32] = send_field_metadata((null)), 
	   [33] = end_result_metadata((null)), 
	   [34] = send_ok((null)), 
	   [35] = send_eof((null)), 
	   [36] = send_error((null)), 
	   [37] = flush((null)), 
	   [38] = store_ps_status((null)), 
	   [39] = send_parameters((null)), 
	} */
	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SAVEPOINT {
	class SAVEPOINT *          prev;                 /*     0     8 */
	char *                     name;                 /*     8     8 */
	size_t                     length;               /*    16     8 */
	class Ha_trx_info *        ha_list;              /*    24     8 */
	class MDL_savepoint       mdl_savepoint;         /*    32    16 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
class Ha_trx_info {
public:

	void register_ha(class Ha_trx_info *, class THD_TRANS *, class handlerton *);

	void reset(class Ha_trx_info *);

	void Ha_trx_info(class Ha_trx_info *);

	void set_trx_read_write(class Ha_trx_info *);

	bool is_trx_read_write(const class Ha_trx_info  *);

	bool is_started(const class Ha_trx_info  *);

	void coalesce_trx_with(class Ha_trx_info *, const class Ha_trx_info  *);

	class Ha_trx_info * next(const class Ha_trx_info  *);

	class handlerton * ht(const class Ha_trx_info  *);

	class Ha_trx_info *        m_next;               /*     0     8 */
	class handlerton *         m_ht;                 /*     8     8 */
	uchar                      m_flags;              /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
class Transaction_ctx {
	enum enum_trx_scope {
		STMT    = 0,
		SESSION = 1,
	};

	struct THD_TRANS {
		bool                       m_no_2pc;             /*     0     1 */

		/* XXX 3 bytes hole, try to pack */

		int                        m_rw_ha_count;        /*     4     4 */
		class Ha_trx_info *        m_ha_list;            /*     8     8 */
	private:

		unsigned int               m_unsafe_rollback_flags; /*    16     4 */

		/* Bitfield combined with previous fields */

		static const unsigned int         MODIFIED_NON_TRANS_TABLE = 1; /*     0     0 */
		static const unsigned int         CREATED_TEMP_TABLE = 2; /*     0     0 */
		static const unsigned int         DROPPED_TEMP_TABLE = 4; /*     0     0 */
		bool cannot_safely_rollback(const class THD_TRANS  *);

		unsigned int get_unsafe_rollback_flags(const class THD_TRANS  *);

		void set_unsafe_rollback_flags(class THD_TRANS *, unsigned int);

		void add_unsafe_rollback_flags(class THD_TRANS *, unsigned int);

		void reset_unsafe_rollback_flags(class THD_TRANS *);

		void mark_modified_non_trans_table(class THD_TRANS *);

		bool has_modified_non_trans_table(const class THD_TRANS  *);

		void mark_created_temp_table(class THD_TRANS *);

		bool has_created_temp_table(const class THD_TRANS  *);

		void mark_dropped_temp_table(class THD_TRANS *);

		bool has_dropped_temp_table(const class THD_TRANS  *);

		void reset(class THD_TRANS *);

		bool is_empty(const class THD_TRANS  *);


		/* size: 24, cachelines: 1, members: 4, static members: 3 */
		/* sum members: 17, holes: 1, sum holes: 3 */
		/* padding: 4 */
		/* last cacheline: 24 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	struct {
		bool                       enabled;              /*     0     1 */
		bool                       xid_written;          /*     1     1 */
		bool                       real_commit;          /*     2     1 */
		bool                       commit_low;           /*     3     1 */
		bool                       run_hooks;            /*     4     1 */

		/* size: 5, cachelines: 1, members: 5 */
		/* last cacheline: 5 bytes */
	};

public:

	void Transaction_ctx(class Transaction_ctx *, const class Transaction_ctx  &);

	int ()(void) * *           _vptr.Transaction_ctx; /*     0     8 */
	class SAVEPOINT *          m_savepoints;         /*     8     8 */
	void register_ha(class Transaction_ctx *, enum enum_trx_scope, class Ha_trx_info *, class handlerton *);

	struct THD_TRANS           m_scope_info[2];      /*    16    48 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class XID_STATE           m_xid_state;           /*    64   208 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	struct MEM_ROOT            m_mem_root;           /*   272    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 5 boundary (320 bytes) was 32 bytes ago --- */
	struct {
		bool               enabled;              /*   352     1 */
		bool               xid_written;          /*   353     1 */
		bool               real_commit;          /*   354     1 */
		bool               commit_low;           /*   355     1 */
		bool               run_hooks;            /*   356     1 */
	} m_flags;                                       /*   352     5 */

	/* XXX 3 bytes hole, try to pack */

	int64                      last_committed;       /*   360     8 */
	int64                      sequence_number;      /*   368     8 */
	void store_commit_parent(class Transaction_ctx *, int64);

	void Transaction_ctx(class Transaction_ctx *);

	virtual void ~Transaction_ctx(class Transaction_ctx *, int);

	void cleanup(class Transaction_ctx *);

	bool is_active(const class Transaction_ctx  *, enum enum_trx_scope);

	void push_unsafe_rollback_warnings(class Transaction_ctx *, class THD *);

	void merge_unsafe_rollback_flags(class Transaction_ctx *);

	void init_mem_root_defaults(class Transaction_ctx *, ulong, ulong);

	class MEM_ROOT * transaction_memroot(class Transaction_ctx *);

	void * allocate_memory(class Transaction_ctx *, unsigned int);

	void claim_memory_ownership(class Transaction_ctx *, bool);

	void free_memory(class Transaction_ctx *, myf);

	char * strmake(class Transaction_ctx *, const char  *, size_t);

	void invalidate_changed_tables_in_cache(class Transaction_ctx *, class THD *);

	void add_changed_table(class Transaction_ctx *, const char  *, uint32);

	class Ha_trx_info * ha_trx_info(class Transaction_ctx *, enum enum_trx_scope);

	const class Ha_trx_info  * ha_trx_info(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_ha_trx_info(class Transaction_ctx *, enum enum_trx_scope, class Ha_trx_info *);

	class XID_STATE * xid_state(class Transaction_ctx *);

	const class XID_STATE  * xid_state(const class Transaction_ctx  *);

	bool cannot_safely_rollback(const class Transaction_ctx  *, enum enum_trx_scope);

	unsigned int get_unsafe_rollback_flags(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_unsafe_rollback_flags(class Transaction_ctx *, enum enum_trx_scope, unsigned int);

	void add_unsafe_rollback_flags(class Transaction_ctx *, enum enum_trx_scope, unsigned int);

	void reset_unsafe_rollback_flags(class Transaction_ctx *, enum enum_trx_scope);

	void mark_modified_non_trans_table(class Transaction_ctx *, enum enum_trx_scope);

	bool has_modified_non_trans_table(const class Transaction_ctx  *, enum enum_trx_scope);

	void mark_created_temp_table(class Transaction_ctx *, enum enum_trx_scope);

	bool has_created_temp_table(const class Transaction_ctx  *, enum enum_trx_scope);

	void mark_dropped_temp_table(class Transaction_ctx *, enum enum_trx_scope);

	bool has_dropped_temp_table(const class Transaction_ctx  *, enum enum_trx_scope);

	void reset(class Transaction_ctx *, enum enum_trx_scope);

	bool is_empty(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_no_2pc(class Transaction_ctx *, enum enum_trx_scope, bool);

	bool no_2pc(const class Transaction_ctx  *, enum enum_trx_scope);

	int rw_ha_count(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_rw_ha_count(class Transaction_ctx *, enum enum_trx_scope, int);

	void reset_scope(class Transaction_ctx *, enum enum_trx_scope);

	class Rpl_transaction_ctx * get_rpl_transaction_ctx(class Transaction_ctx *);

	const class Rpl_transaction_ctx  * get_rpl_transaction_ctx(const class Transaction_ctx  *);

	class Rpl_transaction_write_set_ctx * get_transaction_write_set_ctx(class Transaction_ctx *);

	const class Rpl_transaction_write_set_ctx  * get_transaction_write_set_ctx(const class Transaction_ctx  *);

	bool was_trans_begin_hook_invoked(class Transaction_ctx *);

	void set_trans_begin_hook_invoked(class Transaction_ctx *);

	class Rpl_transaction_ctx m_rpl_transaction_ctx; /*   376    40 */
	/* --- cacheline 6 boundary (384 bytes) was 32 bytes ago --- */
	class Rpl_transaction_write_set_ctx m_transaction_write_set_ctx; /*   416   120 */

	/* XXX last struct has 5 bytes of padding */

	/* --- cacheline 8 boundary (512 bytes) was 24 bytes ago --- */
	bool                       trans_begin_hook_invoked; /*   536     1 */

	/* size: 544, cachelines: 9, members: 11 */
	/* sum members: 534, holes: 1, sum holes: 3 */
	/* padding: 7 */
	/* paddings: 3, sum paddings: 12 */
	/* last cacheline: 32 bytes */
};
struct handlerton {
	enum SHOW_COMP_OPTION      state;                /*     0     4 */
	enum legacy_db_type        db_type;              /*     4     4 */
	uint                       slot;                 /*     8     4 */
	uint                       savepoint_offset;     /*    12     4 */
	close_connection_t         close_connection;     /*    16     8 */
	kill_connection_t          kill_connection;      /*    24     8 */
	pre_dd_shutdown_t          pre_dd_shutdown;      /*    32     8 */
	savepoint_set_t            savepoint_set;        /*    40     8 */
	savepoint_rollback_t       savepoint_rollback;   /*    48     8 */
	savepoint_rollback_can_release_mdl_t savepoint_rollback_can_release_mdl; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	savepoint_release_t        savepoint_release;    /*    64     8 */
	commit_t                   commit;               /*    72     8 */
	rollback_t                 rollback;             /*    80     8 */
	prepare_t                  prepare;              /*    88     8 */
	recover_t                  recover;              /*    96     8 */
	commit_by_xid_t            commit_by_xid;        /*   104     8 */
	rollback_by_xid_t          rollback_by_xid;      /*   112     8 */
	create_t                   create;               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	drop_database_t            drop_database;        /*   128     8 */
	panic_t                    panic;                /*   136     8 */
	start_consistent_snapshot_t start_consistent_snapshot; /*   144     8 */
	clone_consistent_snapshot_t clone_consistent_snapshot; /*   152     8 */
	flush_logs_t               flush_logs;           /*   160     8 */
	store_binlog_info_t        store_binlog_info;    /*   168     8 */
	show_status_t              show_status;          /*   176     8 */
	partition_flags_t          partition_flags;      /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	is_valid_tablespace_name_t is_valid_tablespace_name; /*   192     8 */
	get_tablespace_t           get_tablespace;       /*   200     8 */
	alter_tablespace_t         alter_tablespace;     /*   208     8 */
	get_tablespace_filename_ext_t get_tablespace_filename_ext; /*   216     8 */
	flush_changed_page_bitmaps_t flush_changed_page_bitmaps; /*   224     8 */
	purge_changed_page_bitmaps_t purge_changed_page_bitmaps; /*   232     8 */
	upgrade_tablespace_t       upgrade_tablespace;   /*   240     8 */
	upgrade_space_version_t    upgrade_space_version; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	get_tablespace_type_t      get_tablespace_type;  /*   256     8 */
	get_tablespace_type_by_name_t get_tablespace_type_by_name; /*   264     8 */
	is_tablespace_keyring_pre_v3_encrypted_t is_tablespace_keyring_pre_v3_encrypted; /*   272     8 */
	upgrade_logs_t             upgrade_logs;         /*   280     8 */
	finish_upgrade_t           finish_upgrade;       /*   288     8 */
	fill_is_table_t            fill_is_table;        /*   296     8 */
	dict_init_t                dict_init;            /*   304     8 */
	ddse_dict_init_t           ddse_dict_init;       /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	dict_register_dd_table_id_t dict_register_dd_table_id; /*   320     8 */
	dict_cache_reset_t         dict_cache_reset;     /*   328     8 */
	dict_cache_reset_tables_and_tablespaces_t dict_cache_reset_tables_and_tablespaces; /*   336     8 */
	dict_recover_t             dict_recover;         /*   344     8 */
	dict_get_server_version_t  dict_get_server_version; /*   352     8 */
	dict_set_server_version_t  dict_set_server_version; /*   360     8 */
	is_reserved_db_name_t      is_reserved_db_name;  /*   368     8 */
	uint32                     flags;                /*   376     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 6 boundary (384 bytes) --- */
	binlog_func_t              binlog_func;          /*   384     8 */
	binlog_log_query_t         binlog_log_query;     /*   392     8 */
	acl_notify_t               acl_notify;           /*   400     8 */
	discover_t                 discover;             /*   408     8 */
	find_files_t               find_files;           /*   416     8 */
	table_exists_in_engine_t   table_exists_in_engine; /*   424     8 */
	is_supported_system_table_t is_supported_system_table; /*   432     8 */
	sdi_create_t               sdi_create;           /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	sdi_drop_t                 sdi_drop;             /*   448     8 */
	sdi_get_keys_t             sdi_get_keys;         /*   456     8 */
	sdi_get_t                  sdi_get;              /*   464     8 */
	sdi_set_t                  sdi_set;              /*   472     8 */
	sdi_delete_t               sdi_delete;           /*   480     8 */
	const char  * *            file_extensions;      /*   488     8 */
	is_dict_readonly_t         is_dict_readonly;     /*   496     8 */
	rm_tmp_tables_t            rm_tmp_tables;        /*   504     8 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	get_cost_constants_t       get_cost_constants;   /*   512     8 */
	replace_native_transaction_in_thd_t replace_native_transaction_in_thd; /*   520     8 */
	notify_exclusive_mdl_t     notify_exclusive_mdl; /*   528     8 */
	notify_alter_table_t       notify_alter_table;   /*   536     8 */
	rotate_encryption_master_key_t rotate_encryption_master_key; /*   544     8 */
	fix_tablespaces_empty_uuid_t fix_tablespaces_empty_uuid; /*   552     8 */
	fix_default_table_encryption_t fix_default_table_encryption; /*   560     8 */
	check_mk_keyring_exclusions_t check_mk_keyring_exclusions; /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	upgrade_get_compression_dict_data_t upgrade_get_compression_dict_data; /*   576     8 */
	redo_log_set_state_t       redo_log_set_state;   /*   584     8 */
	get_table_statistics_t     get_table_statistics; /*   592     8 */
	get_index_column_cardinality_t get_index_column_cardinality; /*   600     8 */
	get_tablespace_statistics_t get_tablespace_statistics; /*   608     8 */
	post_ddl_t                 post_ddl;             /*   616     8 */
	post_recover_t             post_recover;         /*   624     8 */
	struct Clone_interface_t   clone_interface;      /*   632    64 */
	/* --- cacheline 10 boundary (640 bytes) was 56 bytes ago --- */
	uint32                     license;              /*   696     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 11 boundary (704 bytes) --- */
	void *                     data;                 /*   704     8 */
	lock_hton_log_t            lock_hton_log;        /*   712     8 */
	unlock_hton_log_t          unlock_hton_log;      /*   720     8 */
	collect_hton_log_info_t    collect_hton_log_info; /*   728     8 */
	uint32                     foreign_keys_flags;   /*   736     4 */

	/* XXX 4 bytes hole, try to pack */

	check_fk_column_compat_t   check_fk_column_compat; /*   744     8 */
	LEX_CSTRING                fk_name_suffix;       /*   752    16 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	prepare_secondary_engine_t prepare_secondary_engine; /*   768     8 */
	optimize_secondary_engine_t optimize_secondary_engine; /*   776     8 */
	compare_secondary_engine_cost_t compare_secondary_engine_cost; /*   784     8 */
	SecondaryEngineFlags       secondary_engine_flags; /*   792     8 */
	secondary_engine_modify_access_path_cost_t secondary_engine_modify_access_path_cost; /*   800     8 */
	se_before_commit_t         se_before_commit;     /*   808     8 */
	se_after_commit_t          se_after_commit;      /*   816     8 */
	se_before_rollback_t       se_before_rollback;   /*   824     8 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	struct Page_track_t        page_track;           /*   832    48 */

	/* size: 880, cachelines: 14, members: 99 */
	/* sum members: 868, holes: 3, sum holes: 12 */
	/* last cacheline: 48 bytes */
};
struct in6_addr {
	union {
		uint8_t                    __u6_addr8[16];       /*     0    16 */
		uint16_t                   __u6_addr16[8];       /*     0    16 */
		uint32_t                   __u6_addr32[4];       /*     0    16 */
	};

	union {
		uint8_t            __u6_addr8[16];       /*     0    16 */
		uint16_t           __u6_addr16[8];       /*     0    16 */
		uint32_t           __u6_addr32[4];       /*     0    16 */
	} __in6_u;                                       /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct MYSQL_SOCKET {
	my_socket                  fd;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_socket *         m_psi;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct PSI_socket : PSI_instr {
	/* struct PSI_instr           <ancestor>; */     /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */

	/* BRAIN FART ALERT! 1 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 8 bits */
};
struct PSI_socket_info_v1 {
	PSI_socket_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	unsigned int               m_flags;              /*    16     4 */
	int                        m_volatility;         /*    20     4 */
	const char  *              m_documentation;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct PSI_socket_locker_state_v1 {
	unsigned int               m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_socket *         m_socket;             /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	size_t                     m_number_of_bytes;    /*    24     8 */
	long long unsigned int     m_timer_start;        /*    32     8 */
	long long unsigned int     (*m_timer)(void);     /*    40     8 */
	enum PSI_socket_operation  m_operation;          /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_src_file;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        m_src_line;           /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     m_wait;               /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* sum members: 68, holes: 3, sum holes: 12 */
	/* last cacheline: 16 bytes */
};
struct PSI_socket_service_v1 {
	register_socket_v1_t       register_socket;      /*     0     8 */
	init_socket_v1_t           init_socket;          /*     8     8 */
	destroy_socket_v1_t        destroy_socket;       /*    16     8 */
	start_socket_wait_v1_t     start_socket_wait;    /*    24     8 */
	end_socket_wait_v1_t       end_socket_wait;      /*    32     8 */
	set_socket_state_v1_t      set_socket_state;     /*    40     8 */
	set_socket_info_v1_t       set_socket_info;      /*    48     8 */
	set_socket_thread_owner_v1_t set_socket_thread_owner; /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct st_VioSSLFd {
	SSL_CTX *                  ssl_context;          /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class thd_scheduler {
public:

	void *                     data;                 /*     0     8 */
	void thd_scheduler(class thd_scheduler *);

	void ~thd_scheduler(class thd_scheduler *, int);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct rpl_event_coordinates {
	char *                     file_name;            /*     0     8 */
	my_off_t                   pos;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Query_arena {
	enum enum_state {
		STMT_INITIALIZED        = 0,
		STMT_INITIALIZED_FOR_SP = 1,
		STMT_PREPARED           = 2,
		STMT_REGULAR_EXECUTION  = 3,
		STMT_EXECUTED           = 4,
		STMT_ERROR              = 4294967295,
	};

public:

	void Query_arena(class Query_arena *, const class Query_arena  &);

	class Query_arena & operator=(class Query_arena *, const class Query_arena  &);

	int ()(void) * *           _vptr.Query_arena;    /*     0     8 */
	class Item *               m_item_list;          /*     8     8 */
	class MEM_ROOT *           mem_root;             /*    16     8 */
	bool                       is_repreparing;       /*    24     1 */

	/* XXX 3 bytes hole, try to pack */

	enum enum_state            state;                /*    28     4 */
	void Query_arena(class Query_arena *, class MEM_ROOT *, enum enum_state);

	void Query_arena(class Query_arena *);

	virtual void ~Query_arena(class Query_arena *, int);

	class Item * item_list(const class Query_arena  *);

	void reset_item_list(class Query_arena *);

	void set_item_list(class Query_arena *, class Item *);

	void add_item(class Query_arena *, class Item *);

	void free_items(class Query_arena *);

	void set_state(class Query_arena *, enum enum_state);

	enum enum_state get_state(const class Query_arena  *);

	bool is_stmt_prepare(const class Query_arena  *);

	bool is_stmt_prepare_or_first_sp_execute(const class Query_arena  *);

	bool is_stmt_prepare_or_first_stmt_execute(const class Query_arena  *);

	bool is_regular(const class Query_arena  *);

	void * alloc(class Query_arena *, size_t);

	void * mem_calloc(class Query_arena *, size_t);

	void * mem_aligned_calloc(class Query_arena *, size_t, size_t);

	char * mem_strdup(class Query_arena *, const char  *);

	char * strmake(const class Query_arena  *, const char  *, size_t);

	LEX_CSTRING strmake(class Query_arena *, LEX_CSTRING);

	void * memdup(class Query_arena *, const void  *, size_t);

	void set_query_arena(class Query_arena *, const class Query_arena  &);

	void swap_query_arena(class Query_arena *, const class Query_arena  &, class Query_arena *);


	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 29, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > > * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepare, reference);

	typedef class pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > > & reference;

	typedef const class pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepare, const_reference);

	typedef const class pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_stat, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_stat, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_stat, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_stat, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepare);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepare);

	void Malloc_allocator<void*>(class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_stat, const class Malloc_allocator<void*>  &);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > >, false> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > >, false> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, s, reference);

	typedef class _Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > >, false> & reference;

	typedef const class _Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, s, const_reference);

	typedef const class _Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::de, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::de, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::de, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::de, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, s);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, s);

	typedef struct _Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > >, false> value_type;

	struct rebind<std::__detail::_Hash_node_base*> {
		typedef struct Malloc_allocator<std::__detail::_Hash_node_base*> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	void construct<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement> >, long unsigned int const&, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > >(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::de, class pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > > *, const long unsigned int  &, );

	void Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement> > >(class Malloc_allocator<std::__detail::_Hash_node<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::de, const class Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepare);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class malloc_unordered_map<long unsigned int, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> >, std::hash<long unsigned int>, std::equal_to<long unsigned int> > : public unordered_map<long unsigned int, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> >, std::hash<long unsigned int>, std::equal_to<long unsigned int>, Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > > > > {
public:

	/* class unordered_map<long unsigned int, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> >, std::hash<long unsigned int>, std::equal_to<long unsigned int>, Malloc_allocator<std::pair<long unsigned int const, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> > > > > <ancestor>; */ /*     0    64 */
	void malloc_unordered_map(class malloc_unordered_map<long unsigned int, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> >, st, PSI_memory_key);

	void ~malloc_unordered_map(class malloc_unordered_map<long unsigned int, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> >, st, int);


	/* size: 64, cachelines: 1, members: 1 */

	/* BRAIN FART ALERT! 64 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 512 bits */
};
class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, P, reference);

	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> & reference;

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, P, const_reference);

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepare, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepare, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepare, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepare, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, P);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, P);

	void Malloc_allocator<void*>(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepare, const class Malloc_allocator<void*>  &);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*>, true> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*>, true> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, reference);

	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*>, true> & reference;

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_stat  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, const_reference);

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_stat  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	typedef struct _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*>, true> value_type;

	struct rebind<std::__detail::_Hash_node_base*> {
		typedef struct Malloc_allocator<std::__detail::_Hash_node_base*> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	void construct<std::pair<const std::__cxx11::basic_string<char>, Prepared_statement*>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*&>(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> *, , class Prepared_statement * &);

	void Malloc_allocator<std::pair<const std::__cxx11::basic_string<char>, Prepared_statement*> >(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, P);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> : public unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> > > {
public:

	/* class unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> > > <ancestor>; */ /*     0    96 */
	void collation_unordered_map(class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_stateme, const class CHARSET_INFO  *, PSI_memory_key);

	void ~collation_unordered_map(class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_stateme, int);


	/* size: 96, cachelines: 2, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 96 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 768 bits */
};
class Prepared_statement_map {
public:

	void Prepared_statement_map(class Prepared_statement_map *);

	int insert(class Prepared_statement_map *, class Prepared_statement *);

	class Prepared_statement * find_by_name(class Prepared_statement_map *, const LEX_CSTRING  &);

	class Prepared_statement * find(class Prepared_statement_map *, ulong);

	void erase(class Prepared_statement_map *, class Prepared_statement *);

	void claim_memory_ownership(class Prepared_statement_map *, bool);

	void reset(class Prepared_statement_map *);

	void ~Prepared_statement_map(class Prepared_statement_map *, int);

	class malloc_unordered_map<long unsigned int, std::unique_ptr<Prepared_statement, std::default_delete<Prepared_statement> >, std::hash<long unsigned int>, std::equal_to<long unsigned int> > st_hash; /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Prepared_statement*> names_hash; /*    64    96 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	class Prepared_statement * m_last_found_statement; /*   160     8 */

	/* size: 168, cachelines: 3, members: 3 */
	/* last cacheline: 40 bytes */
};
class ilink<Item_change_record> {
	class Item_change_record * * prev;               /*     0     8 */
	class Item_change_record * next;                 /*     8     8 */
public:

	void ilink(class ilink<Item_change_record> *);

	void unlink(class ilink<Item_change_record> *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Item_change_record : public ilink<Item_change_record> {
public:

	/* class ilink<Item_change_record> <ancestor>; */ /*     0    16 */
	void Item_change_record(class Item_change_record *);

	void Item_change_record(class Item_change_record *, class Item * *, class Item *);

	class Item * *             place;                /*    16     8 */
	class Item *               old_value;            /*    24     8 */
	class Item *               new_value;            /*    32     8 */
	bool                       m_cancel;             /*    40     1 */

	/* size: 48, cachelines: 1, members: 5 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */

	/* BRAIN FART ALERT! 48 bytes != 25 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class I_List<Item_change_record> : base_ilist<Item_change_record> {
	using ::clear;

	using ::is_empty;

	using ::get;

	using ::push_front;

	using ::push_back;

	using ::head;

	/* class base_ilist<Item_change_record> <ancestor>; */ /*     0    24 */
public:

	void move_elements_to(class I_List<Item_change_record> *, class I_List<Item_change_record> *);

	void I_List(class I_List<Item_change_record> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Prealloced_array<Reprepare_observer*, 4> {
	struct External {
		class Reprepare_observer * * m_array_ptr;        /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Reprepare_observer * m_buff[4];            /*     0    32 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Reprepare_observer*, 4>  *);

	class Reprepare_observer * * buffer(class Prealloced_array<Reprepare_observer*, 4> *);

	class Reprepare_observer * const * buffer(const class Prealloced_array<Reprepare_observer*, 4>  *);

	void set_size(class Prealloced_array<Reprepare_observer*, 4> *, size_t);

	void adjust_size(class Prealloced_array<Reprepare_observer*, 4> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4> *, const class Prealloced_array<Reprepare_observer*, 4>  &);

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4> *, );

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Reprepare_observer * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4> *, class initializer_list<Reprepare_observer*>);

	class Prealloced_array<Reprepare_observer*, 4> & operator=(class Prealloced_array<Reprepare_observer*, 4> *, const class Prealloced_array<Reprepare_observer*, 4>  &);

	class Prealloced_array<Reprepare_observer*, 4> & operator=(class Prealloced_array<Reprepare_observer*, 4> *, );

	void ~Prealloced_array(class Prealloced_array<Reprepare_observer*, 4> *, int);

	size_t capacity(const class Prealloced_array<Reprepare_observer*, 4>  *);

	size_t element_size(const class Prealloced_array<Reprepare_observer*, 4>  *);

	bool empty(const class Prealloced_array<Reprepare_observer*, 4>  *);

	size_t size(const class Prealloced_array<Reprepare_observer*, 4>  *);

	class Reprepare_observer * & at(class Prealloced_array<Reprepare_observer*, 4> *, size_t);

	class Reprepare_observer * const & at(const class Prealloced_array<Reprepare_observer*, 4>  *, size_t);

	class Reprepare_observer * & operator[](class Prealloced_array<Reprepare_observer*, 4> *, size_t);

	class Reprepare_observer * const & operator[](const class Prealloced_array<Reprepare_observer*, 4>  *, size_t);

	class Reprepare_observer * & back(class Prealloced_array<Reprepare_observer*, 4> *);

	class Reprepare_observer * const & back(const class Prealloced_array<Reprepare_observer*, 4>  *);

	class Reprepare_observer * & front(class Prealloced_array<Reprepare_observer*, 4> *);

	class Reprepare_observer * const & front(const class Prealloced_array<Reprepare_observer*, 4>  *);

	typedef class Reprepare_observer * * iterator;

	iterator begin(class Prealloced_array<Reprepare_observer*, 4> *);

	iterator end(class Prealloced_array<Reprepare_observer*, 4> *);

	const_iterator begin(const class Prealloced_array<Reprepare_observer*, 4>  *);

	const_iterator end(const class Prealloced_array<Reprepare_observer*, 4>  *);

	const_iterator cbegin(const class Prealloced_array<Reprepare_observer*, 4>  *);

	const_iterator cend(const class Prealloced_array<Reprepare_observer*, 4>  *);

	bool assign_at(class Prealloced_array<Reprepare_observer*, 4> *, size_t, const value_type  &);

	typedef class Reprepare_observer * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Reprepare_observer*, 4> *, size_t);

	bool push_back(class Prealloced_array<Reprepare_observer*, 4> *, class Reprepare_observer * const &);

	bool push_back(class Prealloced_array<Reprepare_observer*, 4> *, );

	void pop_back(class Prealloced_array<Reprepare_observer*, 4> *);

	iterator insert(class Prealloced_array<Reprepare_observer*, 4> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Reprepare_observer*, 4> *, const_iterator, );

	class pair<Reprepare_observer**, bool> insert_unique(class Prealloced_array<Reprepare_observer*, 4> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Reprepare_observer*, 4> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Reprepare_observer*, 4>  *, const value_type  &);

	iterator erase(class Prealloced_array<Reprepare_observer*, 4> *, const_iterator);

	iterator erase(class Prealloced_array<Reprepare_observer*, 4> *, size_t);

	void erase_at_end(class Prealloced_array<Reprepare_observer*, 4> *, const_iterator);

	iterator erase(class Prealloced_array<Reprepare_observer*, 4> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Reprepare_observer*, 4> *, class Prealloced_array<Reprepare_observer*, 4> &);

	void shrink_to_fit(class Prealloced_array<Reprepare_observer*, 4> *);

	void resize(class Prealloced_array<Reprepare_observer*, 4> *, size_t, class Reprepare_observer * const &);

	void clear(class Prealloced_array<Reprepare_observer*, 4> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Reprepare_observer * m_buff[4];    /*     8    32 */
	};                                               /*     8    32 */
	bool emplace_back<Reprepare_observer* const&>(class Prealloced_array<Reprepare_observer*, 4> *, class Reprepare_observer * const &);


	/* size: 40, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 40 bytes */
};
class Reprepare_observer {
public:

	bool report_error(class Reprepare_observer *, class THD *);

	bool is_invalidated(const class Reprepare_observer  *);

	void reset_reprepare_observer(class Reprepare_observer *);

	bool can_retry(const class Reprepare_observer  *);

	bool                       m_invalidated;        /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        m_attempt;            /*     4     4 */

	/* Bitfield combined with previous fields */

	static const int                  MAX_REPREPARE_ATTEMPTS = 3; /*     0     0 */

	/* size: 8, cachelines: 1, members: 2, static members: 1 */
	/* sum members: 5, holes: 1, sum holes: 3 */
	/* last cacheline: 8 bytes */
};
class Open_tables_state {
	enum enum_flags {
		BACKUPS_AVAIL = 1,
		SYSTEM_TABLES = 2,
	};

	class Prealloced_array<Reprepare_observer*, 4> m_reprepare_observers; /*     0    40 */
public:

	class Reprepare_observer * get_reprepare_observer(const class Open_tables_state  *);

	void push_reprepare_observer(class Open_tables_state *, class Reprepare_observer *);

	class Reprepare_observer * pop_reprepare_observer(class Open_tables_state *);

	void reset_reprepare_observers(class Open_tables_state *);

	class TABLE *              open_tables;          /*    40     8 */
	class TABLE *              temporary_tables;     /*    48     8 */
	class MYSQL_LOCK *         lock;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class MYSQL_LOCK *         extra_lock;           /*    64     8 */
	enum enum_locked_tables_mode locked_tables_mode; /*    72     4 */
	uint                       state_flags;          /*    76     4 */
	void Open_tables_state(class Open_tables_state *);

	void set_open_tables_state(class Open_tables_state *, class Open_tables_state *);

	void reset_open_tables_state(class Open_tables_state *);

	void ~Open_tables_state(class Open_tables_state *, int);


	/* size: 80, cachelines: 2, members: 7 */
	/* last cacheline: 16 bytes */
};
class Open_tables_backup : public Open_tables_state {
public:

	/* class Open_tables_state   <ancestor>; */      /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class MDL_savepoint       mdl_system_tables_svp; /*    80    16 */
	void ~Open_tables_backup(class Open_tables_backup *, int);

	void Open_tables_backup(class Open_tables_backup *);


	/* size: 96, cachelines: 2, members: 2 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 96 bytes != 16 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 640 bits */
};
class Sub_statement_state {
public:

	ulonglong                  option_bits;          /*     0     8 */
	ulonglong                  first_successful_insert_id_in_prev_stmt; /*     8     8 */
	ulonglong                  first_successful_insert_id_in_cur_stmt; /*    16     8 */
	class Discrete_intervals_list auto_inc_intervals_forced; /*    24    64 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	ulonglong                  current_found_rows;   /*    88     8 */
	ulonglong                  previous_found_rows;  /*    96     8 */
	ha_rows                    num_truncated_fields; /*   104     8 */
	ha_rows                    sent_row_count;       /*   112     8 */
	ha_rows                    examined_row_count;   /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ulong                      client_capabilities;  /*   128     8 */
	uint                       in_sub_stmt;          /*   136     4 */
	bool                       enable_slow_log;      /*   140     1 */

	/* XXX 3 bytes hole, try to pack */

	ulong                      tmp_tables_used;      /*   144     8 */
	ulong                      tmp_tables_disk_used; /*   152     8 */
	ulonglong                  tmp_tables_size;      /*   160     8 */
	bool                       innodb_was_used;      /*   168     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      innodb_io_reads;      /*   176     8 */
	ulonglong                  innodb_io_read;       /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	uint64_t                   innodb_io_reads_wait_timer; /*   192     8 */
	uint64_t                   innodb_lock_que_wait_timer; /*   200     8 */
	uint64_t                   innodb_innodb_que_wait_timer; /*   208     8 */
	ulong                      innodb_page_access;   /*   216     8 */
	ulong                      query_plan_flags;     /*   224     8 */
	ulong                      query_plan_fsort_passes; /*   232     8 */
	class SAVEPOINT *          savepoints;           /*   240     8 */
	enum enum_check_fields     check_for_truncated_fields; /*   248     4 */

	/* size: 256, cachelines: 4, members: 26 */
	/* sum members: 242, holes: 2, sum holes: 10 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 4 */
};
struct Ha_data {
	void *                     ha_ptr;               /*     0     8 */
	void *                     ha_ptr_backup;        /*     8     8 */
	class Ha_trx_info         ha_info[2];            /*    16    48 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	plugin_ref                 lock;                 /*    64     8 */
	void Ha_data(class Ha_data *);


	/* size: 72, cachelines: 2, members: 4 */
	/* last cacheline: 8 bytes */
};
class Global_read_lock {
	enum enum_grl_state {
		GRL_NONE                       = 0,
		GRL_ACQUIRED                   = 1,
		GRL_ACQUIRED_AND_BLOCKS_COMMIT = 2,
	};

public:

	void Global_read_lock(class Global_read_lock *);

	bool lock_global_read_lock(class Global_read_lock *, class THD *);

	void unlock_global_read_lock(class Global_read_lock *, class THD *);

	bool global_read_lock_active(void);

	bool can_acquire_protection(const class Global_read_lock  *);

	bool make_global_read_lock_block_commit(class Global_read_lock *, class THD *);

	bool is_acquired(const class Global_read_lock  *);

	void set_explicit_lock_duration(class Global_read_lock *, class THD *);

	static struct atomic<int>         m_atomic_active_requests; /*     0     0 */
	enum enum_grl_state        m_state;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class MDL_ticket *         m_mdl_global_shared_lock; /*     8     8 */
	class MDL_ticket *         m_mdl_blocks_commits_lock; /*    16     8 */

	/* size: 24, cachelines: 1, members: 3, static members: 1 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class Global_backup_lock {
public:

	void Global_backup_lock(class Global_backup_lock *, enum enum_mdl_namespace);

	bool acquire(class Global_backup_lock *, class THD *);

	void release(class Global_backup_lock *, class THD *);

	bool acquire_protection(class Global_backup_lock *, class THD *, enum enum_mdl_duration, ulong);

	void init_protection_request(const class Global_backup_lock  *, class MDL_request *, enum enum_mdl_duration);

	bool abort_if_acquired(const class Global_backup_lock  *);

	bool is_acquired(const class Global_backup_lock  *);

	const enum enum_mdl_namespace m_namespace;       /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class MDL_ticket *         m_lock;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct QUERY_START_TIME_INFO {
	struct timeval             start_time;           /*     0    16 */
	ulonglong                  start_utime;          /*    16     8 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
class Bloom_filter {
	static const int                  SIZE = 8191;   /*     0     0 */
	typedef struct bitset<8191> Bit_set;

	Bit_set *                  bit_set;              /*     0     8 */
	struct mysql_mutex_t       LOCK_bit_set;         /*     8    48 */
	void Bloom_filter(class Bloom_filter *, const class Bloom_filter  &);

	class Bloom_filter & operator=(class Bloom_filter *, const class Bloom_filter  &);

public:

	void Bloom_filter(class Bloom_filter *);

	void ~Bloom_filter(class Bloom_filter *, int);

	void clear(class Bloom_filter *);

	bool test_and_set(class Bloom_filter *, ulong);


	/* size: 56, cachelines: 1, members: 2, static members: 1 */
	/* last cacheline: 56 bytes */
};
class Transactional_ddl_context {
public:

	void Transactional_ddl_context(class Transactional_ddl_context *, class THD *);

	void ~Transactional_ddl_context(class Transactional_ddl_context *, int);

	void init(class Transactional_ddl_context *, String_type, String_type, const class handlerton  *);

	bool inited(class Transactional_ddl_context *);

	void rollback(class Transactional_ddl_context *);

	void post_ddl(class Transactional_ddl_context *);

	class THD *                m_thd;                /*     0     8 */
	const class handlerton  *  m_hton;               /*     8     8 */
	String_type                m_db;                 /*    16    32 */
	String_type                m_tablename;          /*    48    32 */

	/* size: 80, cachelines: 2, members: 4 */
	/* last cacheline: 16 bytes */
};
class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s, reference);

	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > & reference;

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entr  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s, const_reference);

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entr  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s);

	void Malloc_allocator<void*>(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, const class Malloc_allocator<void*>  &);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> >, true> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> >, true> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, reference);

	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> >, true> & reference;

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_p  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, const_reference);

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_p  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	typedef struct _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> >, true> value_type;

	struct rebind<std::__detail::_Hash_node_base*> {
		typedef struct Malloc_allocator<std::__detail::_Hash_node_base*> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	void Malloc_allocator<std::pair<const std::__cxx11::basic_string<char>, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > >(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class user_var_entry {
	void reset_value(class user_var_entry *);

	void set_value(class user_var_entry *, char *, size_t);

	char * internal_buffer_ptr(class user_var_entry *);

	char * name_ptr(class user_var_entry *);

	bool mem_realloc(class user_var_entry *, size_t);

	bool alloced(class user_var_entry *);

	void free_value(class user_var_entry *);

	void copy_name(class user_var_entry *, const class Simple_cstring  &);

	void init(class user_var_entry *, class THD *, const class Simple_cstring  &, const class CHARSET_INFO  *);

	bool store(class user_var_entry *, const void  *, size_t, enum Item_result);

	void assert_locked(const class user_var_entry  *);

	static const size_t               extra_size = 8; /*     0     0 */
	char *                     m_ptr;                /*     0     8 */
	size_t                     m_length;             /*     8     8 */
	enum Item_result           m_type;               /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	class THD *                m_owner;              /*    24     8 */
	query_id_t                 m_used_query_id;      /*    32     8 */
public:

	void user_var_entry(class user_var_entry *);

	class THD * owner_session(const class user_var_entry  *);

	class Simple_cstring      entry_name;            /*    40    16 */
	class DTCollation         collation;             /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	bool                       unsigned_flag;        /*    72     1 */
	bool store(class user_var_entry *, const void  *, size_t, enum Item_result, const class CHARSET_INFO  *, enum Derivation, bool);

	void set_type(class user_var_entry *, enum Item_result);

	void set_null_value(class user_var_entry *, enum Item_result);

	void set_used_query_id(class user_var_entry *, query_id_t);

	query_id_t used_query_id(const class user_var_entry  *);

	class user_var_entry * create(class THD *, const class Name_string  &, const class CHARSET_INFO  *);

	void destroy(class user_var_entry *);

	void lock(class user_var_entry *);

	void unlock(class user_var_entry *);

	const char  * ptr(const class user_var_entry  *);

	size_t length(const class user_var_entry  *);

	enum Item_result type(const class user_var_entry  *);

	double val_real(const class user_var_entry  *, bool *);

	longlong val_int(const class user_var_entry  *, bool *);

	class String * val_str(const class user_var_entry  *, bool *, class String *, uint);

	class my_decimal * val_decimal(const class user_var_entry  *, bool *, class my_decimal *);


	/* size: 80, cachelines: 2, members: 8, static members: 1 */
	/* sum members: 69, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > : public unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)>, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > > > {
public:

	/* class unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)>, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<user_var_entry, void (*)(user_var_entry*)> > > > <ancestor>; */ /*     0    96 */
	void collation_unordered_map(class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<, const class CHARSET_INFO  *, PSI_memory_key);

	void ~collation_unordered_map(class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<, int);


	/* size: 96, cachelines: 2, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 96 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 768 bits */
};
class List<Security_context> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Security_context> *);

	void List(class List<Security_context> *, const class List<Security_context>  &);

	class List<Security_context> & operator=(class List<Security_context> *, const class List<Security_context>  &);

	void List(class List<Security_context> *, const class List<Security_context>  &, class MEM_ROOT *);

	bool push_back(class List<Security_context> *, class Security_context *);

	bool push_back(class List<Security_context> *, class Security_context *, class MEM_ROOT *);

	bool push_front(class List<Security_context> *, class Security_context *);

	bool push_front(class List<Security_context> *, class Security_context *, class MEM_ROOT *);

	class Security_context * head(class List<Security_context> *);

	const class Security_context  * head(const class List<Security_context>  *);

	class Security_context * * head_ref(class List<Security_context> *);

	class Security_context * pop(class List<Security_context> *);

	void concat(class List<Security_context> *, class List<Security_context> *);

	void disjoin(class List<Security_context> *, class List<Security_context> *);

	void prepend(class List<Security_context> *, class List<Security_context> *);

	void delete_elements(class List<Security_context> *);

	void destroy_elements(class List<Security_context> *);

	class Security_context * operator[](const class List<Security_context>  *, uint);

	void replace(class List<Security_context> *, uint, class Security_context *);

	bool swap_elts(class List<Security_context> *, uint, uint);

	typedef struct List_STL_Iterator<Security_context> iterator;

	iterator begin(class List<Security_context> *);

	iterator end(class List<Security_context> *);

	typedef struct List_STL_Iterator<const Security_context> const_iterator;

	const_iterator begin(const class List<Security_context>  *);

	const_iterator end(const class List<Security_context>  *);

	const_iterator cbegin(const class List<Security_context>  *);

	const_iterator cend(const class List<Security_context>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s, reference);

	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> > & reference;

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, M  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s, const_reference);

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, M  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s);

	void Malloc_allocator<void*>(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::un, const class Malloc_allocator<void*>  &);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> >, true> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> >, true> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, reference);

	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> >, true> & reference;

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_p  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, const_reference);

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_p  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	typedef struct _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> >, true> value_type;

	struct rebind<std::__detail::_Hash_node_base*> {
		typedef struct Malloc_allocator<std::__detail::_Hash_node_base*> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	void Malloc_allocator<std::pair<const std::__cxx11::basic_string<char>, std::unique_ptr<TABLE_LIST, My_free_deleter> > >(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, s);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> > : public unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter>, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> > > > {
public:

	/* class unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter>, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<TABLE_LIST, My_free_deleter> > > > <ancestor>; */ /*     0    96 */
	void collation_unordered_map(class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<, const class CHARSET_INFO  *, PSI_memory_key);

	void ~collation_unordered_map(class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<, int);


	/* size: 96, cachelines: 2, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 96 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 768 bits */
};
class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, U, reference);

	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*> & reference;

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, U, const_reference);

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_le, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_le, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_le, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_le, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, U);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, U);

	void Malloc_allocator<void*>(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_le, const class Malloc_allocator<void*>  &);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*>, true> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*>, true> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, reference);

	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*>, true> & reference;

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lo  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, const_reference);

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lo  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	typedef struct _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*>, true> value_type;

	struct rebind<std::__detail::_Hash_node_base*> {
		typedef struct Malloc_allocator<std::__detail::_Hash_node_base*> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};

	void Malloc_allocator<std::pair<const std::__cxx11::basic_string<char>, User_level_lock*> >(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, U);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > : public unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*> > > {
public:

	/* class unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*> > > <ancestor>; */ /*     0    64 */
	void malloc_unordered_map(class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*, s, PSI_memory_key);

	void ~malloc_unordered_map(class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, User_level_lock*, s, int);


	/* size: 64, cachelines: 1, members: 1 */

	/* BRAIN FART ALERT! 64 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 512 bits */
};
class Prealloced_array<Ha_data, 15> {
	struct External {
		class Ha_data *            m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		struct Ha_data             m_buff[15];           /*     0  1080 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Ha_data, 15>  *);

	class Ha_data * buffer(class Prealloced_array<Ha_data, 15> *);

	const class Ha_data  * buffer(const class Prealloced_array<Ha_data, 15>  *);

	void set_size(class Prealloced_array<Ha_data, 15> *, size_t);

	void adjust_size(class Prealloced_array<Ha_data, 15> *, int);

public:

	static const size_t               initial_capacity = 15; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Ha_data, 15> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Ha_data, 15> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Ha_data, 15> *, const class Prealloced_array<Ha_data, 15>  &);

	void Prealloced_array(class Prealloced_array<Ha_data, 15> *, );

	void Prealloced_array(class Prealloced_array<Ha_data, 15> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const class Ha_data  * const_iterator;

	void Prealloced_array(class Prealloced_array<Ha_data, 15> *, class initializer_list<Ha_data>);

	class Prealloced_array<Ha_data, 15> & operator=(class Prealloced_array<Ha_data, 15> *, const class Prealloced_array<Ha_data, 15>  &);

	class Prealloced_array<Ha_data, 15> & operator=(class Prealloced_array<Ha_data, 15> *, );

	void ~Prealloced_array(class Prealloced_array<Ha_data, 15> *, int);

	size_t capacity(const class Prealloced_array<Ha_data, 15>  *);

	size_t element_size(const class Prealloced_array<Ha_data, 15>  *);

	bool empty(const class Prealloced_array<Ha_data, 15>  *);

	size_t size(const class Prealloced_array<Ha_data, 15>  *);

	class Ha_data & at(class Prealloced_array<Ha_data, 15> *, size_t);

	const class Ha_data  & at(const class Prealloced_array<Ha_data, 15>  *, size_t);

	class Ha_data & operator[](class Prealloced_array<Ha_data, 15> *, size_t);

	const class Ha_data  & operator[](const class Prealloced_array<Ha_data, 15>  *, size_t);

	class Ha_data & back(class Prealloced_array<Ha_data, 15> *);

	const class Ha_data  & back(const class Prealloced_array<Ha_data, 15>  *);

	class Ha_data & front(class Prealloced_array<Ha_data, 15> *);

	const class Ha_data  & front(const class Prealloced_array<Ha_data, 15>  *);

	typedef class Ha_data * iterator;

	iterator begin(class Prealloced_array<Ha_data, 15> *);

	iterator end(class Prealloced_array<Ha_data, 15> *);

	const_iterator begin(const class Prealloced_array<Ha_data, 15>  *);

	const_iterator end(const class Prealloced_array<Ha_data, 15>  *);

	const_iterator cbegin(const class Prealloced_array<Ha_data, 15>  *);

	const_iterator cend(const class Prealloced_array<Ha_data, 15>  *);

	bool assign_at(class Prealloced_array<Ha_data, 15> *, size_t, const value_type  &);

	typedef struct Ha_data value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Ha_data, 15> *, size_t);

	bool push_back(class Prealloced_array<Ha_data, 15> *, const class Ha_data  &);

	bool push_back(class Prealloced_array<Ha_data, 15> *, );

	void pop_back(class Prealloced_array<Ha_data, 15> *);

	iterator insert(class Prealloced_array<Ha_data, 15> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Ha_data, 15> *, const_iterator, );

	class pair<Ha_data*, bool> insert_unique(class Prealloced_array<Ha_data, 15> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Ha_data, 15> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Ha_data, 15>  *, const value_type  &);

	iterator erase(class Prealloced_array<Ha_data, 15> *, const_iterator);

	iterator erase(class Prealloced_array<Ha_data, 15> *, size_t);

	void erase_at_end(class Prealloced_array<Ha_data, 15> *, const_iterator);

	iterator erase(class Prealloced_array<Ha_data, 15> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Ha_data, 15> *, class Prealloced_array<Ha_data, 15> &);

	void shrink_to_fit(class Prealloced_array<Ha_data, 15> *);

	void resize(class Prealloced_array<Ha_data, 15> *, size_t, const class Ha_data  &);

	void clear(class Prealloced_array<Ha_data, 15> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		struct Ha_data     m_buff[15];           /*     8  1080 */
	};                                               /*     8  1080 */
	bool emplace_back<const Ha_data&>(class Prealloced_array<Ha_data, 15> *, const class Ha_data  &);


	/* size: 1088, cachelines: 17, members: 3, static members: 2 */
};
class Query_tables_list {
	enum enum_lock_tables_state {
		LTS_NOT_LOCKED = 0,
		LTS_LOCKED     = 1,
	};

	enum enum_binlog_stmt_unsafe {
		BINLOG_STMT_UNSAFE_LIMIT                                    = 0,
		BINLOG_STMT_UNSAFE_SYSTEM_TABLE                             = 1,
		BINLOG_STMT_UNSAFE_AUTOINC_COLUMNS                          = 2,
		BINLOG_STMT_UNSAFE_UDF                                      = 3,
		BINLOG_STMT_UNSAFE_SYSTEM_VARIABLE                          = 4,
		BINLOG_STMT_UNSAFE_SYSTEM_FUNCTION                          = 5,
		BINLOG_STMT_UNSAFE_NONTRANS_AFTER_TRANS                     = 6,
		BINLOG_STMT_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 7,
		BINLOG_STMT_UNSAFE_MIXED_STATEMENT                          = 8,
		BINLOG_STMT_UNSAFE_INSERT_IGNORE_SELECT                     = 9,
		BINLOG_STMT_UNSAFE_INSERT_SELECT_UPDATE                     = 10,
		BINLOG_STMT_UNSAFE_WRITE_AUTOINC_SELECT                     = 11,
		BINLOG_STMT_UNSAFE_REPLACE_SELECT                           = 12,
		BINLOG_STMT_UNSAFE_CREATE_IGNORE_SELECT                     = 13,
		BINLOG_STMT_UNSAFE_CREATE_REPLACE_SELECT                    = 14,
		BINLOG_STMT_UNSAFE_CREATE_SELECT_AUTOINC                    = 15,
		BINLOG_STMT_UNSAFE_UPDATE_IGNORE                            = 16,
		BINLOG_STMT_UNSAFE_INSERT_TWO_KEYS                          = 17,
		BINLOG_STMT_UNSAFE_AUTOINC_NOT_FIRST                        = 18,
		BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN                          = 19,
		BINLOG_STMT_UNSAFE_SKIP_LOCKED                              = 20,
		BINLOG_STMT_UNSAFE_NOWAIT                                   = 21,
		BINLOG_STMT_UNSAFE_XA                                       = 22,
		BINLOG_STMT_UNSAFE_DEFAULT_EXPRESSION_IN_SUBSTATEMENT       = 23,
		BINLOG_STMT_UNSAFE_ACL_TABLE_READ_IN_DML_DDL                = 24,
		BINLOG_STMT_UNSAFE_COUNT                                    = 25,
	};

	enum enum_stmt_accessed_table {
		STMT_READS_TRANS_TABLE           = 0,
		STMT_READS_NON_TRANS_TABLE       = 1,
		STMT_READS_TEMP_TRANS_TABLE      = 2,
		STMT_READS_TEMP_NON_TRANS_TABLE  = 3,
		STMT_WRITES_TRANS_TABLE          = 4,
		STMT_WRITES_NON_TRANS_TABLE      = 5,
		STMT_WRITES_TEMP_TRANS_TABLE     = 6,
		STMT_WRITES_TEMP_NON_TRANS_TABLE = 7,
		STMT_ACCESS_TABLE_COUNT          = 8,
	};

public:

	class Query_tables_list & operator=(class Query_tables_list *, );

	enum enum_sql_command      sql_command;          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class TABLE_LIST *         query_tables;         /*     8     8 */
	class TABLE_LIST * *       query_tables_last;    /*    16     8 */
	class TABLE_LIST * *       query_tables_own_last; /*    24     8 */
	class unique_ptr<malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::default_delete<malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > sroutines; /*    32     8 */
	class SQL_I_List<Sroutine_hash_entry> sroutines_list; /*    40    24 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class Sroutine_hash_entry * * sroutines_list_own_last; /*    64     8 */
	uint                       sroutines_list_own_elements; /*    72     4 */
	enum enum_lock_tables_state lock_tables_state;   /*    76     4 */
	bool is_query_tables_locked(const class Query_tables_list  *);

	uint                       table_count;          /*    80     4 */
	void Query_tables_list(class Query_tables_list *);

	void ~Query_tables_list(class Query_tables_list *, int);

	void reset_query_tables_list(class Query_tables_list *, bool);

	void destroy_query_tables_list(class Query_tables_list *);

	void set_query_tables_list(class Query_tables_list *, class Query_tables_list *);

	void add_to_query_tables(class Query_tables_list *, class TABLE_LIST *);

	bool requires_prelocking(class Query_tables_list *);

	void mark_as_requiring_prelocking(class Query_tables_list *, class TABLE_LIST * *);

	class TABLE_LIST * first_not_own_table(class Query_tables_list *);

	void chop_off_not_own_tables(class Query_tables_list *);


	/* Bitfield combined with previous fields */

	static const int                  BINLOG_STMT_UNSAFE_ALL_FLAGS = 33554431; /*     0     0 */
	static const const int            binlog_stmt_unsafe_errcode[25]; /*     0     0 */
	bool is_stmt_unsafe(const class Query_tables_list  *, enum enum_binlog_stmt_unsafe);

	bool is_stmt_unsafe(const class Query_tables_list  *);

	bool is_stmt_unsafe(class Query_tables_list *, enum enum_binlog_stmt_unsafe);

	void set_stmt_unsafe(class Query_tables_list *, enum enum_binlog_stmt_unsafe);

	void set_stmt_unsafe_flags(class Query_tables_list *, uint32);

	uint32 get_stmt_unsafe_flags(const class Query_tables_list  *);

	bool is_stmt_row_injection(const class Query_tables_list  *);

	void set_stmt_row_injection(class Query_tables_list *);

	void set_stmt_accessed_table(class Query_tables_list *, enum enum_stmt_accessed_table);

	bool stmt_accessed_table(class Query_tables_list *, enum enum_stmt_accessed_table);

	bool is_mixed_stmt_unsafe(class Query_tables_list *, bool, bool, bool, uint);

	bool uses_stored_routines(const class Query_tables_list  *);

	void set_using_match(class Query_tables_list *);

	bool get_using_match(class Query_tables_list *);

	void set_stmt_unsafe_with_mixed_mode(class Query_tables_list *);

	bool is_stmt_unsafe_with_mixed_mode(const class Query_tables_list  *);

	uint32                     binlog_stmt_flags;    /*    84     4 */
	uint32                     stmt_accessed_table_flag; /*    88     4 */
	bool                       using_match;          /*    92     1 */
	bool                       stmt_unsafe_with_mixed_mode; /*    93     1 */

	/* size: 96, cachelines: 2, members: 14, static members: 2 */
	/* sum members: 90, holes: 1, sum holes: 4 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
class base_ilist<Item_change_record> {
	class Item_change_record * first;                /*     0     8 */
	class ilink<Item_change_record> sentinel;        /*     8    16 */
public:

	void clear(class base_ilist<Item_change_record> *);

	void base_ilist(class base_ilist<Item_change_record> *);

	bool is_empty(const class base_ilist<Item_change_record>  *);

	void push_front(class base_ilist<Item_change_record> *, class Item_change_record *);

	void push_back(class base_ilist<Item_change_record> *, class Item_change_record *);

	class Item_change_record * get(class base_ilist<Item_change_record> *);

	class Item_change_record * head(class base_ilist<Item_change_record> *);

	void move_elements_to(class base_ilist<Item_change_record> *, class base_ilist<Item_change_record> *);

	void base_ilist(class base_ilist<Item_change_record> *, const class base_ilist<Item_change_record>  &);

	void operator=(class base_ilist<Item_change_record> *, const class base_ilist<Item_change_record>  &);


	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
class PROFILING {
	query_id_t                 profile_id_counter;   /*     0     8 */
	class THD *                thd;                  /*     8     8 */
	bool                       keeping;              /*    16     1 */
	bool                       enabled;              /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	class QUERY_PROFILE *      current;              /*    24     8 */
	class QUERY_PROFILE *      last;                 /*    32     8 */
	class Queue<QUERY_PROFILE> history;              /*    40    24 */
	query_id_t next_profile_id(class PROFILING *);

public:

	void PROFILING(class PROFILING *);

	void ~PROFILING(class PROFILING *, int);

	void set_query_source(class PROFILING *, const char  *, size_t);

	void start_new_query(class PROFILING *, const char  *);

	void discard_current_query(class PROFILING *);

	void finish_current_query(class PROFILING *);

	void status_change(class PROFILING *, const char  *, const char  *, const char  *, unsigned int);

	void set_thd(class PROFILING *, class THD *);

	bool show_profiles(class PROFILING *);

	bool enabled_getrusage(const class PROFILING  *);

	int fill_statistics_info(class PROFILING *, class THD *, class TABLE_LIST *);

	void cleanup(class PROFILING *);

	int print_current(const class PROFILING  *, class IO_CACHE *);


	/* size: 64, cachelines: 1, members: 7 */
	/* sum members: 58, holes: 1, sum holes: 6 */
};
class Prealloced_array<Binlog_user_var_event*, 2> {
	struct External {
		class Binlog_user_var_event * * m_array_ptr;     /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Binlog_user_var_event * m_buff[2];         /*     0    16 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	class Binlog_user_var_event * * buffer(class Prealloced_array<Binlog_user_var_event*, 2> *);

	class Binlog_user_var_event * const * buffer(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	void set_size(class Prealloced_array<Binlog_user_var_event*, 2> *, size_t);

	void adjust_size(class Prealloced_array<Binlog_user_var_event*, 2> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Binlog_user_var_event*, 2> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Binlog_user_var_event*, 2> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Binlog_user_var_event*, 2> *, const class Prealloced_array<Binlog_user_var_event*, 2>  &);

	void Prealloced_array(class Prealloced_array<Binlog_user_var_event*, 2> *, );

	void Prealloced_array(class Prealloced_array<Binlog_user_var_event*, 2> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Binlog_user_var_event * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Binlog_user_var_event*, 2> *, class initializer_list<Binlog_user_var_event*>);

	class Prealloced_array<Binlog_user_var_event*, 2> & operator=(class Prealloced_array<Binlog_user_var_event*, 2> *, const class Prealloced_array<Binlog_user_var_event*, 2>  &);

	class Prealloced_array<Binlog_user_var_event*, 2> & operator=(class Prealloced_array<Binlog_user_var_event*, 2> *, );

	void ~Prealloced_array(class Prealloced_array<Binlog_user_var_event*, 2> *, int);

	size_t capacity(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	size_t element_size(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	bool empty(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	size_t size(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	class Binlog_user_var_event * & at(class Prealloced_array<Binlog_user_var_event*, 2> *, size_t);

	class Binlog_user_var_event * const & at(const class Prealloced_array<Binlog_user_var_event*, 2>  *, size_t);

	class Binlog_user_var_event * & operator[](class Prealloced_array<Binlog_user_var_event*, 2> *, size_t);

	class Binlog_user_var_event * const & operator[](const class Prealloced_array<Binlog_user_var_event*, 2>  *, size_t);

	class Binlog_user_var_event * & back(class Prealloced_array<Binlog_user_var_event*, 2> *);

	class Binlog_user_var_event * const & back(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	class Binlog_user_var_event * & front(class Prealloced_array<Binlog_user_var_event*, 2> *);

	class Binlog_user_var_event * const & front(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	typedef class Binlog_user_var_event * * iterator;

	iterator begin(class Prealloced_array<Binlog_user_var_event*, 2> *);

	iterator end(class Prealloced_array<Binlog_user_var_event*, 2> *);

	const_iterator begin(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	const_iterator end(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	const_iterator cbegin(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	const_iterator cend(const class Prealloced_array<Binlog_user_var_event*, 2>  *);

	bool assign_at(class Prealloced_array<Binlog_user_var_event*, 2> *, size_t, const value_type  &);

	typedef class Binlog_user_var_event * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Binlog_user_var_event*, 2> *, size_t);

	bool push_back(class Prealloced_array<Binlog_user_var_event*, 2> *, class Binlog_user_var_event * const &);

	bool push_back(class Prealloced_array<Binlog_user_var_event*, 2> *, );

	void pop_back(class Prealloced_array<Binlog_user_var_event*, 2> *);

	iterator insert(class Prealloced_array<Binlog_user_var_event*, 2> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Binlog_user_var_event*, 2> *, const_iterator, );

	class pair<Binlog_user_var_event**, bool> insert_unique(class Prealloced_array<Binlog_user_var_event*, 2> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Binlog_user_var_event*, 2> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Binlog_user_var_event*, 2>  *, const value_type  &);

	iterator erase(class Prealloced_array<Binlog_user_var_event*, 2> *, const_iterator);

	iterator erase(class Prealloced_array<Binlog_user_var_event*, 2> *, size_t);

	void erase_at_end(class Prealloced_array<Binlog_user_var_event*, 2> *, const_iterator);

	iterator erase(class Prealloced_array<Binlog_user_var_event*, 2> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Binlog_user_var_event*, 2> *, class Prealloced_array<Binlog_user_var_event*, 2> &);

	void shrink_to_fit(class Prealloced_array<Binlog_user_var_event*, 2> *);

	void resize(class Prealloced_array<Binlog_user_var_event*, 2> *, size_t, class Binlog_user_var_event * const &);

	void clear(class Prealloced_array<Binlog_user_var_event*, 2> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Binlog_user_var_event * m_buff[2]; /*     8    16 */
	};                                               /*     8    24 */

	/* size: 32, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 32 bytes */
};
struct Binlog_user_var_event {
	class user_var_entry *     user_var_event;       /*     0     8 */
	char *                     value;                /*     8     8 */
	ulong                      length;               /*    16     8 */
	enum Item_result           type;                 /*    24     4 */
	uint                       charset_number;       /*    28     4 */
	bool                       unsigned_flag;        /*    32     1 */

	/* size: 40, cachelines: 1, members: 6 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
class Prealloced_array<long unsigned int, 11> {
	struct External {
		long unsigned int *        m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		long unsigned int          m_buff[11];           /*     0    88 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<long unsigned int, 11>  *);

	long unsigned int * buffer(class Prealloced_array<long unsigned int, 11> *);

	const long unsigned int  * buffer(const class Prealloced_array<long unsigned int, 11>  *);

	void set_size(class Prealloced_array<long unsigned int, 11> *, size_t);

	void adjust_size(class Prealloced_array<long unsigned int, 11> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<long unsigned int, 11> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<long unsigned int, 11> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<long unsigned int, 11> *, const class Prealloced_array<long unsigned int, 11>  &);

	void Prealloced_array(class Prealloced_array<long unsigned int, 11> *, );

	void Prealloced_array(class Prealloced_array<long unsigned int, 11> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const long unsigned int  * const_iterator;

	void Prealloced_array(class Prealloced_array<long unsigned int, 11> *, class initializer_list<long unsigned int>);

	class Prealloced_array<long unsigned int, 11> & operator=(class Prealloced_array<long unsigned int, 11> *, const class Prealloced_array<long unsigned int, 11>  &);

	class Prealloced_array<long unsigned int, 11> & operator=(class Prealloced_array<long unsigned int, 11> *, );

	void ~Prealloced_array(class Prealloced_array<long unsigned int, 11> *, int);

	size_t capacity(const class Prealloced_array<long unsigned int, 11>  *);

	size_t element_size(const class Prealloced_array<long unsigned int, 11>  *);

	bool empty(const class Prealloced_array<long unsigned int, 11>  *);

	size_t size(const class Prealloced_array<long unsigned int, 11>  *);

	long unsigned int & at(class Prealloced_array<long unsigned int, 11> *, size_t);

	const long unsigned int  & at(const class Prealloced_array<long unsigned int, 11>  *, size_t);

	long unsigned int & operator[](class Prealloced_array<long unsigned int, 11> *, size_t);

	const long unsigned int  & operator[](const class Prealloced_array<long unsigned int, 11>  *, size_t);

	long unsigned int & back(class Prealloced_array<long unsigned int, 11> *);

	const long unsigned int  & back(const class Prealloced_array<long unsigned int, 11>  *);

	long unsigned int & front(class Prealloced_array<long unsigned int, 11> *);

	const long unsigned int  & front(const class Prealloced_array<long unsigned int, 11>  *);

	typedef long unsigned int * iterator;

	iterator begin(class Prealloced_array<long unsigned int, 11> *);

	iterator end(class Prealloced_array<long unsigned int, 11> *);

	const_iterator begin(const class Prealloced_array<long unsigned int, 11>  *);

	const_iterator end(const class Prealloced_array<long unsigned int, 11>  *);

	const_iterator cbegin(const class Prealloced_array<long unsigned int, 11>  *);

	const_iterator cend(const class Prealloced_array<long unsigned int, 11>  *);

	bool assign_at(class Prealloced_array<long unsigned int, 11> *, size_t, const value_type  &);

	typedef long unsigned int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<long unsigned int, 11> *, size_t);

	bool push_back(class Prealloced_array<long unsigned int, 11> *, const long unsigned int  &);

	bool push_back(class Prealloced_array<long unsigned int, 11> *, );

	void pop_back(class Prealloced_array<long unsigned int, 11> *);

	iterator insert(class Prealloced_array<long unsigned int, 11> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<long unsigned int, 11> *, const_iterator, );

	class pair<long unsigned int*, bool> insert_unique(class Prealloced_array<long unsigned int, 11> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<long unsigned int, 11> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<long unsigned int, 11>  *, const value_type  &);

	iterator erase(class Prealloced_array<long unsigned int, 11> *, const_iterator);

	iterator erase(class Prealloced_array<long unsigned int, 11> *, size_t);

	void erase_at_end(class Prealloced_array<long unsigned int, 11> *, const_iterator);

	iterator erase(class Prealloced_array<long unsigned int, 11> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<long unsigned int, 11> *, class Prealloced_array<long unsigned int, 11> &);

	void shrink_to_fit(class Prealloced_array<long unsigned int, 11> *);

	void resize(class Prealloced_array<long unsigned int, 11> *, size_t, const long unsigned int  &);

	void clear(class Prealloced_array<long unsigned int, 11> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		long unsigned int  m_buff[11];           /*     8    88 */
	};                                               /*     8    88 */

	/* size: 96, cachelines: 2, members: 3, static members: 2 */
	/* last cacheline: 32 bytes */
};
struct s_mysql_dynamic_loader {
	mysql_service_status_t     (*load)(const char  * *, int); /*     0     8 */
	mysql_service_status_t     (*unload)(const char  * *, int); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct mysql_service_ref_t {
	const char  *              name;                 /*     0     8 */
	void *                     implementation;       /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct mysql_service_placeholder_ref_t {
	const char  *              name;                 /*     0     8 */
	void * *                   implementation;       /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct mysql_metadata_ref_t {
	const char  *              key;                  /*     0     8 */
	const char  *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct mysql_component_t {
	const char  *              name;                 /*     0     8 */
	class mysql_service_ref_t * provides;            /*     8     8 */
	class mysql_service_placeholder_ref_t * requires; /*    16     8 */
	class mysql_metadata_ref_t * metadata;           /*    24     8 */
	mysql_service_status_t     (*init)(void);        /*    32     8 */
	mysql_service_status_t     (*deinit)(void);      /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct s_mysql_dynamic_loader_scheme {
	mysql_service_status_t     (*load)(const char  *, class mysql_component_t * *); /*     0     8 */
	mysql_service_status_t     (*unload)(const char  *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct s_mysql_registry {
	mysql_service_status_t     (*acquire)(const char  *, my_h_service *); /*     0     8 */
	mysql_service_status_t     (*acquire_related)(const char  *, my_h_service, my_h_service *); /*     8     8 */
	mysql_service_status_t     (*release)(my_h_service); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Query_logger {
	static const uint                 MAX_LOG_HANDLERS_NUM = 2; /*     0     0 */
	struct mysql_rwlock_t      LOCK_logger;          /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class Log_to_csv_event_handler table_log_handler; /*    64     0 */

	/* XXX 8 bytes hole, try to pack */

	class Log_to_file_event_handler * file_log_handler; /*    72     8 */
	class Log_event_handler *  slow_log_handler_list[3]; /*    80    24 */
	class Log_event_handler *  general_log_handler_list[3]; /*   104    24 */
	void init_query_log(class Query_logger *, enum enum_log_table_type, ulonglong);

public:

	void Query_logger(class Query_logger *);

	bool is_log_table_enabled(const class Query_logger  *, enum enum_log_table_type);

	bool is_log_file_enabled(const class Query_logger  *, enum enum_log_table_type);

	void init(class Query_logger *);

	void cleanup(class Query_logger *);

	bool slow_log_write(class Query_logger *, class THD *, const char  *, size_t, class System_status_var *);

	bool general_log_print(class Query_logger *, class THD *, enum enum_server_command, const char  *, ...);

	bool general_log_write(class Query_logger *, class THD *, enum enum_server_command, const char  *, size_t);

	void set_handlers(class Query_logger *, ulonglong);

	bool activate_log_handler(class Query_logger *, class THD *, enum enum_log_table_type);

	void deactivate_log_handler(class Query_logger *, enum enum_log_table_type);

	bool reopen_log_file(class Query_logger *, enum enum_log_table_type);

	bool set_log_file(class Query_logger *, enum enum_log_table_type);

	enum enum_log_table_type check_if_log_table(const class Query_logger  *, class TABLE_LIST *, bool);


	/* size: 128, cachelines: 2, members: 5, static members: 1 */
	/* sum members: 120, holes: 1, sum holes: 8 */
};
class Log_event_handler {
public:

	void Log_event_handler(class Log_event_handler *, const class Log_event_handler  &);

	int ()(void) * *           _vptr.Log_event_handler; /*     0     8 */
	void Log_event_handler(class Log_event_handler *);

	virtual void ~Log_event_handler(class Log_event_handler *, int);

	virtual bool log_slow(class Log_event_handler *, class THD *, ulonglong, ulonglong, const char  *, size_t, ulonglong, ulonglong, bool, const char  *, size_t, class System_status_var *);

	virtual bool log_general(class Log_event_handler *, class THD *, ulonglong, const char  *, size_t, my_thread_id, const char  *, size_t, const char  *, size_t, const class CHARSET_INFO  *);

	/* vtable has 2 entries: {
	   [2] = log_slow((null)), 
	   [3] = log_general((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Log_throttle {
	ulonglong                  window_end;           /*     0     8 */
	const ulong                window_size;          /*     8     8 */
	ulong                      count;                /*    16     8 */
protected:

	const char  *              summary_template;     /*    24     8 */
	void new_window(class Log_throttle *, ulonglong);

	bool inc_log_count(class Log_throttle *, ulong);

	bool in_window(const class Log_throttle  *, ulonglong);

	ulong prepare_summary(class Log_throttle *, ulong);

	void Log_throttle(class Log_throttle *, ulong, const char  *);

public:


	/* Bitfield combined with previous fields */

	static const ulong                LOG_THROTTLE_WINDOW_SIZE = 60000000; /*     0     0 */

	/* size: 32, cachelines: 1, members: 4, static members: 1 */
	/* last cacheline: 32 bytes */
};
class Slow_log_throttle : public Log_throttle {
public:

	/* class Log_throttle        <ancestor>; */      /*     0    32 */
	class Security_context    aggregate_sctx;        /*    32  1040 */
	/* --- cacheline 16 boundary (1024 bytes) was 48 bytes ago --- */
	ulonglong                  total_exec_time;      /*  1072     8 */
	ulonglong                  total_lock_time;      /*  1080     8 */
	/* --- cacheline 17 boundary (1088 bytes) --- */
	ulong *                    rate;                 /*  1088     8 */
	bool                       (*log_summary)(class THD *, const char  *, size_t, class System_status_var *); /*  1096     8 */
	class mysql_mutex_t *      LOCK_log_throttle;    /*  1104     8 */
	void new_window(class Slow_log_throttle *, ulonglong);

	void print_summary(class Slow_log_throttle *, class THD *, ulong, ulonglong, ulonglong);

	void Slow_log_throttle(class Slow_log_throttle *, ulong *, class mysql_mutex_t *, ulong, bool (*)(class THD *, const char  *, size_t, class System_status_var *), const char  *);

	bool flush(class Slow_log_throttle *, class THD *);

	bool log(class Slow_log_throttle *, class THD *, bool);


	/* size: 1112, cachelines: 18, members: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 1112 bytes != 1080 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class LogEvent {
	log_line *                 ll;                   /*     0     8 */
	char *                     msg;                  /*     8     8 */
	const char  *              msg_tag;              /*    16     8 */
	bool set_errcode(class LogEvent *, longlong);

	void set_message(class LogEvent *, const char  *, class typedef __va_list_tag __va_list_tag *);

	void set_message_by_errcode(class LogEvent *, longlong, class typedef __va_list_tag __va_list_tag *);

public:

	void ~LogEvent(class LogEvent *, int);

	void LogEvent(class LogEvent *);

	class LogEvent & type(class LogEvent *, enum enum_log_type);

	class LogEvent & errcode(class LogEvent *, longlong);

	class LogEvent & errsymbol(class LogEvent *, const char  *);

	class LogEvent & sqlstate(class LogEvent *, const char  *);

	class LogEvent & os_errno(class LogEvent *, longlong);

	class LogEvent & os_errmsg(class LogEvent *, const char  *);

	class LogEvent & source_file(class LogEvent *, const char  *);

	class LogEvent & source_line(class LogEvent *, longlong);

	class LogEvent & function(class LogEvent *, const char  *);

	class LogEvent & subsys(class LogEvent *, const char  *);

	class LogEvent & component(class LogEvent *, const char  *);

	class LogEvent & user(class LogEvent *, LEX_CSTRING);

	class LogEvent & user(class LogEvent *, const char  *);

	class LogEvent & host(class LogEvent *, LEX_CSTRING);

	class LogEvent & host(class LogEvent *, const char  *);

	class LogEvent & thread_id(class LogEvent *, longlong);

	class LogEvent & query_id(class LogEvent *, longlong);

	class LogEvent & table_name(class LogEvent *, const char  *);

	class LogEvent & prio(class LogEvent *, longlong);

	class LogEvent & label(class LogEvent *, const char  *);

	class LogEvent & verbatim(class LogEvent *, const char  *);

	class LogEvent & messagev(class LogEvent *, const char  *, class typedef __va_list_tag __va_list_tag *);

	class LogEvent & message(class LogEvent *, const char  *, ...);

	class LogEvent & message_quoted(class LogEvent *, const char  *, const char  *, ...);

	class LogEvent & lookup(class LogEvent *, longlong, ...);

	class LogEvent & lookupv(class LogEvent *, longlong, class typedef __va_list_tag __va_list_tag *);

	class LogEvent & lookup_quoted(class LogEvent *, longlong, const char  *, ...);

	class LogEvent & lookup_quotedv(class LogEvent *, longlong, const char  *, class typedef __va_list_tag __va_list_tag *);

	class LogEvent & int_value(class LogEvent *, const char  *, longlong);

	class LogEvent & float_value(class LogEvent *, const char  *, double);

	class LogEvent & string_value(class LogEvent *, const char  *, const char  *, size_t);

	class LogEvent & string_value(class LogEvent *, const char  *, const char  *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class I_List<i_string> : base_ilist<i_string> {
	using ::clear;

	using ::is_empty;

	using ::get;

	using ::push_front;

	using ::push_back;

	using ::head;

	/* class base_ilist<i_string> <ancestor>; */     /*     0    24 */
public:

	void move_elements_to(class I_List<i_string> *, class I_List<i_string> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct SHOW_VAR {
	const char  *              name;                 /*     0     8 */
	char *                     value;                /*     8     8 */
	enum enum_mysql_show_type  type;                 /*    16     4 */
	enum enum_mysql_show_scope scope;                /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct COM_INIT_DB_DATA {
	const char  *              db_name;              /*     0     8 */
	long unsigned int          length;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct COM_REFRESH_DATA {
	unsigned char              options;              /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct COM_KILL_DATA {
	long unsigned int          id;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct COM_SET_OPTION_DATA {
	unsigned int               opt_command;          /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct PS_PARAM {
	unsigned char              null_bit;             /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	enum enum_field_types      type;                 /*     4     4 */
	unsigned char              unsigned_type;        /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	const unsigned char  *     value;                /*    16     8 */
	long unsigned int          length;               /*    24     8 */
	const unsigned char  *     name;                 /*    32     8 */
	long unsigned int          name_length;          /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 38, holes: 2, sum holes: 10 */
	/* last cacheline: 48 bytes */
};
struct COM_STMT_EXECUTE_DATA {
	long unsigned int          stmt_id;              /*     0     8 */
	long unsigned int          open_cursor;          /*     8     8 */
	class PS_PARAM *           parameters;           /*    16     8 */
	long unsigned int          parameter_count;      /*    24     8 */
	unsigned char              has_new_types;        /*    32     1 */

	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
struct COM_STMT_FETCH_DATA {
	long unsigned int          stmt_id;              /*     0     8 */
	long unsigned int          num_rows;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct COM_STMT_SEND_LONG_DATA_DATA {
	long unsigned int          stmt_id;              /*     0     8 */
	unsigned int               param_number;         /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	unsigned char *            longdata;             /*    16     8 */
	long unsigned int          length;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct COM_STMT_PREPARE_DATA {
	const char  *              query;                /*     0     8 */
	unsigned int               length;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct COM_STMT_CLOSE_DATA {
	unsigned int               stmt_id;              /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct COM_STMT_RESET_DATA {
	unsigned int               stmt_id;              /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct COM_QUERY_DATA {
	const char  *              query;                /*     0     8 */
	unsigned int               length;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	class PS_PARAM *           parameters;           /*    16     8 */
	long unsigned int          parameter_count;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct COM_FIELD_LIST_DATA {
	unsigned char *            table_name;           /*     0     8 */
	unsigned int               table_name_length;    /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const unsigned char  *     query;                /*    16     8 */
	unsigned int               query_length;         /*    24     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 24, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
union COM_DATA {
	struct COM_INIT_DB_DATA    com_init_db;        /*     0    16 */
	struct COM_REFRESH_DATA    com_refresh;        /*     0     1 */
	struct COM_KILL_DATA       com_kill;           /*     0     8 */
	struct COM_SET_OPTION_DATA com_set_option;     /*     0     4 */
	struct COM_STMT_EXECUTE_DATA com_stmt_execute; /*     0    40 */
	struct COM_STMT_FETCH_DATA com_stmt_fetch;     /*     0    16 */
	struct COM_STMT_SEND_LONG_DATA_DATA com_stmt_send_long_data; /*     0    32 */
	struct COM_STMT_PREPARE_DATA com_stmt_prepare; /*     0    16 */
	struct COM_STMT_CLOSE_DATA com_stmt_close;     /*     0     4 */
	struct COM_STMT_RESET_DATA com_stmt_reset;     /*     0     4 */
	struct COM_QUERY_DATA      com_query;          /*     0    32 */
	struct COM_FIELD_LIST_DATA com_field_list;     /*     0    32 */
};
struct srv_session_service_st {
	int                        (*init_session_thread)(const void  *); /*     0     8 */
	void                       (*deinit_session_thread)(void); /*     8     8 */
	MYSQL_SESSION              (*open_session)(srv_session_error_cb, void *); /*    16     8 */
	int                        (*detach_session)(MYSQL_SESSION); /*    24     8 */
	int                        (*close_session)(MYSQL_SESSION); /*    32     8 */
	int                        (*server_is_available)(void); /*    40     8 */
	int                        (*attach_session)(MYSQL_SESSION, class THD * *); /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct st_send_field {
	const char  *              db_name;              /*     0     8 */
	const char  *              table_name;           /*     8     8 */
	const char  *              org_table_name;       /*    16     8 */
	const char  *              col_name;             /*    24     8 */
	const char  *              org_col_name;         /*    32     8 */
	long unsigned int          length;               /*    40     8 */
	unsigned int               charsetnr;            /*    48     4 */
	unsigned int               flags;                /*    52     4 */
	unsigned int               decimals;             /*    56     4 */
	enum enum_field_types      type;                 /*    60     4 */

	/* size: 64, cachelines: 1, members: 10 */
};
struct st_command_service_cbs {
	start_result_metadata_t    start_result_metadata; /*     0     8 */
	field_metadata_t           field_metadata;       /*     8     8 */
	end_result_metadata_t      end_result_metadata;  /*    16     8 */
	start_row_t                start_row;            /*    24     8 */
	end_row_t                  end_row;              /*    32     8 */
	abort_row_t                abort_row;            /*    40     8 */
	get_client_capabilities_t  get_client_capabilities; /*    48     8 */
	get_null_t                 get_null;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	get_integer_t              get_integer;          /*    64     8 */
	get_longlong_t             get_longlong;         /*    72     8 */
	get_decimal_t              get_decimal;          /*    80     8 */
	get_double_t               get_double;           /*    88     8 */
	get_date_t                 get_date;             /*    96     8 */
	get_time_t                 get_time;             /*   104     8 */
	get_datetime_t             get_datetime;         /*   112     8 */
	get_string_t               get_string;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	handle_ok_t                handle_ok;            /*   128     8 */
	handle_error_t             handle_error;         /*   136     8 */
	shutdown_t                 shutdown;             /*   144     8 */
	connection_alive_t         connection_alive;     /*   152     8 */

	/* size: 160, cachelines: 3, members: 20 */
	/* last cacheline: 32 bytes */
};
struct command_service_st {
	int                        (*run_command)(MYSQL_SESSION, enum enum_server_command, const union COM_DATA  *, const class CHARSET_INFO  *, const class st_command_service_cbs  *, enum cs_text_or_binary, void *); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct mysql_locking_service_st {
	mysql_acquire_locks_t      mysql_acquire_locks;  /*     0     8 */
	mysql_release_locks_t      mysql_release_locks;  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct my_plugin_log_service {
	int                        (*my_plugin_log_message)(MYSQL_PLUGIN *, enum plugin_log_level, const char  *, ...); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct mysql_keyring_service_st {
	int                        (*my_key_store_func)(const char  *, const char  *, const char  *, const void  *, size_t); /*     0     8 */
	int                        (*my_key_fetch_func)(const char  *, char * *, const char  *, void * *, size_t *); /*     8     8 */
	int                        (*my_key_remove_func)(const char  *, const char  *); /*    16     8 */
	int                        (*my_key_generate_func)(const char  *, const char  *, const char  *, size_t); /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct mysql_password_policy_service_st {
	int                        (*my_validate_password_policy_func)(const char  *, unsigned int); /*     0     8 */
	int                        (*my_calculate_password_strength_func)(const char  *, unsigned int); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct mysql_string_service_st {
	int                        (*mysql_string_convert_to_char_ptr_type)(mysql_string_handle, const char  *, char *, unsigned int, int *); /*     0     8 */
	mysql_string_iterator_handle (*mysql_string_get_iterator_type)(mysql_string_handle); /*     8     8 */
	int                        (*mysql_string_iterator_next_type)(mysql_string_iterator_handle); /*    16     8 */
	int                        (*mysql_string_iterator_isupper_type)(mysql_string_iterator_handle); /*    24     8 */
	int                        (*mysql_string_iterator_islower_type)(mysql_string_iterator_handle); /*    32     8 */
	int                        (*mysql_string_iterator_isdigit_type)(mysql_string_iterator_handle); /*    40     8 */
	mysql_string_handle        (*mysql_string_to_lowercase_type)(mysql_string_handle); /*    48     8 */
	void                       (*mysql_string_free_type)(mysql_string_handle); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*mysql_string_iterator_free_type)(mysql_string_iterator_handle); /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* last cacheline: 8 bytes */
};
struct mysql_parser_service_st {
	mysql_current_session_t    mysql_current_session; /*     0     8 */
	mysql_open_session_t       mysql_open_session;   /*     8     8 */
	mysql_start_thread_t       mysql_start_thread;   /*    16     8 */
	mysql_join_thread_t        mysql_join_thread;    /*    24     8 */
	mysql_set_current_database_t mysql_set_current_database; /*    32     8 */
	mysql_parse_t              mysql_parse;          /*    40     8 */
	mysql_get_statement_type_t mysql_get_statement_type; /*    48     8 */
	mysql_get_statement_digest_t mysql_get_statement_digest; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	mysql_get_number_params_t  mysql_get_number_params; /*    64     8 */
	mysql_extract_prepared_params_t mysql_extract_prepared_params; /*    72     8 */
	mysql_visit_tree_t         mysql_visit_tree;     /*    80     8 */
	mysql_item_string_t        mysql_item_string;    /*    88     8 */
	mysql_free_string_t        mysql_free_string;    /*    96     8 */
	mysql_get_query_t          mysql_get_query;      /*   104     8 */
	mysql_get_normalized_query_t mysql_get_normalized_query; /*   112     8 */

	/* size: 120, cachelines: 2, members: 15 */
	/* last cacheline: 56 bytes */
};
struct plugin_registry_service_st {
	const mysql_service_registry_t  * (*mysql_plugin_registry_acquire_func)(void); /*     0     8 */
	int                        (*mysql_plugin_registry_release_func)(const mysql_service_registry_t  *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Transaction_write_set {
	unsigned int               m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int          write_set_size;       /*     8     8 */
	long long unsigned int *   write_set;            /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct transaction_write_set_service_st {
	class Transaction_write_set * (*get_transaction_write_set)(long unsigned int); /*     0     8 */
	void                       (*require_full_write_set)(bool); /*     8     8 */
	void                       (*set_write_set_memory_size_limit)(uint64); /*    16     8 */
	void                       (*update_write_set_memory_size_limit)(uint64); /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct security_context_service_st {
	my_svc_bool                (*thd_get_security_context)(class THD *, class Security_context * *); /*     0     8 */
	my_svc_bool                (*thd_set_security_context)(class THD *, class Security_context *); /*     8     8 */
	my_svc_bool                (*security_context_create)(class Security_context * *); /*    16     8 */
	my_svc_bool                (*security_context_destroy)(class Security_context *); /*    24     8 */
	my_svc_bool                (*security_context_copy)(class Security_context *, class Security_context * *); /*    32     8 */
	my_svc_bool                (*security_context_lookup)(class Security_context *, const char  *, const char  *, const char  *, const char  *); /*    40     8 */
	my_svc_bool                (*security_context_get_option)(class Security_context *, const char  *, void *); /*    48     8 */
	my_svc_bool                (*security_context_set_option)(class Security_context *, const char  *, void *); /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct srv_session_info_service_st {
	class THD *                (*get_thd)(MYSQL_SESSION); /*     0     8 */
	my_thread_id               (*get_session_id)(MYSQL_SESSION); /*     8     8 */
	LEX_CSTRING                (*get_current_db)(MYSQL_SESSION); /*    16     8 */
	uint16_t                   (*get_client_port)(MYSQL_SESSION); /*    24     8 */
	int                        (*set_client_port)(MYSQL_SESSION, uint16_t); /*    32     8 */
	int                        (*set_connection_type)(MYSQL_SESSION, enum enum_vio_type); /*    40     8 */
	int                        (*killed)(MYSQL_SESSION); /*    48     8 */
	unsigned int               (*session_count)(void); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned int               (*thread_count)(const void  *); /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* last cacheline: 8 bytes */
};
struct thd_alloc_service_st {
	void *                     (*thd_alloc_func)(class THD *, size_t); /*     0     8 */
	void *                     (*thd_calloc_func)(class THD *, size_t); /*     8     8 */
	char *                     (*thd_strdup_func)(class THD *, const char  *); /*    16     8 */
	char *                     (*thd_strmake_func)(class THD *, const char  *, size_t); /*    24     8 */
	void *                     (*thd_memdup_func)(class THD *, const void  *, size_t); /*    32     8 */
	class MYSQL_LEX_STRING *   (*thd_make_lex_string_func)(class THD *, class MYSQL_LEX_STRING *, const char  *, size_t, int); /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct thd_wait_service_st {
	void                       (*thd_wait_begin_func)(class THD *, int); /*     0     8 */
	void                       (*thd_wait_end_func)(class THD *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PSI_error_service_v1 {
	log_error_v1_t             log_error;            /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_table_locker_state {
	unsigned int               m_flags;              /*     0     4 */
	enum PSI_table_io_operation m_io_operation;      /*     4     4 */
	class PSI_table *          m_table;              /*     8     8 */
	class PSI_table_share *    m_table_share;        /*    16     8 */
	class PSI_thread *         m_thread;             /*    24     8 */
	long long unsigned int     m_timer_start;        /*    32     8 */
	long long unsigned int     (*m_timer)(void);     /*    40     8 */
	void *                     m_wait;               /*    48     8 */
	unsigned int               m_index;              /*    56     4 */

	/* size: 64, cachelines: 1, members: 9 */
	/* padding: 4 */
};
struct TABLE_SHARE {
	enum Schema_read_only {
		NOT_SET = 0,
		RO_OFF  = 1,
		RO_ON   = 2,
	};

	void TABLE_SHARE(class TABLE_SHARE *);

	void TABLE_SHARE(class TABLE_SHARE *, long unsigned int, bool);

	class malloc_unordered_map<unsigned int, const histograms::Histogram*, std::hash<unsigned int>, std::equal_to<unsigned int> > * m_histograms; /*     0     8 */
	const class Histogram  * find_histogram(const class TABLE_SHARE  *, uint);

	TABLE_CATEGORY             table_category;       /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Field**> * name_hash; /*    16     8 */
	struct MEM_ROOT            mem_root;             /*    24    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	class MEM_ROOT *           alloc_for_tmp_file_handler; /*   104     8 */
	struct TYPELIB             keynames;             /*   112    32 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class TYPELIB *            intervals;            /*   144     8 */
	struct mysql_mutex_t       LOCK_ha_data;         /*   152    48 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	class TABLE_SHARE *        next;                 /*   200     8 */
	class TABLE_SHARE * *      prev;                 /*   208     8 */
	class Table_cache_element * * cache_element;     /*   216     8 */
	class Field * *            field;                /*   224     8 */
	class Field * *            found_next_number_field; /*   232     8 */
	class KEY *                key_info;             /*   240     8 */
	uint *                     blob_field;           /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uchar *                    default_values;       /*   256     8 */
	LEX_STRING                 comment;              /*   264    16 */
	LEX_STRING                 compress;             /*   280    16 */
	LEX_STRING                 encrypt_type;         /*   296    16 */
	LEX_CSTRING                secondary_engine;     /*   312    16 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	uint32_t                   encryption_key_id;    /*   328     4 */
	bool                       was_encryption_key_id_set; /*   332     1 */
	bool                       explicit_encryption;  /*   333     1 */

	/* XXX 2 bytes hole, try to pack */

	const class CHARSET_INFO  * table_charset;       /*   336     8 */
	struct MY_BITMAP           all_set;              /*   344    32 */
	LEX_CSTRING                table_cache_key;      /*   376    16 */
	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
	LEX_CSTRING                db;                   /*   392    16 */
	LEX_CSTRING                table_name;           /*   408    16 */
	LEX_STRING                 path;                 /*   424    16 */
	LEX_CSTRING                normalized_path;      /*   440    16 */
	/* --- cacheline 7 boundary (448 bytes) was 8 bytes ago --- */
	LEX_STRING                 connect_string;       /*   456    16 */
	LEX_CSTRING                engine_attribute;     /*   472    16 */
	LEX_CSTRING                secondary_engine_attribute; /*   488    16 */
	Key_map                    keys_in_use;          /*   504     8 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	Key_map                    visible_indexes;      /*   512     8 */
	Key_map                    keys_for_keyread;     /*   520     8 */
	ha_rows                    min_rows;             /*   528     8 */
	ha_rows                    max_rows;             /*   536     8 */
	ulong                      avg_row_length;       /*   544     8 */
	ulong                      mysql_version;        /*   552     8 */
	ulong                      reclength;            /*   560     8 */
	ulong                      stored_rec_length;    /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	ulonglong                  autoextend_size;      /*   576     8 */
	plugin_ref                 db_plugin;            /*   584     8 */
	class handlerton * db_type(const class TABLE_SHARE  *);

	enum row_type              row_type;             /*   592     4 */
	enum row_type              real_row_type;        /*   596     4 */
	enum tmp_table_type        tmp_table;            /*   600     4 */
	uint                       tmp_handler_count;    /*   604     4 */
	uint                       tmp_open_count;       /*   608     4 */
	uint32_t                   key_block_size;       /*   612     4 */
	uint                       stats_sample_pages;   /*   616     4 */
	enum enum_stats_auto_recalc stats_auto_recalc;   /*   620     4 */
	uint                       null_bytes;           /*   624     4 */
	uint                       last_null_bit_pos;    /*   628     4 */
	uint                       fields;               /*   632     4 */
	uint                       rec_buff_length;      /*   636     4 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	uint                       keys;                 /*   640     4 */
	uint                       key_parts;            /*   644     4 */
	uint                       max_key_length;       /*   648     4 */
	uint                       max_unique_length;    /*   652     4 */
	uint                       total_key_length;     /*   656     4 */
	bool                       is_distinct;          /*   660     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       null_fields;          /*   664     4 */
	uint                       blob_fields;          /*   668     4 */
	uint                       varchar_fields;       /*   672     4 */
	uint                       first_unused_tmp_key; /*   676     4 */
	uint                       max_tmp_keys;         /*   680     4 */
	uint                       max_tmp_key_parts;    /*   684     4 */
	class Key_name *           key_names;            /*   688     8 */
	ulong *                    base_rec_per_key;     /*   696     8 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	rec_per_key_t *            base_rec_per_key_float; /*   704     8 */
	uint                       db_create_options;    /*   712     4 */
	uint                       db_options_in_use;    /*   716     4 */
	uint                       rowid_field_offset;   /*   720     4 */
	uint                       primary_key;          /*   724     4 */
	uint                       next_number_index;    /*   728     4 */
	uint                       next_number_key_offset; /*   732     4 */
	uint                       next_number_keypart;  /*   736     4 */
	bool                       error;                /*   740     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       column_bitmap_size;   /*   744     4 */
	uint                       vfields;              /*   748     4 */
	uint                       gen_def_field_count;  /*   752     4 */
	bool                       system;               /*   756     1 */
	bool                       db_low_byte_first;    /*   757     1 */
	bool                       crashed;              /*   758     1 */
	bool                       is_view;              /*   759     1 */
	bool                       m_open_in_progress;   /*   760     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 12 boundary (768 bytes) --- */
	class Table_id            table_map_id;          /*   768     8 */
	int                        cached_row_logging_check; /*   776     4 */
	enum ha_storage_media      default_storage_media; /*   780     4 */
	const char  *              tablespace;           /*   784     8 */
	class partition_info *     m_part_info;          /*   792     8 */
	bool                       auto_partitioned;     /*   800     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     partition_info_str;   /*   808     8 */
	uint                       partition_info_str_len; /*   816     4 */

	/* XXX 4 bytes hole, try to pack */

	const class TABLE_FIELD_DEF  * table_field_def_cache; /*   824     8 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	class Handler_share *      ha_share;             /*   832     8 */
	PSI_table_share *          m_psi;                /*   840     8 */
	Wait_for_flush_list        m_flush_tickets;      /*   848     8 */
	const class View  *        view_object;          /*   856     8 */
	class Table *              tmp_table_def;        /*   864     8 */
	bool                       rfr_lookup_warning;   /*   872     1 */

	/* XXX 7 bytes hole, try to pack */

	class Query_block *        owner_of_possible_tmp_keys; /*   880     8 */
	uint                       foreign_keys;         /*   888     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 14 boundary (896 bytes) --- */
	TABLE_SHARE_FOREIGN_KEY_INFO * foreign_key;      /*   896     8 */
	uint                       foreign_key_parents;  /*   904     4 */

	/* XXX 4 bytes hole, try to pack */

	TABLE_SHARE_FOREIGN_KEY_PARENT_INFO * foreign_key_parent; /*   912     8 */
	Sql_check_constraint_share_list * check_constraint_share_list; /*   920     8 */
	enum Schema_read_only      schema_read_only;     /*   928     4 */
	void set_table_cache_key(class TABLE_SHARE *, char *, size_t);

	void set_table_cache_key(class TABLE_SHARE *, char *, const char  *, size_t);

	ulonglong get_table_def_version(const class TABLE_SHARE  *);

	long unsigned int version(const class TABLE_SHARE  *);

	void clear_version(class TABLE_SHARE *);

	bool has_old_version(const class TABLE_SHARE  *);

	enum enum_table_ref_type get_table_ref_type(const class TABLE_SHARE  *);

	ulonglong get_table_ref_version(const class TABLE_SHARE  *);

	bool is_missing_primary_key(const class TABLE_SHARE  *);

	uint find_first_unused_tmp_key(class TABLE_SHARE *, const Key_map  &);

	bool visit_subgraph(class TABLE_SHARE *, class Wait_for_flush *, class MDL_wait_for_graph_visitor *);

	bool wait_for_old_version(class TABLE_SHARE *, class THD *, class timespec *, uint);

	Key_map usable_indexes(const class TABLE_SHARE  *, const class THD  *);

	void destroy(class TABLE_SHARE *);

	unsigned int ref_count(const class TABLE_SHARE  *);

	unsigned int increment_ref_count(class TABLE_SHARE *);

	unsigned int decrement_ref_count(class TABLE_SHARE *);

	bool is_primary_engine(const class TABLE_SHARE  *);

	bool is_secondary_engine(const class TABLE_SHARE  *);

	bool has_secondary_engine(const class TABLE_SHARE  *);

	bool is_referenced_by_foreign_key(const class TABLE_SHARE  *);

	bool has_compressed_columns(const class TABLE_SHARE  *);

private:

	unsigned int               m_ref_count;          /*   932     4 */
	long unsigned int          m_version;            /*   936     8 */
	bool                       m_secondary_engine;   /*   944     1 */

	/* size: 952, cachelines: 15, members: 112 */
	/* sum members: 900, holes: 10, sum holes: 45 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 56 bytes */
};
struct PSI_table_service_v1 {
	get_table_share_v1_t       get_table_share;      /*     0     8 */
	release_table_share_v1_t   release_table_share;  /*     8     8 */
	drop_table_share_v1_t      drop_table_share;     /*    16     8 */
	open_table_v1_t            open_table;           /*    24     8 */
	unbind_table_v1_t          unbind_table;         /*    32     8 */
	rebind_table_v1_t          rebind_table;         /*    40     8 */
	close_table_v1_t           close_table;          /*    48     8 */
	start_table_io_wait_v1_t   start_table_io_wait;  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	end_table_io_wait_v1_t     end_table_io_wait;    /*    64     8 */
	start_table_lock_wait_v1_t start_table_lock_wait; /*    72     8 */
	end_table_lock_wait_v1_t   end_table_lock_wait;  /*    80     8 */
	unlock_table_v1_t          unlock_table;         /*    88     8 */

	/* size: 96, cachelines: 2, members: 12 */
	/* last cacheline: 32 bytes */
};
struct get_opt_arg_source {
	char                       m_path_name[512];     /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	enum enum_variable_source  m_source;             /*   512     4 */

	/* size: 516, cachelines: 9, members: 2 */
	/* last cacheline: 4 bytes */
};
struct my_option {
	const char  *              name;                 /*     0     8 */
	int                        id;                   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              comment;              /*    16     8 */
	void *                     value;                /*    24     8 */
	void *                     u_max_value;          /*    32     8 */
	class TYPELIB *            typelib;              /*    40     8 */
	ulong                      var_type;             /*    48     8 */
	enum get_opt_arg_type      arg_type;             /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	longlong                   def_value;            /*    64     8 */
	longlong                   min_value;            /*    72     8 */
	ulonglong                  max_value;            /*    80     8 */
	class get_opt_arg_source * arg_source;           /*    88     8 */
	long int                   block_size;           /*    96     8 */
	void *                     app_type;             /*   104     8 */

	/* size: 112, cachelines: 2, members: 14 */
	/* sum members: 104, holes: 2, sum holes: 8 */
	/* last cacheline: 48 bytes */
};
struct TYPELIB {
	size_t                     count;                /*     0     8 */
	const char  *              name;                 /*     8     8 */
	const char  * *            type_names;           /*    16     8 */
	unsigned int *             type_lengths;         /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct KeyringEncryptionKeyIdInfo {
	void KeyringEncryptionKeyIdInfo(class KeyringEncryptionKeyIdInfo *, bool, EncryptionKeyId);

	void KeyringEncryptionKeyIdInfo(class KeyringEncryptionKeyIdInfo *);

	bool                       was_encryption_key_id_set; /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	EncryptionKeyId            id;                   /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* sum members: 5, holes: 1, sum holes: 3 */
	/* last cacheline: 8 bytes */
};
struct MY_BITMAP {
	my_bitmap_map *            bitmap;               /*     0     8 */
	uint                       n_bits;               /*     8     4 */
	my_bitmap_map              last_word_mask;       /*    12     4 */
	my_bitmap_map *            last_word_ptr;        /*    16     8 */
	class mysql_mutex_t *      mutex;                /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
class KEY_CREATE_INFO {
public:

	enum ha_key_alg            algorithm;            /*     0     4 */
	bool                       is_algorithm_explicit; /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	ulong                      block_size;           /*     8     8 */
	LEX_CSTRING                parser_name;          /*    16    16 */
	LEX_CSTRING                comment;              /*    32    16 */
	bool                       is_visible;           /*    48     1 */

	/* XXX 7 bytes hole, try to pack */
	void KEY_CREATE_INFO(class KEY_CREATE_INFO *);

	void KEY_CREATE_INFO(class KEY_CREATE_INFO *, bool);


	LEX_CSTRING                m_engine_attribute;   /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	LEX_CSTRING                m_secondary_engine_attribute; /*    72    16 */

	/* size: 88, cachelines: 2, members: 8 */
	/* sum members: 78, holes: 2, sum holes: 10 */
	/* last cacheline: 24 bytes */
};
class KEY_PART_INFO {
public:

	class Field *              field;                /*     0     8 */
	uint                       offset;               /*     8     4 */
	uint                       null_offset;          /*    12     4 */
	uint16                     length;               /*    16     2 */
	uint16                     store_length;         /*    18     2 */
	uint16                     fieldnr;              /*    20     2 */
	uint16                     key_part_flag;        /*    22     2 */
	uint8                      type;                 /*    24     1 */
	uint8                      null_bit;             /*    25     1 */
	bool                       bin_cmp;              /*    26     1 */
	void init_from_field(class KEY_PART_INFO *, class Field *);

	void init_flags(class KEY_PART_INFO *);


	/* size: 32, cachelines: 1, members: 10 */
	/* padding: 5 */
	/* last cacheline: 32 bytes */
};
class KEY {
public:

	uint                       key_length;           /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      flags;                /*     8     8 */
	ulong                      actual_flags;         /*    16     8 */
	uint                       user_defined_key_parts; /*    24     4 */
	uint                       actual_key_parts;     /*    28     4 */
	uint                       unused_key_parts;     /*    32     4 */
	uint                       usable_key_parts;     /*    36     4 */
	uint                       block_size;           /*    40     4 */
	enum ha_key_alg            algorithm;            /*    44     4 */
	bool                       is_algorithm_explicit; /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	plugin_ref                 parser;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	LEX_CSTRING                parser_name;          /*    64    16 */
	class KEY_PART_INFO *      key_part;             /*    80     8 */
	const char  *              name;                 /*    88     8 */
	ulong *                    rec_per_key;          /*    96     8 */
	bool is_functional_index(const class KEY  *);

	LEX_CSTRING                engine_attribute;     /*   104    16 */
	LEX_CSTRING                secondary_engine_attribute; /*   120    16 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	double                     m_in_memory_estimate; /*   136     8 */
	rec_per_key_t *            rec_per_key_float;    /*   144     8 */
	bool                       is_visible;           /*   152     1 */

	/* XXX 7 bytes hole, try to pack */

	class TABLE *              table;                /*   160     8 */
	LEX_CSTRING                comment;              /*   168    16 */
	bool has_records_per_key(const class KEY  *, uint);

	rec_per_key_t records_per_key(const class KEY  *, uint);

	void set_records_per_key(class KEY *, uint, rec_per_key_t);

	bool supports_records_per_key(const class KEY  *);

	void set_rec_per_key_array(class KEY *, ulong *, rec_per_key_t *);

	double in_memory_estimate(const class KEY  *);

	void set_in_memory_estimate(class KEY *, double);


	/* size: 184, cachelines: 3, members: 22 */
	/* sum members: 166, holes: 3, sum holes: 18 */
	/* last cacheline: 56 bytes */
};
struct sdi_key_t {
	uint32                     type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64                     id;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct sdi_vector_t {
	sdi_container              m_vec;                /*     0    24 */

	/* size: 24, cachelines: 1, members: 1 */
	/* last cacheline: 24 bytes */
};
class st_alter_tablespace {
public:

	const char  *              tablespace_name;      /*     0     8 */
	const char  *              logfile_group_name;   /*     8     8 */
	enum ts_command_type       ts_cmd_type;          /*    16     4 */
	enum ts_alter_tablespace_type ts_alter_tablespace_type; /*    20     4 */
	const char  *              data_file_name;       /*    24     8 */
	const char  *              undo_file_name;       /*    32     8 */
	ulonglong                  extent_size;          /*    40     8 */
	ulonglong                  undo_buffer_size;     /*    48     8 */
	ulonglong                  redo_buffer_size;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  initial_size;         /*    64     8 */
	class Nullable<long long unsigned int> autoextend_size; /*    72    16 */
	ulonglong                  max_size;             /*    88     8 */
	ulonglong                  file_block_size;      /*    96     8 */
	uint                       nodegroup_id;         /*   104     4 */
	bool                       wait_until_completed; /*   108     1 */

	/* XXX 3 bytes hole, try to pack */

	const char  *              ts_comment;           /*   112     8 */
	const char  *              encryption;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	bool                       explicit_encryption;  /*   128     1 */

	/* XXX 3 bytes hole, try to pack */

	struct KeyringEncryptionKeyIdInfo encryption_key_id; /*   132     8 */
	bool is_tablespace_command(class st_alter_tablespace *);

	void st_alter_tablespace(class st_alter_tablespace *, const char  *, const char  *, enum ts_command_type, enum ts_alter_tablespace_type, const char  *, const char  *, const class Tablespace_options  &);


	/* size: 144, cachelines: 3, members: 19 */
	/* sum members: 134, holes: 2, sum holes: 6 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct Ha_clone_file {
	enum {
		FILE_HANDLE = 0,
		FILE_DESC   = 1,
	};

	union {
		int                        file_desc;            /*     0     4 */
		void *                     file_handle;          /*     0     8 */
	};

	enum {
		FILE_HANDLE = 0,
		FILE_DESC   = 1,
	} type;                                          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		int                file_desc;            /*     8     4 */
		void *             file_handle;          /*     8     8 */
	};                                               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct Ha_fk_column_type {
	enum enum_column_types     type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     char_length;          /*     8     8 */
	const class CHARSET_INFO  * field_charset;       /*    16     8 */
	size_t                     elements_count;       /*    24     8 */
	uint                       numeric_scale;        /*    32     4 */
	bool                       is_unsigned;          /*    36     1 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 33, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* last cacheline: 40 bytes */
};
class List<MYSQL_LEX_STRING> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<MYSQL_LEX_STRING> *);

	void List(class List<MYSQL_LEX_STRING> *, const class List<MYSQL_LEX_STRING>  &);

	class List<MYSQL_LEX_STRING> & operator=(class List<MYSQL_LEX_STRING> *, const class List<MYSQL_LEX_STRING>  &);

	void List(class List<MYSQL_LEX_STRING> *, const class List<MYSQL_LEX_STRING>  &, class MEM_ROOT *);

	bool push_back(class List<MYSQL_LEX_STRING> *, class MYSQL_LEX_STRING *);

	bool push_back(class List<MYSQL_LEX_STRING> *, class MYSQL_LEX_STRING *, class MEM_ROOT *);

	bool push_front(class List<MYSQL_LEX_STRING> *, class MYSQL_LEX_STRING *);

	bool push_front(class List<MYSQL_LEX_STRING> *, class MYSQL_LEX_STRING *, class MEM_ROOT *);

	class MYSQL_LEX_STRING * head(class List<MYSQL_LEX_STRING> *);

	const class MYSQL_LEX_STRING  * head(const class List<MYSQL_LEX_STRING>  *);

	class MYSQL_LEX_STRING * * head_ref(class List<MYSQL_LEX_STRING> *);

	class MYSQL_LEX_STRING * pop(class List<MYSQL_LEX_STRING> *);

	void concat(class List<MYSQL_LEX_STRING> *, class List<MYSQL_LEX_STRING> *);

	void disjoin(class List<MYSQL_LEX_STRING> *, class List<MYSQL_LEX_STRING> *);

	void prepend(class List<MYSQL_LEX_STRING> *, class List<MYSQL_LEX_STRING> *);

	void delete_elements(class List<MYSQL_LEX_STRING> *);

	void destroy_elements(class List<MYSQL_LEX_STRING> *);

	class MYSQL_LEX_STRING * operator[](const class List<MYSQL_LEX_STRING>  *, uint);

	void replace(class List<MYSQL_LEX_STRING> *, uint, class MYSQL_LEX_STRING *);

	bool swap_elts(class List<MYSQL_LEX_STRING> *, uint, uint);

	typedef struct List_STL_Iterator<MYSQL_LEX_STRING> iterator;

	iterator begin(class List<MYSQL_LEX_STRING> *);

	iterator end(class List<MYSQL_LEX_STRING> *);

	typedef struct List_STL_Iterator<const MYSQL_LEX_STRING> const_iterator;

	const_iterator begin(const class List<MYSQL_LEX_STRING>  *);

	const_iterator end(const class List<MYSQL_LEX_STRING>  *);

	const_iterator cbegin(const class List<MYSQL_LEX_STRING>  *);

	const_iterator cend(const class List<MYSQL_LEX_STRING>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class ha_statistics {
public:

	ulonglong                  data_file_length;     /*     0     8 */
	ulonglong                  max_data_file_length; /*     8     8 */
	ulonglong                  index_file_length;    /*    16     8 */
	ulonglong                  max_index_file_length; /*    24     8 */
	ulonglong                  delete_length;        /*    32     8 */
	ulonglong                  auto_increment_value; /*    40     8 */
	ha_rows                    records;              /*    48     8 */
	ha_rows                    deleted;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulong                      mean_rec_length;      /*    64     8 */
	time_t                     create_time;          /*    72     8 */
	ulong                      check_time;           /*    80     8 */
	ulong                      update_time;          /*    88     8 */
	uint                       block_size;           /*    96     4 */
	uint                       mrr_length_per_rec;   /*   100     4 */
	double                     table_in_mem_estimate; /*   104     8 */
	void ha_statistics(class ha_statistics *);


	/* size: 112, cachelines: 2, members: 15 */
	/* last cacheline: 48 bytes */
};
class ha_tablespace_statistics {
public:

	void ha_tablespace_statistics(class ha_tablespace_statistics *);

	ulonglong                  m_id;                 /*     0     8 */
	String_type                m_type;               /*     8    32 */
	String_type                m_logfile_group_name; /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	ulonglong                  m_logfile_group_number; /*    72     8 */
	ulonglong                  m_free_extents;       /*    80     8 */
	ulonglong                  m_total_extents;      /*    88     8 */
	ulonglong                  m_extent_size;        /*    96     8 */
	ulonglong                  m_initial_size;       /*   104     8 */
	ulonglong                  m_maximum_size;       /*   112     8 */
	ulonglong                  m_autoextend_size;    /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ulonglong                  m_version;            /*   128     8 */
	String_type                m_row_format;         /*   136    32 */
	ulonglong                  m_data_free;          /*   168     8 */
	String_type                m_status;             /*   176    32 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	String_type                m_extra;              /*   208    32 */

	/* size: 240, cachelines: 4, members: 15 */
	/* last cacheline: 48 bytes */
};
class Ha_clone_cbk {
public:

	int ()(void) * *           _vptr.Ha_clone_cbk;   /*     0     8 */
protected:

	void Ha_clone_cbk(class Ha_clone_cbk *);

public:

	virtual int file_cbk(class Ha_clone_cbk *, class Ha_clone_file, uint);

	virtual int buffer_cbk(class Ha_clone_cbk *, uchar *, uint);

	virtual int apply_file_cbk(class Ha_clone_cbk *, class Ha_clone_file);

	virtual int apply_buffer_cbk(class Ha_clone_cbk *, uchar * &, uint &);

	virtual void ~Ha_clone_cbk(class Ha_clone_cbk *, int);

	void set_hton(class Ha_clone_cbk *, class handlerton *);

	class handlerton * get_hton(class Ha_clone_cbk *);

	void set_client_buffer_size(class Ha_clone_cbk *, uint);

	uint get_client_buffer_size(class Ha_clone_cbk *);

	void set_loc_index(class Ha_clone_cbk *, uint);

	uint get_loc_index(class Ha_clone_cbk *);

	void set_data_desc(class Ha_clone_cbk *, const uchar  *, uint);

	const uchar  * get_data_desc(class Ha_clone_cbk *, uint *);

	const char  * get_source_name(class Ha_clone_cbk *);

	void set_source_name(class Ha_clone_cbk *, const char  *);

	const char  * get_dest_name(class Ha_clone_cbk *);

	void set_dest_name(class Ha_clone_cbk *, const char  *);

	void clear_flags(class Ha_clone_cbk *);

	void set_ack(class Ha_clone_cbk *);

	bool is_ack_needed(const class Ha_clone_cbk  *);

	void set_os_buffer_cache(class Ha_clone_cbk *);

	bool is_os_buffer_cache(const class Ha_clone_cbk  *);

	void set_zero_copy(class Ha_clone_cbk *);

	bool is_zero_copy(const class Ha_clone_cbk  *);

	void set_secure(class Ha_clone_cbk *);

	bool is_secure(const class Ha_clone_cbk  *);

	void mark_state_change(class Ha_clone_cbk *, uint64_t);

	bool is_state_change(class Ha_clone_cbk *, uint64_t &);

	class handlerton *         m_hton;               /*     8     8 */
	uint                       m_loc_idx;            /*    16     4 */
	uint                       m_client_buff_size;   /*    20     4 */
	const uchar  *             m_data_desc;          /*    24     8 */
	uint                       m_desc_len;           /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_src_name;           /*    40     8 */
	const char  *              m_dest_name;          /*    48     8 */
	uint64_t                   m_state_estimate;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        m_flag;               /*    64     4 */
	const int                  HA_CLONE_ACK;         /*    68     4 */
	const int                  HA_CLONE_FILE_CACHE;  /*    72     4 */
	const int                  HA_CLONE_ZERO_COPY;   /*    76     4 */
	const int                  HA_CLONE_SECURE;      /*    80     4 */
	const int                  HA_CLONE_STATE_CHANGE; /*    84     4 */
	/* vtable has 4 entries: {
	   [0] = file_cbk((null)), 
	   [1] = buffer_cbk((null)), 
	   [2] = apply_file_cbk((null)), 
	   [3] = apply_buffer_cbk((null)), 
	} */
	/* size: 88, cachelines: 2, members: 15 */
	/* sum members: 84, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct Clone_interface_t {
	Clone_capability_t         clone_capability;     /*     0     8 */
	Clone_begin_t              clone_begin;          /*     8     8 */
	Clone_copy_t               clone_copy;           /*    16     8 */
	Clone_ack_t                clone_ack;            /*    24     8 */
	Clone_end_t                clone_end;            /*    32     8 */
	Clone_apply_begin_t        clone_apply_begin;    /*    40     8 */
	Clone_apply_t              clone_apply;          /*    48     8 */
	Clone_apply_end_t          clone_apply_end;      /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct Page_track_t {
	page_track_start_t         start;                /*     0     8 */
	page_track_stop_t          stop;                 /*     8     8 */
	page_track_purge_t         purge;                /*    16     8 */
	page_track_get_page_ids_t  get_page_ids;         /*    24     8 */
	page_track_get_num_page_ids_t get_num_page_ids;  /*    32     8 */
	page_track_get_status_t    get_status;           /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
class SQL_I_List<TABLE_LIST> {
public:

	uint                       elements;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class TABLE_LIST *         first;                /*     8     8 */
	class TABLE_LIST * *       next;                 /*    16     8 */
	void SQL_I_List(class SQL_I_List<TABLE_LIST> *);

	void SQL_I_List(class SQL_I_List<TABLE_LIST> *, const class SQL_I_List<TABLE_LIST>  &);

	void SQL_I_List(class SQL_I_List<TABLE_LIST> *, );

	void clear(class SQL_I_List<TABLE_LIST> *);

	void link_in_list(class SQL_I_List<TABLE_LIST> *, class TABLE_LIST *, class TABLE_LIST * *);

	void save_and_clear(class SQL_I_List<TABLE_LIST> *, class SQL_I_List<TABLE_LIST> *);

	void push_front(class SQL_I_List<TABLE_LIST> *, class SQL_I_List<TABLE_LIST> *);

	void push_back(class SQL_I_List<TABLE_LIST> *, class SQL_I_List<TABLE_LIST> *);

	uint size(const class SQL_I_List<TABLE_LIST>  *);

	class SQL_I_List<TABLE_LIST> & operator=(class SQL_I_List<TABLE_LIST> *, class SQL_I_List<TABLE_LIST> &);

	class SQL_I_List<TABLE_LIST> & operator=(class SQL_I_List<TABLE_LIST> *, );


	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct HA_CREATE_INFO {
	const class CHARSET_INFO  * table_charset;       /*     0     8 */
	const class CHARSET_INFO  * default_table_charset; /*     8     8 */
	bool                       schema_read_only;     /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	LEX_STRING                 connect_string;       /*    24    16 */
	const char  *              password;             /*    40     8 */
	const char  *              tablespace;           /*    48     8 */
	LEX_STRING                 comment;              /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	LEX_STRING                 compress;             /*    72    16 */
	LEX_STRING                 encrypt_type;         /*    88    16 */
	EncryptionKeyId            encryption_key_id;    /*   104     4 */
	bool                       was_encryption_key_id_set; /*   108     1 */
	bool                       explicit_encryption;  /*   109     1 */

	/* XXX 2 bytes hole, try to pack */

	LEX_CSTRING                secondary_engine;     /*   112    16 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	const char  *              data_file_name;       /*   128     8 */
	const char  *              index_file_name;      /*   136     8 */
	const char  *              alias;                /*   144     8 */
	ulonglong                  max_rows;             /*   152     8 */
	ulonglong                  min_rows;             /*   160     8 */
	ulonglong                  auto_increment_value; /*   168     8 */
	ulong                      table_options;        /*   176     8 */
	ulong                      avg_row_length;       /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	uint64_t                   used_fields;          /*   192     8 */
	uint32_t                   key_block_size;       /*   200     4 */
	uint                       stats_sample_pages;   /*   204     4 */
	enum enum_stats_auto_recalc stats_auto_recalc;   /*   208     4 */

	/* XXX 4 bytes hole, try to pack */

	class SQL_I_List<TABLE_LIST> merge_list;         /*   216    24 */
	class handlerton *         db_type;              /*   240     8 */
	enum row_type              row_type;             /*   248     4 */
	uint                       null_bits;            /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint                       options;              /*   256     4 */
	uint                       merge_insert_method;  /*   260     4 */
	enum ha_storage_media      storage_media;        /*   264     4 */
	bool                       m_hidden;             /*   268     1 */
	bool                       m_transactional_ddl;  /*   269     1 */

	/* XXX 2 bytes hole, try to pack */

	LEX_CSTRING                engine_attribute;     /*   272    16 */
	LEX_CSTRING                secondary_engine_attribute; /*   288    16 */
	ulonglong                  m_implicit_tablespace_autoextend_size; /*   304     8 */
	bool                       m_implicit_tablespace_autoextend_size_change; /*   312     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 5 boundary (320 bytes) --- */
	string                     actual_user_table_name; /*   320    32 */
	void init_create_options_from_share(class HA_CREATE_INFO *, const class TABLE_SHARE  *, uint64_t);

	class Item *               zip_dict_name;        /*   352     8 */

	/* size: 360, cachelines: 6, members: 40 */
	/* sum members: 338, holes: 5, sum holes: 22 */
	/* last cacheline: 40 bytes */
};
class partition_info {
	union {
		longlong *                 range_int_array;      /*     0     8 */
		LIST_PART_ENTRY *          list_array;           /*     0     8 */
		part_column_list_val *     range_col_array;      /*     0     8 */
		part_column_list_val *     list_col_array;       /*     0     8 */
	};

	enum enum_can_prune {
		PRUNE_NO       = 0,
		PRUNE_DEFAULTS = 1,
		PRUNE_YES      = 2,
	};

public:

	class List<partition_element> partitions;        /*     0    24 */
	class List<partition_element> temp_partitions;   /*    24    24 */
	class List<char>          part_field_list;       /*    48    24 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	class List<char>          subpart_field_list;    /*    72    24 */
	get_part_id_func           get_partition_id;     /*    96     8 */
	get_part_id_func           get_part_partition_id; /*   104     8 */
	get_subpart_id_func        get_subpartition_id;  /*   112     8 */
	get_part_id_func           get_part_partition_id_charset; /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	get_subpart_id_func        get_subpartition_id_charset; /*   128     8 */
	class Field * *            part_field_array;     /*   136     8 */
	class Field * *            subpart_field_array;  /*   144     8 */
	class Field * *            part_charset_field_array; /*   152     8 */
	class Field * *            subpart_charset_field_array; /*   160     8 */
	class Field * *            full_part_field_array; /*   168     8 */
	struct MY_BITMAP           full_part_field_set;  /*   176    32 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	uchar * *                  part_field_buffers;   /*   208     8 */
	uchar * *                  subpart_field_buffers; /*   216     8 */
	uchar * *                  restore_part_field_ptrs; /*   224     8 */
	uchar * *                  restore_subpart_field_ptrs; /*   232     8 */
	class Item *               part_expr;            /*   240     8 */
	class Item *               subpart_expr;         /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	class Item *               item_list;            /*   256     8 */
	struct MY_BITMAP           read_partitions;      /*   264    32 */
	struct MY_BITMAP           lock_partitions;      /*   296    32 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	bool                       bitmaps_are_initialized; /*   328     1 */

	/* XXX 7 bytes hole, try to pack */

	union {
		longlong *         range_int_array;      /*   336     8 */
		LIST_PART_ENTRY *  list_array;           /*   336     8 */
		part_column_list_val * range_col_array;  /*   336     8 */
		part_column_list_val * list_col_array;   /*   336     8 */
	};                                               /*   336     8 */
	get_partitions_in_range_iter get_part_iter_for_interval; /*   344     8 */
	get_partitions_in_range_iter get_subpart_iter_for_interval; /*   352     8 */
	longlong                   err_value;            /*   360     8 */
	char *                     part_func_string;     /*   368     8 */
	char *                     subpart_func_string;  /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint                       num_columns;          /*   384     4 */

	/* XXX 4 bytes hole, try to pack */

	class TABLE *              table;                /*   392     8 */
	Key_map                    all_fields_in_PF;     /*   400     8 */
	Key_map                    all_fields_in_PPF;    /*   408     8 */
	Key_map                    all_fields_in_SPF;    /*   416     8 */
	Key_map                    some_fields_in_PF;    /*   424     8 */
	class handlerton *         default_engine_type;  /*   432     8 */
	enum partition_type        part_type;            /*   440     4 */
	enum partition_type        subpart_type;         /*   444     4 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	size_t                     part_func_len;        /*   448     8 */
	size_t                     subpart_func_len;     /*   456     8 */
	uint                       num_parts;            /*   464     4 */
	uint                       num_subparts;         /*   468     4 */
	uint                       num_list_values;      /*   472     4 */
	uint                       num_part_fields;      /*   476     4 */
	uint                       num_subpart_fields;   /*   480     4 */
	uint                       num_full_part_fields; /*   484     4 */
	uint                       has_null_part_id;     /*   488     4 */
	uint16                     linear_hash_mask;     /*   492     2 */

	/* XXX 2 bytes hole, try to pack */

	enum enum_key_algorithm    key_algorithm;        /*   496     4 */
	bool                       use_default_partitions; /*   500     1 */
	bool                       use_default_num_partitions; /*   501     1 */
	bool                       use_default_subpartitions; /*   502     1 */
	bool                       use_default_num_subpartitions; /*   503     1 */
	bool                       default_partitions_setup; /*   504     1 */
	bool                       defined_max_value;    /*   505     1 */
	bool                       list_of_part_fields;  /*   506     1 */
	bool                       list_of_subpart_fields; /*   507     1 */
	bool                       linear_hash_ind;      /*   508     1 */
	bool                       fixed;                /*   509     1 */
	bool                       is_auto_partitioned;  /*   510     1 */
	bool                       has_null_value;       /*   511     1 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	bool                       column_list;          /*   512     1 */
	bool                       is_pruning_completed; /*   513     1 */
	void partition_info(class partition_info *);

	class partition_info * get_clone(class partition_info *, class THD *, bool);

	class partition_info * get_full_clone(class partition_info *, class THD *);

	bool set_named_partition_bitmap(class partition_info *, const char  *, size_t);

	bool set_partition_bitmaps(class partition_info *, class TABLE_LIST *);

	bool set_read_partitions(class partition_info *, class List<String> *);

	bool is_sub_partitioned(const class partition_info  *);

	uint get_tot_partitions(const class partition_info  *);

	bool set_up_defaults_for_partitioning(class partition_info *, class Partition_handler *, class HA_CREATE_INFO *, uint);

	char * find_duplicate_field(class partition_info *);

	const char  * find_duplicate_name(class partition_info *);

	bool check_engine_mix(class partition_info *, class handlerton *, bool);

	bool check_range_constants(class partition_info *, class THD *);

	bool check_list_constants(class partition_info *, class THD *);

	bool check_partition_info(class partition_info *, class THD *, class handlerton * *, class handler *, class HA_CREATE_INFO *, bool);

	void print_no_partition_found(class partition_info *, class THD *, class TABLE *);

	void print_debug(class partition_info *, const char  *, uint *);

	class Item * get_column_item(class partition_info *, class Item *, class Field *);

	bool fix_partition_values(class partition_info *, part_elem_value *, class partition_element *, uint);

	bool fix_column_value_functions(class partition_info *, class THD *, part_elem_value *, uint);

	bool fix_parser_data(class partition_info *, class THD *);

	bool set_part_expr(class partition_info *, char *, class Item *, char *, bool);

	bool compare_column_values(const part_column_list_val  *, const part_column_list_val  *);

	bool set_up_charset_field_preps(class partition_info *);

	bool check_partition_field_length(class partition_info *);

	void set_show_version_string(class partition_info *, class String *);

	class partition_element * get_part_elem(class partition_info *, const char  *, uint32 *);

	void report_part_expr_error(class partition_info *, bool);

	bool set_used_partition(class partition_info *, class THD *, const class mem_root_deque<Item*>  &, const class mem_root_deque<Item*>  &, class COPY_INFO &, bool, class MY_BITMAP *);

	bool can_prune_insert(class partition_info *, class THD *, enum enum_duplicates, class COPY_INFO &, const class mem_root_deque<Item*>  &, const class mem_root_deque<Item*>  &, bool, enum enum_can_prune *, bool *, class MY_BITMAP *);

	bool has_same_partitioning(class partition_info *, class partition_info *);

	bool is_partition_used(const class partition_info  *, uint);

	bool is_partition_locked(const class partition_info  *, uint);

	uint num_partitions_used(class partition_info *);

	uint get_first_used_partition(const class partition_info  *);

	uint get_next_used_partition(const class partition_info  *, uint);

	bool same_key_column_order(class partition_info *, class List<Create_field> *);

	bool init_partition_bitmap(class partition_info *, class MY_BITMAP *, class MEM_ROOT *);

	bool set_up_default_partitions(class partition_info *, class Partition_handler *, class HA_CREATE_INFO *, uint);

	bool set_up_default_subpartitions(class partition_info *, class Partition_handler *, class HA_CREATE_INFO *);

	char * create_default_partition_names(class partition_info *, uint, uint);

	char * create_default_subpartition_name(class partition_info *, uint, const char  *);

	bool add_named_partition(class partition_info *, const char  *, size_t);

	bool is_fields_in_part_expr(class partition_info *, const class mem_root_deque<Item*>  &);

	bool is_full_part_expr_in_fields(class partition_info *, const class mem_root_deque<Item*>  &);


	/* size: 520, cachelines: 9, members: 65 */
	/* sum members: 501, holes: 3, sum holes: 13 */
	/* padding: 6 */
	/* last cacheline: 8 bytes */
};
class Bitmap<64> {
	ulonglong                  map;                  /*     0     8 */
public:

	void Bitmap(class Bitmap<64> *);

	void Bitmap(class Bitmap<64> *, uint);

	void init(class Bitmap<64> *);

	void init(class Bitmap<64> *, uint);

	uint length(const class Bitmap<64>  *);

	void set_bit(class Bitmap<64> *, uint);

	void clear_bit(class Bitmap<64> *, uint);

	void set_prefix(class Bitmap<64> *, uint);

	void set_all(class Bitmap<64> *);

	void clear_all(class Bitmap<64> *);

	void intersect(class Bitmap<64> *, const class Bitmap<64>  &);

	void intersect(class Bitmap<64> *, ulonglong);

	void intersect_extended(class Bitmap<64> *, ulonglong);

	void subtract(class Bitmap<64> *, const class Bitmap<64>  &);

	void merge(class Bitmap<64> *, const class Bitmap<64>  &);

	bool is_set(const class Bitmap<64>  *, uint);

	bool is_prefix(const class Bitmap<64>  *, uint);

	bool is_clear_all(const class Bitmap<64>  *);

	bool is_set_all(const class Bitmap<64>  *);

	bool is_subset(const class Bitmap<64>  *, const class Bitmap<64>  &);

	bool is_overlapping(const class Bitmap<64>  *, const class Bitmap<64>  &);

	bool operator==(const class Bitmap<64>  *, const class Bitmap<64>  &);

	bool operator!=(const class Bitmap<64>  *, const class Bitmap<64>  &);

	char * print(const class Bitmap<64>  *, char *);

	ulonglong to_ulonglong(const class Bitmap<64>  *);

	uint bits_set(const class Bitmap<64>  *);

	uint get_first_set(const class Bitmap<64>  *);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class TC_LOG {
	enum enum_result {
		RESULT_SUCCESS      = 0,
		RESULT_ABORTED      = 1,
		RESULT_INCONSISTENT = 2,
	};

public:

	void TC_LOG(class TC_LOG *, const class TC_LOG  &);

	int ()(void) * *           _vptr.TC_LOG;         /*     0     8 */
	bool using_heuristic_recover(class TC_LOG *);

	void TC_LOG(class TC_LOG *);

	virtual void ~TC_LOG(class TC_LOG *, int);

	virtual int open(class TC_LOG *, const char  *);

	virtual void close(class TC_LOG *);

	virtual enum enum_result commit(class TC_LOG *, class THD *, bool);

	virtual int rollback(class TC_LOG *, class THD *, bool);

	virtual int prepare(class TC_LOG *, class THD *, bool);

	virtual void xlock(class TC_LOG *);

	virtual void xunlock(class TC_LOG *);

	virtual void slock(class TC_LOG *);

	virtual void sunlock(class TC_LOG *);

	/* vtable has 9 entries: {
	   [2] = open((null)), 
	   [3] = close((null)), 
	   [4] = commit((null)), 
	   [5] = rollback((null)), 
	   [6] = prepare((null)), 
	   [7] = xlock((null)), 
	   [8] = xunlock((null)), 
	   [9] = slock((null)), 
	   [10] = sunlock((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Rpl_encryption {
	struct Rpl_encryption_key {
		string                     m_id;                 /*     0    32 */
		Key_string                 m_value;              /*    32    32 */

		/* size: 64, cachelines: 1, members: 2 */
	};

	/* tag__fprintf: const_type tag not supported! */;

	enum Keyring_status {
		SUCCESS                  = 0,
		KEYRING_ERROR_FETCHING   = 1,
		KEY_NOT_FOUND            = 2,
		UNEXPECTED_KEY_SIZE      = 3,
		UNEXPECTED_KEY_TYPE      = 4,
		KEY_EXISTS_UNEXPECTED    = 5,
		KEYRING_ERROR_GENERATING = 6,
		KEYRING_ERROR_STORING    = 7,
		KEYRING_ERROR_REMOVING   = 8,
	};

	enum Key_rotation_step {
		START                        = 0,
		DETERMINE_NEXT_SEQNO         = 1,
		GENERATE_NEW_MASTER_KEY      = 2,
		REMOVE_MASTER_KEY_INDEX      = 3,
		STORE_MASTER_KEY_INDEX       = 4,
		ROTATE_LOGS                  = 5,
		PURGE_UNUSED_ENCRYPTION_KEYS = 6,
		REMOVE_KEY_ROTATION_TAG      = 7,
	};

public:

	void Rpl_encryption(class Rpl_encryption *);

	void Rpl_encryption(class Rpl_encryption *, const class Rpl_encryption  &);

	void Rpl_encryption(class Rpl_encryption *, );

	class Rpl_encryption & operator=(class Rpl_encryption *, const class Rpl_encryption  &);

	class Rpl_encryption & operator=(class Rpl_encryption *, );

	void report_keyring_error(enum Keyring_status);

	void report_keyring_error(enum Keyring_status, const char  *);

	bool initialize(class Rpl_encryption *);

	bool remove_remaining_seqnos_from_keyring(class Rpl_encryption *);

	bool recover_master_key(class Rpl_encryption *);

	const class Rpl_encryption_key  get_master_key(class Rpl_encryption *);

	class pair<Rpl_encryption::Keyring_status, std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allo get_key(const string  &, const string  &);

	class pair<Rpl_encryption::Keyring_status, std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allo get_key(const string  &, const string  &, size_t);

	bool enable(class Rpl_encryption *, class THD *);

	void disable(class Rpl_encryption *, class THD *);

	bool is_enabled(class Rpl_encryption *);

	const bool  & get_enabled_var(class Rpl_encryption *);

	const bool  & get_master_key_rotation_at_startup_var(class Rpl_encryption *);

	bool purge_unused_keys(class Rpl_encryption *);

	bool rotate_master_key(class Rpl_encryption *, enum Key_rotation_step, uint32_t);

	static const char  *              SEQNO_KEY_TYPE; /*     0     0 */
	static const int                  SEQNO_KEY_LENGTH = 16; /*     0     0 */
	bool                       m_enabled;            /*     0     1 */
	bool                       m_rotate_at_startup;  /*     1     1 */
	bool                       m_master_key_recovered; /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   m_master_key_seqno;   /*     4     4 */
	struct Rpl_encryption_key  m_master_key;         /*     8    64 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	bool                       m_skip_logs_rotation; /*    72     1 */
	class tuple<Rpl_encryption::Keyring_status, void*, long unsigned int> fetch_key_from_keyring(const string  &, const string  &);

	void rotate_logs(class Rpl_encryption *, class THD *);

	class pair<Rpl_encryption::Keyring_status, unsigned int> get_seqno_from_keyring(class Rpl_encryption *, string);

	bool set_seqno_on_keyring(class Rpl_encryption *, string, uint32_t);

	bool remove_key_from_keyring(class Rpl_encryption *, string);

	string get_master_key_seqno_key_id(class Rpl_encryption *);

	class pair<Rpl_encryption::Keyring_status, unsigned int> get_master_key_seqno_from_keyring(class Rpl_encryption *);

	bool set_master_key_seqno_on_keyring(class Rpl_encryption *, uint32);

	bool remove_master_key_seqno_from_keyring(class Rpl_encryption *);

	string get_new_master_key_seqno_key_id(class Rpl_encryption *);

	string get_last_purged_master_key_seqno_key_id(class Rpl_encryption *);

	string get_old_master_key_seqno_key_id(class Rpl_encryption *);

	class pair<Rpl_encryption::Keyring_status, unsigned int> get_new_master_key_seqno_from_keyring(class Rpl_encryption *);

	class pair<Rpl_encryption::Keyring_status, unsigned int> get_old_master_key_seqno_from_keyring(class Rpl_encryption *);

	class pair<Rpl_encryption::Keyring_status, unsigned int> get_last_purged_master_key_seqno_from_keyring(class Rpl_encryption *);

	bool set_new_master_key_seqno_on_keyring(class Rpl_encryption *, uint32);

	bool set_last_purged_master_key_seqno_on_keyring(class Rpl_encryption *, uint32);

	bool set_old_master_key_seqno_on_keyring(class Rpl_encryption *, uint32);

	bool remove_new_master_key_seqno_from_keyring(class Rpl_encryption *);

	bool remove_last_purged_master_key_seqno_from_keyring(class Rpl_encryption *);

	bool remove_old_master_key_seqno_from_keyring(class Rpl_encryption *);

	bool generate_master_key_on_keyring(class Rpl_encryption *, uint32);


	/* size: 80, cachelines: 2, members: 6, static members: 2 */
	/* sum members: 72, holes: 1, sum holes: 1 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct LOG_INFO {
	char                       log_file_name[512];   /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	my_off_t                   index_file_offset;    /*   512     8 */
	my_off_t                   index_file_start_offset; /*   520     8 */
	my_off_t                   pos;                  /*   528     8 */
	bool                       fatal;                /*   536     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        entry_index;          /*   540     4 */
	int                        encrypted_header_size; /*   544     4 */
	void LOG_INFO(class LOG_INFO *);


	/* size: 552, cachelines: 9, members: 7 */
	/* sum members: 545, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> >  *, reference);

	typedef class pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> & reference;

	typedef const class pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> >  *, const_reference);

	typedef const class pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstrac, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstrac, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_table>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_tabl, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_tabl, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_tabl, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstract_tabl, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstrac);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Abstract_table* const, dd::cache::Cache_element<dd::Abstrac);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Abstract_table*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Abstract_table  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Abstract_table*>  *, reference);

	typedef const class Abstract_table  * & reference;

	typedef const class Abstract_table  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Abstract_table*>  *, const_reference);

	typedef const class Abstract_table  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Abstract_table*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Abstract_table*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Abstract_table*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Abstract_table*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Abstract_table*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Abstract_table*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Abstract_table*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Abstract_table*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Abstract_table*> & reference;

	typedef const class _Rb_tree_node<const dd::Abstract_table*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Abstract_table*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Abstract_table*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > , PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > , size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > , pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > , pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Abstract_table);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<dd::Primary_id_key> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class Primary_id_key * pointer;

public:

	pointer address(const class Malloc_allocator<dd::Primary_id_key>  *, reference);

	typedef class Primary_id_key & reference;

	typedef const class Primary_id_key  * const_pointer;

	const_pointer address(const class Malloc_allocator<dd::Primary_id_key>  *, const_reference);

	typedef const class Primary_id_key  & const_reference;

	void Malloc_allocator(class Malloc_allocator<dd::Primary_id_key> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<dd::Primary_id_key> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<dd::Primary_id_key> *, pointer, size_type);

	void destroy(class Malloc_allocator<dd::Primary_id_key> *, pointer);

	size_type max_size(const class Malloc_allocator<dd::Primary_id_key>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<dd::Primary_id_key>  *);

	struct rebind<std::_Rb_tree_node<dd::Primary_id_key> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<dd::Primary_id_key> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> >  *, reference);

	typedef class _Rb_tree_node<dd::Primary_id_key> & reference;

	typedef const class _Rb_tree_node<dd::Primary_id_key>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> >  *, const_reference);

	typedef const class _Rb_tree_node<dd::Primary_id_key>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<dd::Primary_id_key> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *, reference);

	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> & reference;

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *, const_reference);

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > >, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > >, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > >, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>*> > >, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Abstract_table>);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<dd::Item_name_key> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class Item_name_key * pointer;

public:

	pointer address(const class Malloc_allocator<dd::Item_name_key>  *, reference);

	typedef class Item_name_key & reference;

	typedef const class Item_name_key  * const_pointer;

	const_pointer address(const class Malloc_allocator<dd::Item_name_key>  *, const_reference);

	typedef const class Item_name_key  & const_reference;

	void Malloc_allocator(class Malloc_allocator<dd::Item_name_key> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<dd::Item_name_key> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<dd::Item_name_key> *, pointer, size_type);

	void destroy(class Malloc_allocator<dd::Item_name_key> *, pointer);

	size_type max_size(const class Malloc_allocator<dd::Item_name_key>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<dd::Item_name_key>  *);

	struct rebind<std::_Rb_tree_node<dd::Item_name_key> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<dd::Item_name_key> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> >  *, reference);

	typedef class _Rb_tree_node<dd::Item_name_key> & reference;

	typedef const class _Rb_tree_node<dd::Item_name_key>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> >  *, const_reference);

	typedef const class _Rb_tree_node<dd::Item_name_key>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<dd::Item_name_key> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *, reference);

	typedef class pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> & reference;

	typedef const class pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *, const_reference);

	typedef const class pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_ta, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_ta, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*>, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*>, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*>, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_table>*>, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_ta);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Se_private_id_key, dd::cache::Cache_element<dd::Abstract_ta);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<dd::Se_private_id_key> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class Se_private_id_key * pointer;

public:

	pointer address(const class Malloc_allocator<dd::Se_private_id_key>  *, reference);

	typedef class Se_private_id_key & reference;

	typedef const class Se_private_id_key  * const_pointer;

	const_pointer address(const class Malloc_allocator<dd::Se_private_id_key>  *, const_reference);

	typedef const class Se_private_id_key  & const_reference;

	void Malloc_allocator(class Malloc_allocator<dd::Se_private_id_key> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<dd::Se_private_id_key> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<dd::Se_private_id_key> *, pointer, size_type);

	void destroy(class Malloc_allocator<dd::Se_private_id_key> *, pointer);

	size_type max_size(const class Malloc_allocator<dd::Se_private_id_key>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<dd::Se_private_id_key>  *);

	struct rebind<std::_Rb_tree_node<dd::Se_private_id_key> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<dd::Se_private_id_key> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> >  *, reference);

	typedef class _Rb_tree_node<dd::Se_private_id_key> & reference;

	typedef const class _Rb_tree_node<dd::Se_private_id_key>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> >  *, const_reference);

	typedef const class _Rb_tree_node<dd::Se_private_id_key>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<dd::Se_private_id_key> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> >  *, reference);

	typedef class pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> & reference;

	typedef const class pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> >  *, const_reference);

	typedef const class pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > >, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > >, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > >);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Charset* const, dd::cache::Cache_element<dd::Charset>*> > >);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Charset*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Charset  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Charset*>  *, reference);

	typedef const class Charset  * & reference;

	typedef const class Charset  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Charset*>  *, const_reference);

	typedef const class Charset  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Charset*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Charset*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Charset*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Charset*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Charset*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Charset*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Charset*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Charset*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Charset*> & reference;

	typedef const class _Rb_tree_node<const dd::Charset*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Charset*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Charset*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > >, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > >, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > >);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Charset>*> > >);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> >  *, reference);

	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> & reference;

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> >  *, const_reference);

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Charset>*> > );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<dd::Global_name_key> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class Global_name_key * pointer;

public:

	pointer address(const class Malloc_allocator<dd::Global_name_key>  *, reference);

	typedef class Global_name_key & reference;

	typedef const class Global_name_key  * const_pointer;

	const_pointer address(const class Malloc_allocator<dd::Global_name_key>  *, const_reference);

	typedef const class Global_name_key  & const_reference;

	void Malloc_allocator(class Malloc_allocator<dd::Global_name_key> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<dd::Global_name_key> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<dd::Global_name_key> *, pointer, size_type);

	void destroy(class Malloc_allocator<dd::Global_name_key> *, pointer);

	size_type max_size(const class Malloc_allocator<dd::Global_name_key>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<dd::Global_name_key>  *);

	struct rebind<std::_Rb_tree_node<dd::Global_name_key> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<dd::Global_name_key> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> >  *, reference);

	typedef class _Rb_tree_node<dd::Global_name_key> & reference;

	typedef const class _Rb_tree_node<dd::Global_name_key>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> >  *, const_reference);

	typedef const class _Rb_tree_node<dd::Global_name_key>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<dd::Global_name_key> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Charset>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<dd::Void_key> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class Void_key * pointer;

public:

	pointer address(const class Malloc_allocator<dd::Void_key>  *, reference);

	typedef class Void_key & reference;

	typedef const class Void_key  * const_pointer;

	const_pointer address(const class Malloc_allocator<dd::Void_key>  *, const_reference);

	typedef const class Void_key  & const_reference;

	void Malloc_allocator(class Malloc_allocator<dd::Void_key> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<dd::Void_key> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<dd::Void_key> *, pointer, size_type);

	void destroy(class Malloc_allocator<dd::Void_key> *, pointer);

	size_type max_size(const class Malloc_allocator<dd::Void_key>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<dd::Void_key>  *);

	struct rebind<std::_Rb_tree_node<dd::Void_key> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<dd::Void_key> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<dd::Void_key> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> >  *, reference);

	typedef class _Rb_tree_node<dd::Void_key> & reference;

	typedef const class _Rb_tree_node<dd::Void_key>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> >  *, const_reference);

	typedef const class _Rb_tree_node<dd::Void_key>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<dd::Void_key> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> >  *, reference);

	typedef class pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> & reference;

	typedef const class pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> >  *, const_reference);

	typedef const class pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*>, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*>, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*>);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Collation* const, dd::cache::Cache_element<dd::Collation>*>);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Collation*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Collation  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Collation*>  *, reference);

	typedef const class Collation  * & reference;

	typedef const class Collation  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Collation*>  *, const_reference);

	typedef const class Collation  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Collation*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Collation*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Collation*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Collation*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Collation*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Collation*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Collation*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Collation*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Collation*> & reference;

	typedef const class _Rb_tree_node<const dd::Collation*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Collation*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Collation*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Collation>*> >);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> >  *, reference);

	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> & reference;

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> >  *, const_reference);

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Collation>*> );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Collation>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > , reference);

	typedef class pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> & reference;

	typedef const class pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > , const_reference);

	typedef const class pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > );

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > );

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Colu, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Colu, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_statistics>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_sta, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_sta, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_sta, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Column_sta, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Colu);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Column_statistics* const, dd::cache::Cache_element<dd::Colu);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Column_statistics*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Column_statistics  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Column_statistics*>  *, reference);

	typedef const class Column_statistics  * & reference;

	typedef const class Column_statistics  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Column_statistics*>  *, const_reference);

	typedef const class Column_statistics  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Column_statistics*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Column_statistics*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Column_statistics*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Column_statistics*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Column_statistics*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Column_statistics*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Column_statistics*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Column_statistics*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Column_statistics*> & reference;

	typedef const class _Rb_tree_node<const dd::Column_statistics*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Column_statistics*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Column_statistics*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statist, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statist, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*>, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*>, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*>, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statistics>*>, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statist);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Column_statist);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *, reference);

	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> & reference;

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *, const_reference);

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statisti, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statisti, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> , PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> , size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> , pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statistics>*> , pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statisti);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Column_statisti);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*>, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*>, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*>);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Column_statistics>*>);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> >  *, reference);

	typedef class pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> & reference;

	typedef const class pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> >  *, const_reference);

	typedef const class pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Event* const, dd::cache::Cache_element<dd::Event>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Event*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Event  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Event*>  *, reference);

	typedef const class Event  * & reference;

	typedef const class Event  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Event*>  *, const_reference);

	typedef const class Event  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Event*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Event*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Event*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Event*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Event*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Event*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Event*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Event*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Event*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Event*> & reference;

	typedef const class _Rb_tree_node<const dd::Event*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Event*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Event*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > >  , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > >  , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > >  );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Event>*> > >  );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> >  *, reference);

	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> & reference;

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> >  *, const_reference);

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Event>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Event>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> >  *, reference);

	typedef class pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> & reference;

	typedef const class pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> >  *, const_reference);

	typedef const class pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resourc, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resourc, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_group>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_grou, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_grou, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_grou, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resource_grou, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resourc);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Resource_group* const, dd::cache::Cache_element<dd::Resourc);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Resource_group*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Resource_group  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Resource_group*>  *, reference);

	typedef const class Resource_group  * & reference;

	typedef const class Resource_group  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Resource_group*>  *, const_reference);

	typedef const class Resource_group  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Resource_group*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Resource_group*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Resource_group*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Resource_group*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Resource_group*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Resource_group*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Resource_group*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Resource_group*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Resource_group*> & reference;

	typedef const class _Rb_tree_node<const dd::Resource_group*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Resource_group*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Resource_group*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > , PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > , size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > , pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group>*> > , pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Resource_group);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >  *, reference);

	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> & reference;

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >  *, const_reference);

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_grou, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_grou, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_group>*> >, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_grou);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Resource_grou);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Resource_group>*> > );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> >  *, reference);

	typedef class pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> & reference;

	typedef const class pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> >  *, const_reference);

	typedef const class pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > >, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > >, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > >);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine* const, dd::cache::Cache_element<dd::Routine>*> > >);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Routine*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Routine  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Routine*>  *, reference);

	typedef const class Routine  * & reference;

	typedef const class Routine  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Routine*>  *, const_reference);

	typedef const class Routine  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Routine*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Routine*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Routine*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Routine*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Routine*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Routine*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Routine*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Routine*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Routine*> & reference;

	typedef const class _Rb_tree_node<const dd::Routine*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Routine*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Routine*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > >, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > >, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > >);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Routine>*> > >);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >  *, reference);

	typedef class pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> & reference;

	typedef const class pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >  *, const_reference);

	typedef const class pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Routine_name_key, dd::cache::Cache_element<dd::Routine>*> >);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<dd::Routine_name_key> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class Routine_name_key * pointer;

public:

	pointer address(const class Malloc_allocator<dd::Routine_name_key>  *, reference);

	typedef class Routine_name_key & reference;

	typedef const class Routine_name_key  * const_pointer;

	const_pointer address(const class Malloc_allocator<dd::Routine_name_key>  *, const_reference);

	typedef const class Routine_name_key  & const_reference;

	void Malloc_allocator(class Malloc_allocator<dd::Routine_name_key> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<dd::Routine_name_key> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<dd::Routine_name_key> *, pointer, size_type);

	void destroy(class Malloc_allocator<dd::Routine_name_key> *, pointer);

	size_type max_size(const class Malloc_allocator<dd::Routine_name_key>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<dd::Routine_name_key>  *);

	struct rebind<std::_Rb_tree_node<dd::Routine_name_key> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<dd::Routine_name_key> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> >  *, reference);

	typedef class _Rb_tree_node<dd::Routine_name_key> & reference;

	typedef const class _Rb_tree_node<dd::Routine_name_key>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> >  *, const_reference);

	typedef const class _Rb_tree_node<dd::Routine_name_key>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<dd::Routine_name_key> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Routine>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> >  *, reference);

	typedef class pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> & reference;

	typedef const class pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> >  *, const_reference);

	typedef const class pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > >  , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > >  , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > >  );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Schema* const, dd::cache::Cache_element<dd::Schema>*> > >  );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Schema*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Schema  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Schema*>  *, reference);

	typedef const class Schema  * & reference;

	typedef const class Schema  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Schema*>  *, const_reference);

	typedef const class Schema  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Schema*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Schema*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Schema*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Schema*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Schema*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Schema*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Schema*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Schema*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Schema*> & reference;

	typedef const class _Rb_tree_node<const dd::Schema*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Schema*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Schema*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Schema>*> > > );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> >  *, reference);

	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> & reference;

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> >  *, const_reference);

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > >  , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > >  , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > >  );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Schema>*> > >  );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Schema>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_referenc, reference);

	typedef class pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> & reference;

	typedef const class pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_referenc, const_reference);

	typedef const class pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_syst, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_syst, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_syst, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_syst, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_referenc);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_referenc);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<d, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<d, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spatial_reference_system>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spa, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spa, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spa, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<dd::Spa, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<d);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Spatial_reference_system* const, dd::cache::Cache_element<d);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Spatial_reference_system*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Spatial_reference_system  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Spatial_reference_system*>  *, reference);

	typedef const class Spatial_reference_system  * & reference;

	typedef const class Spatial_reference_system  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Spatial_reference_system*>  *, const_reference);

	typedef const class Spatial_reference_system  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Spatial_reference_system*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Spatial_reference_system*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Spatial_reference_system*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Spatial_reference_system*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Spatial_reference_system*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Spatial_reference_system*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Spatial_reference_system*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Spatial_reference_system*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Spatial_reference_system*> & reference;

	typedef const class _Rb_tree_node<const dd::Spatial_reference_system*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Spatial_reference_system*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Spatial_reference_system*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_refere, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_refere, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_sy, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_sy, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_sy, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_reference_sy, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_refere);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Spatial_refere);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *, reference);

	typedef class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> & reference;

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *, const_reference);

	typedef const class pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_referen, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_referen, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_sys, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_sys, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_sys, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_reference_sys, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_referen);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Item_name_key, dd::cache::Cache_element<dd::Spatial_referen);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_sy, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_sy, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_system>*, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_sy);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Spatial_reference_sy);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> >  *, reference);

	typedef class pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> & reference;

	typedef const class pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> >  *, const_reference);

	typedef const class pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > >, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > >, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > >, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>*> > >, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Tablespace* const, dd::cache::Cache_element<dd::Tablespace>);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<const dd::Tablespace*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef const class Tablespace  * * pointer;

public:

	pointer address(const class Malloc_allocator<const dd::Tablespace*>  *, reference);

	typedef const class Tablespace  * & reference;

	typedef const class Tablespace  * const * const_pointer;

	const_pointer address(const class Malloc_allocator<const dd::Tablespace*>  *, const_reference);

	typedef const class Tablespace  * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<const dd::Tablespace*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<const dd::Tablespace*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<const dd::Tablespace*> *, pointer, size_type);

	void destroy(class Malloc_allocator<const dd::Tablespace*> *, pointer);

	size_type max_size(const class Malloc_allocator<const dd::Tablespace*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<const dd::Tablespace*>  *);

	struct rebind<std::_Rb_tree_node<const dd::Tablespace*> > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<const dd::Tablespace*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> >  *, reference);

	typedef class _Rb_tree_node<const dd::Tablespace*> & reference;

	typedef const class _Rb_tree_node<const dd::Tablespace*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> >  *, const_reference);

	typedef const class _Rb_tree_node<const dd::Tablespace*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<const dd::Tablespace*> >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> >  *, reference);

	typedef class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> & reference;

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> >  *, const_reference);

	typedef const class pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> , reference);

	typedef class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> , const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> );

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Primary_id_key, dd::cache::Cache_element<dd::Tablespace>*> );


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> >  *, reference);

	typedef class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> & reference;

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> >  *, const_reference);

	typedef const class pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*>, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*>, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*>);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Global_name_key, dd::cache::Cache_element<dd::Tablespace>*>);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> >  *, reference);

	typedef class pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> & reference;

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> >  *, const_reference);

	typedef const class pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > *, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> >  *);

	struct rebind<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > >  *, reference);

	typedef class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > & reference;

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> >  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > >  *, const_reference);

	typedef const class _Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> >  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > > *, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > >  *);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const dd::Void_key, dd::cache::Cache_element<dd::Tablespace>*> > >  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Table_id {
	static const long long unsigned int TABLE_ID_MAX = 281474976710655; /*     0     0 */
	uint64_t                   m_id;                 /*     0     8 */
public:

	void Table_id(class Table_id *);

	void Table_id(class Table_id *, long long unsigned int);

	long long unsigned int id(const class Table_id  *);

	bool is_valid(const class Table_id  *);

	class Table_id & operator=(class Table_id *, long long unsigned int);

	bool operator==(const class Table_id  *, const class Table_id  &);

	bool operator!=(const class Table_id  *, const class Table_id  &);

	long long unsigned int operator long long unsigned int(const class Table_id  *);

	class Table_id operator++(class Table_id *, int);


	/* size: 8, cachelines: 1, members: 1, static members: 1 */
	/* last cacheline: 8 bytes */
};
struct p_column_list_val {
	union column_value_union {
		const uchar  *             field_image;          /*     0     8 */
		const char  *              value_str;            /*     0     8 */
	};

	union column_value_union   column_value;         /*     0     8 */
	class Item *               item_expression;      /*     8     8 */
	class partition_info *     part_info;            /*    16     8 */
	uint                       partition_id;         /*    24     4 */
	bool                       max_value;            /*    28     1 */
	bool                       null_value;           /*    29     1 */
	char                       fixed;                /*    30     1 */

	/* size: 32, cachelines: 1, members: 7 */
	/* padding: 1 */
	/* last cacheline: 32 bytes */
};
struct p_elem_val {
	longlong                   value;                /*     0     8 */
	uint                       added_items;          /*     8     4 */
	bool                       null_value;           /*    12     1 */
	bool                       unsigned_flag;        /*    13     1 */

	/* XXX 2 bytes hole, try to pack */

	part_column_list_val *     col_val_array;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* sum members: 22, holes: 1, sum holes: 2 */
	/* last cacheline: 24 bytes */
};
class List<partition_element> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<partition_element> *);

	void List(class List<partition_element> *, const class List<partition_element>  &);

	class List<partition_element> & operator=(class List<partition_element> *, const class List<partition_element>  &);

	void List(class List<partition_element> *, const class List<partition_element>  &, class MEM_ROOT *);

	bool push_back(class List<partition_element> *, class partition_element *);

	bool push_back(class List<partition_element> *, class partition_element *, class MEM_ROOT *);

	bool push_front(class List<partition_element> *, class partition_element *);

	bool push_front(class List<partition_element> *, class partition_element *, class MEM_ROOT *);

	class partition_element * head(class List<partition_element> *);

	const class partition_element  * head(const class List<partition_element>  *);

	class partition_element * * head_ref(class List<partition_element> *);

	class partition_element * pop(class List<partition_element> *);

	void concat(class List<partition_element> *, class List<partition_element> *);

	void disjoin(class List<partition_element> *, class List<partition_element> *);

	void prepend(class List<partition_element> *, class List<partition_element> *);

	void delete_elements(class List<partition_element> *);

	void destroy_elements(class List<partition_element> *);

	class partition_element * operator[](const class List<partition_element>  *, uint);

	void replace(class List<partition_element> *, uint, class partition_element *);

	bool swap_elts(class List<partition_element> *, uint, uint);

	typedef struct List_STL_Iterator<partition_element> iterator;

	iterator begin(class List<partition_element> *);

	iterator end(class List<partition_element> *);

	typedef struct List_STL_Iterator<const partition_element> const_iterator;

	const_iterator begin(const class List<partition_element>  *);

	const_iterator end(const class List<partition_element>  *);

	const_iterator cbegin(const class List<partition_element>  *);

	const_iterator cend(const class List<partition_element>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class partition_element {
public:

	class List<partition_element> subpartitions;     /*     0    24 */
	class List<p_elem_val>    list_val_list;         /*    24    24 */
	ha_rows                    part_max_rows;        /*    48     8 */
	ha_rows                    part_min_rows;        /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	longlong                   range_value;          /*    64     8 */
	const char  *              partition_name;       /*    72     8 */
	const char  *              tablespace_name;      /*    80     8 */
	char *                     part_comment;         /*    88     8 */
	const char  *              data_file_name;       /*    96     8 */
	const char  *              index_file_name;      /*   104     8 */
	class handlerton *         engine_type;          /*   112     8 */
	enum partition_state       part_state;           /*   120     4 */
	uint16                     nodegroup_id;         /*   124     2 */
	bool                       has_null_value;       /*   126     1 */
	bool                       signed_flag;          /*   127     1 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	bool                       max_value;            /*   128     1 */
	void partition_element(class partition_element *);

	void partition_element(class partition_element *, class partition_element *);

	void set_from_info(class partition_element *, const class HA_CREATE_INFO  *);

	void put_to_info(const class partition_element  *, class HA_CREATE_INFO *);


	/* size: 136, cachelines: 3, members: 16 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
class List<p_elem_val> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<p_elem_val> *);

	void List(class List<p_elem_val> *, const class List<p_elem_val>  &);

	class List<p_elem_val> & operator=(class List<p_elem_val> *, const class List<p_elem_val>  &);

	void List(class List<p_elem_val> *, const class List<p_elem_val>  &, class MEM_ROOT *);

	bool push_back(class List<p_elem_val> *, class p_elem_val *);

	bool push_back(class List<p_elem_val> *, class p_elem_val *, class MEM_ROOT *);

	bool push_front(class List<p_elem_val> *, class p_elem_val *);

	bool push_front(class List<p_elem_val> *, class p_elem_val *, class MEM_ROOT *);

	class p_elem_val * head(class List<p_elem_val> *);

	const class p_elem_val  * head(const class List<p_elem_val>  *);

	class p_elem_val * * head_ref(class List<p_elem_val> *);

	class p_elem_val * pop(class List<p_elem_val> *);

	void concat(class List<p_elem_val> *, class List<p_elem_val> *);

	void disjoin(class List<p_elem_val> *, class List<p_elem_val> *);

	void prepend(class List<p_elem_val> *, class List<p_elem_val> *);

	void delete_elements(class List<p_elem_val> *);

	void destroy_elements(class List<p_elem_val> *);

	class p_elem_val * operator[](const class List<p_elem_val>  *, uint);

	void replace(class List<p_elem_val> *, uint, class p_elem_val *);

	bool swap_elts(class List<p_elem_val> *, uint, uint);

	typedef struct List_STL_Iterator<p_elem_val> iterator;

	iterator begin(class List<p_elem_val> *);

	iterator end(class List<p_elem_val> *);

	typedef struct List_STL_Iterator<const p_elem_val> const_iterator;

	const_iterator begin(const class List<p_elem_val>  *);

	const_iterator end(const class List<p_elem_val>  *);

	const_iterator cbegin(const class List<p_elem_val>  *);

	const_iterator cend(const class List<p_elem_val>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class COPY_INFO {
	class Statistics {
	public:

		void Statistics(class Statistics *);

		ha_rows                    records;              /*     0     8 */
		ha_rows                    deleted;              /*     8     8 */
		ha_rows                    updated;              /*    16     8 */
		ha_rows                    copied;               /*    24     8 */
		ha_rows                    error_count;          /*    32     8 */
		ha_rows                    touched;              /*    40     8 */

		/* size: 48, cachelines: 1, members: 6 */
		/* last cacheline: 48 bytes */
	};

	enum operation_type {
		INSERT_OPERATION = 0,
		UPDATE_OPERATION = 1,
	};

	/* tag__fprintf: const_type tag not supported! */;

public:

	int ()(void) * *           _vptr.COPY_INFO;      /*     0     8 */
	void COPY_INFO(class COPY_INFO *, const class COPY_INFO  &);

	void operator=(class COPY_INFO *, class COPY_INFO &);

	const enum operation_type  m_optype;             /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	class mem_root_deque<Item*> * m_changed_columns; /*    16     8 */
	class mem_root_deque<Item*> * m_changed_columns2; /*    24     8 */
	const bool                 m_manage_defaults;    /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	class MY_BITMAP *          m_function_default_columns; /*    40     8 */
	const enum enum_duplicates handle_duplicates;    /*    48     4 */

	/* XXX 4 bytes hole, try to pack */
protected:

	bool get_function_default_columns(class COPY_INFO *, class TABLE *);

	class MY_BITMAP * get_cached_bitmap(const class COPY_INFO  *);

public:


	class Statistics          stats;                 /*    56    48 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	int                        escape_char;          /*   104     4 */
	int                        last_errno;           /*   108     4 */
	class mem_root_deque<Item*> * update_values;     /*   112     8 */
	void COPY_INFO(class COPY_INFO *, enum operation_type, class mem_root_deque<Item*> *, bool, enum enum_duplicates);

	void COPY_INFO(class COPY_INFO *, enum operation_type, class mem_root_deque<Item*> *, class mem_root_deque<Item*> *, bool, enum enum_duplicates, int);

	void COPY_INFO(class COPY_INFO *, enum operation_type, class mem_root_deque<Item*> *, class mem_root_deque<Item*> *);

	enum operation_type get_operation_type(const class COPY_INFO  *);

	class mem_root_deque<Item*> * get_changed_columns(const class COPY_INFO  *);

	const class mem_root_deque<Item*>  * get_changed_columns2(const class COPY_INFO  *);

	bool get_manage_defaults(const class COPY_INFO  *);

	enum enum_duplicates get_duplicate_handling(const class COPY_INFO  *);

	bool set_function_defaults(class COPY_INFO *, class TABLE *);

	bool add_function_default_columns(class COPY_INFO *, class TABLE *, class MY_BITMAP *);

	bool function_defaults_apply(const class COPY_INFO  *, const class TABLE  *);

	bool function_defaults_apply_on_columns(class COPY_INFO *, class MY_BITMAP *);

	void reset_counters(class COPY_INFO *);

	void cleanup(class COPY_INFO *);

	bool ignore_last_columns(class COPY_INFO *, class TABLE *, uint);

	virtual void ~COPY_INFO(class COPY_INFO *, int);


	/* size: 120, cachelines: 2, members: 11 */
	/* sum members: 105, holes: 3, sum holes: 15 */
	/* last cacheline: 56 bytes */
};
struct PARTITION_ITERATOR {
	struct st_part_num_range {
		uint32                     start;                /*     0     4 */
		uint32                     cur;                  /*     4     4 */
		uint32                     end;                  /*     8     4 */

		/* size: 12, cachelines: 1, members: 3 */
		/* last cacheline: 12 bytes */
	};

	struct st_field_value_range {
		ulonglong                  start;                /*     0     8 */
		ulonglong                  cur;                  /*     8     8 */
		ulonglong                  end;                  /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct st_part_num_range   part_nums;            /*     0    12 */
		struct st_field_value_range field_vals;          /*     0    24 */
	};

	partition_iter_func        get_next;             /*     0     8 */
	bool                       ret_null_part;        /*     8     1 */
	bool                       ret_null_part_orig;   /*     9     1 */

	/* XXX 6 bytes hole, try to pack */

	union {
		struct st_part_num_range part_nums;      /*    16    12 */
		struct st_field_value_range field_vals;  /*    16    24 */
	};                                               /*    16    24 */
	class partition_info *     part_info;            /*    40     8 */

	/* size: 48, cachelines: 1, members: 5 */
	/* sum members: 42, holes: 1, sum holes: 6 */
	/* last cacheline: 48 bytes */
};
class List<char> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<char> *);

	void List(class List<char> *, const class List<char>  &);

	class List<char> & operator=(class List<char> *, const class List<char>  &);

	void List(class List<char> *, const class List<char>  &, class MEM_ROOT *);

	bool push_back(class List<char> *, char *);

	bool push_back(class List<char> *, char *, class MEM_ROOT *);

	bool push_front(class List<char> *, char *);

	bool push_front(class List<char> *, char *, class MEM_ROOT *);

	char * head(class List<char> *);

	const char  * head(const class List<char>  *);

	char * * head_ref(class List<char> *);

	char * pop(class List<char> *);

	void concat(class List<char> *, class List<char> *);

	void disjoin(class List<char> *, class List<char> *);

	void prepend(class List<char> *, class List<char> *);

	void delete_elements(class List<char> *);

	void destroy_elements(class List<char> *);

	char * operator[](const class List<char>  *, uint);

	void replace(class List<char> *, uint, char *);

	bool swap_elts(class List<char> *, uint, uint);

	typedef struct List_STL_Iterator<char> iterator;

	iterator begin(class List<char> *);

	iterator end(class List<char> *);

	typedef struct List_STL_Iterator<char const> const_iterator;

	const_iterator begin(const class List<char>  *);

	const_iterator end(const class List<char>  *);

	const_iterator cbegin(const class List<char>  *);

	const_iterator cend(const class List<char>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class List<String> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<String> *);

	void List(class List<String> *, const class List<String>  &);

	class List<String> & operator=(class List<String> *, const class List<String>  &);

	void List(class List<String> *, const class List<String>  &, class MEM_ROOT *);

	bool push_back(class List<String> *, class String *);

	bool push_back(class List<String> *, class String *, class MEM_ROOT *);

	bool push_front(class List<String> *, class String *);

	bool push_front(class List<String> *, class String *, class MEM_ROOT *);

	class String * head(class List<String> *);

	const class String  * head(const class List<String>  *);

	class String * * head_ref(class List<String> *);

	class String * pop(class List<String> *);

	void concat(class List<String> *, class List<String> *);

	void disjoin(class List<String> *, class List<String> *);

	void prepend(class List<String> *, class List<String> *);

	void delete_elements(class List<String> *);

	void destroy_elements(class List<String> *);

	class String * operator[](const class List<String>  *, uint);

	void replace(class List<String> *, uint, class String *);

	bool swap_elts(class List<String> *, uint, uint);

	typedef struct List_STL_Iterator<String> iterator;

	iterator begin(class List<String> *);

	iterator end(class List<String> *);

	typedef struct List_STL_Iterator<const String> const_iterator;

	const_iterator begin(const class List<String>  *);

	const_iterator end(const class List<String>  *);

	const_iterator cbegin(const class List<String>  *);

	const_iterator cend(const class List<String>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class mem_root_deque<Item*> {
public:

	void mem_root_deque(class mem_root_deque<Item*> *, class MEM_ROOT *);

	void mem_root_deque(class mem_root_deque<Item*> *, const class mem_root_deque<Item*>  &);

	class mem_root_deque<Item*> & operator=(class mem_root_deque<Item*> *, const class mem_root_deque<Item*>  &);

	void mem_root_deque(class mem_root_deque<Item*> *, );

	class mem_root_deque<Item*> & operator=(class mem_root_deque<Item*> *, );

	void ~mem_root_deque(class mem_root_deque<Item*> *, int);

	class Item * & operator[](const class mem_root_deque<Item*>  *, size_t);

	bool push_back(class mem_root_deque<Item*> *, class Item * const &);

	bool push_back(class mem_root_deque<Item*> *, );

	bool push_front(class mem_root_deque<Item*> *, class Item * const &);

	bool push_front(class mem_root_deque<Item*> *, );

	void pop_back(class mem_root_deque<Item*> *);

	void pop_front(class mem_root_deque<Item*> *);

	class Item * & front(class mem_root_deque<Item*> *);

	class Item * const & front(const class mem_root_deque<Item*>  *);

	class Item * & back(class mem_root_deque<Item*> *);

	class Item * const & back(const class mem_root_deque<Item*>  *);

	void clear(class mem_root_deque<Item*> *);

	typedef struct Iterator<Item*> iterator;

	class Iterator<Item*> {

		/* size: 0, cachelines: 0, members: 0 */
	};

	iterator begin(class mem_root_deque<Item*> *);

	iterator end(class mem_root_deque<Item*> *);

	typedef struct reverse_iterator<mem_root_deque<Item*>::Iterator<Item*> > reverse_iterator;

	reverse_iterator rbegin(class mem_root_deque<Item*> *);

	reverse_iterator rend(class mem_root_deque<Item*> *);

	typedef struct Iterator<Item* const> const_iterator;

	class Iterator<Item* const> {
	public:

		void Iterator(class Iterator<Item* const> *);

		void Iterator(class Iterator<Item* const> *, const class mem_root_deque<Item*>  *, size_t);

		class Item * const & operator*(const class Iterator<Item* const>  *);

		class Iterator<Item* const> & operator++(class Iterator<Item* const> *);

		bool operator==(const class Iterator<Item* const>  *, const class Iterator<Item* const>  &);

		bool operator!=(const class Iterator<Item* const>  *, const class Iterator<Item* const>  &);

		class Item * const * operator->(const class Iterator<Item* const>  *);

		class Iterator<Item* const> operator++(class Iterator<Item* const> *, int);

		class Iterator<Item* const> & operator--(class Iterator<Item* const> *);

		class Iterator<Item* const> operator--(class Iterator<Item* const> *, int);

		class Iterator<Item* const> & operator+=(class Iterator<Item* const> *, difference_type);

		typedef ptrdiff_t difference_type;

		class Iterator<Item* const> & operator-=(class Iterator<Item* const> *, difference_type);

		class Iterator<Item* const> operator+(class Iterator<Item* const> *, difference_type);

		class Iterator<Item* const> operator-(class Iterator<Item* const> *, difference_type);

		difference_type operator-(const class Iterator<Item* const>  *, const class Iterator<Item* const>  &);

		class Item * const & operator[](const class Iterator<Item* const>  *, size_t);

		bool operator<(const class Iterator<Item* const>  *, const class Iterator<Item* const>  &);

		bool operator<=(const class Iterator<Item* const>  *, const class Iterator<Item* const>  &);

		bool operator>(const class Iterator<Item* const>  *, const class Iterator<Item* const>  &);

		bool operator>=(const class Iterator<Item* const>  *, const class Iterator<Item* const>  &);

		const class mem_root_deque<Item*>  * m_deque;    /*     0     8 */
		size_t                     m_physical_idx;       /*     8     8 */
		void assert_not_invalidated(const class Iterator<Item* const>  *);


		/* size: 16, cachelines: 1, members: 2 */
		/* last cacheline: 16 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	const_iterator cbegin(class mem_root_deque<Item*> *);

	const_iterator cend(class mem_root_deque<Item*> *);

	const_iterator begin(const class mem_root_deque<Item*>  *);

	const_iterator end(const class mem_root_deque<Item*>  *);

	typedef struct reverse_iterator<mem_root_deque<Item*>::Iterator<Item* const> > reverse_const_iterator;

	reverse_const_iterator crbegin(const class mem_root_deque<Item*>  *);

	reverse_const_iterator crend(const class mem_root_deque<Item*>  *);

	reverse_const_iterator rbegin(const class mem_root_deque<Item*>  *);

	reverse_const_iterator rend(const class mem_root_deque<Item*>  *);

	size_t size(const class mem_root_deque<Item*>  *);

	bool empty(const class mem_root_deque<Item*>  *);

	iterator erase(class mem_root_deque<Item*> *, const_iterator, const_iterator);

	iterator erase(class mem_root_deque<Item*> *, const_iterator);

	iterator insert(class mem_root_deque<Item*> *, const_iterator, class Item * const &);

	iterator insert(class mem_root_deque<Item*> *, const_iterator, );

	static const size_t               block_elements = 128; /*     0     0 */
	struct Block {
		class Item * *             elements;             /*     0     8 */
		bool init(class Block *, class MEM_ROOT *);


		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */
	};

	class Block *              m_blocks;             /*     0     8 */
	size_t                     m_begin_idx;          /*     8     8 */
	size_t                     m_end_idx;            /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */
	class MEM_ROOT *           m_root;               /*    32     8 */
	void invalidate_iterators(class mem_root_deque<Item*> *);

	bool add_initial_block(class mem_root_deque<Item*> *);

	bool add_block_back(class mem_root_deque<Item*> *);

	bool add_block_front(class mem_root_deque<Item*> *);

	size_t num_blocks(const class mem_root_deque<Item*>  *);

	class Item * & get(const class mem_root_deque<Item*>  *, size_t);


	/* size: 40, cachelines: 1, members: 5, static members: 1 */
	/* last cacheline: 40 bytes */
};
class List<Create_field> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Create_field> *);

	void List(class List<Create_field> *, const class List<Create_field>  &);

	class List<Create_field> & operator=(class List<Create_field> *, const class List<Create_field>  &);

	void List(class List<Create_field> *, const class List<Create_field>  &, class MEM_ROOT *);

	bool push_back(class List<Create_field> *, class Create_field *);

	bool push_back(class List<Create_field> *, class Create_field *, class MEM_ROOT *);

	bool push_front(class List<Create_field> *, class Create_field *);

	bool push_front(class List<Create_field> *, class Create_field *, class MEM_ROOT *);

	class Create_field * head(class List<Create_field> *);

	const class Create_field  * head(const class List<Create_field>  *);

	class Create_field * * head_ref(class List<Create_field> *);

	class Create_field * pop(class List<Create_field> *);

	void concat(class List<Create_field> *, class List<Create_field> *);

	void disjoin(class List<Create_field> *, class List<Create_field> *);

	void prepend(class List<Create_field> *, class List<Create_field> *);

	void delete_elements(class List<Create_field> *);

	void destroy_elements(class List<Create_field> *);

	class Create_field * operator[](const class List<Create_field>  *, uint);

	void replace(class List<Create_field> *, uint, class Create_field *);

	bool swap_elts(class List<Create_field> *, uint, uint);

	typedef struct List_STL_Iterator<Create_field> iterator;

	iterator begin(class List<Create_field> *);

	iterator end(class List<Create_field> *);

	typedef struct List_STL_Iterator<const Create_field> const_iterator;

	const_iterator begin(const class List<Create_field>  *);

	const_iterator end(const class List<Create_field>  *);

	const_iterator cbegin(const class List<Create_field>  *);

	const_iterator cend(const class List<Create_field>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Record_buffer {
	ha_rows                    m_max_records;        /*     0     8 */
	size_t                     m_record_size;        /*     8     8 */
	ha_rows                    m_count;              /*    16     8 */
	uchar *                    m_buffer;             /*    24     8 */
	bool                       m_out_of_range;       /*    32     1 */
public:

	void Record_buffer(class Record_buffer *, ha_rows, size_t, uchar *);

	size_t buffer_size(ha_rows, size_t);

	ha_rows max_records(const class Record_buffer  *);

	size_t record_size(const class Record_buffer  *);

	ha_rows records(const class Record_buffer  *);

	uchar * record(const class Record_buffer  *, ha_rows);

	uchar * add_record(class Record_buffer *);

	void remove_last(class Record_buffer *);

	void clear(class Record_buffer *);

	void reset(class Record_buffer *);

	void set_out_of_range(class Record_buffer *, bool);

	bool is_out_of_range(const class Record_buffer  *);


	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
class Sort_result {
public:

	void Sort_result(class Sort_result *);

	bool has_result_in_memory(const class Sort_result  *);

	bool has_result(const class Sort_result  *);

	class IO_CACHE *           io_cache;             /*     0     8 */
	bool                       sorted_result_in_fsbuf; /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	unique_ptr_my_free         sorted_result;        /*    16     8 */
	uchar *                    sorted_result_end;    /*    24     8 */
	ha_rows                    found_records;        /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
class Mem_root_array_YY<MYSQL_LEX_CSTRING> {
	static const bool                 has_trivial_destructor; /*     0     0 */
public:

	void init(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, class MEM_ROOT *);

	void init_empty_const(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *);

	class MYSQL_LEX_CSTRING & at(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, size_t);

	const class MYSQL_LEX_CSTRING  & at(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *, size_t);

	class MYSQL_LEX_CSTRING & operator[](class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, size_t);

	const class MYSQL_LEX_CSTRING  & operator[](const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *, size_t);

	class MYSQL_LEX_CSTRING & back(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *);

	const class MYSQL_LEX_CSTRING  & back(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	class MYSQL_LEX_CSTRING * begin(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *);

	const class MYSQL_LEX_CSTRING  * begin(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	class MYSQL_LEX_CSTRING * end(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *);

	const class MYSQL_LEX_CSTRING  * end(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	typedef const class MYSQL_LEX_CSTRING  * const_iterator;

	const_iterator cbegin(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	const_iterator cend(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	void clear(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *);

	void chop(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, size_t);

	bool reserve(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, size_t);

	bool push_back(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, const class MYSQL_LEX_CSTRING  &);

	bool push_back(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, );

	bool push_front(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, const class MYSQL_LEX_CSTRING  &);

	bool push_front(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, );

	void pop_back(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *);

	void resize(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, size_t, const value_type  &);

	typedef struct MYSQL_LEX_CSTRING value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void resize(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, size_t);

	typedef class MYSQL_LEX_CSTRING * iterator;

	iterator erase(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, const_iterator, const_iterator);

	iterator erase(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, const_iterator);

	iterator erase(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, size_t);

	iterator insert(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, const_iterator, const class MYSQL_LEX_CSTRING  &);

	size_t erase_value(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, const value_type  &);

	iterator erase(class Mem_root_array_YY<MYSQL_LEX_CSTRING> *, iterator);

	size_t capacity(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	size_t element_size(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	bool empty(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

	size_t size(const class Mem_root_array_YY<MYSQL_LEX_CSTRING>  *);

protected:

	class MEM_ROOT *           m_root;               /*     0     8 */
	class MYSQL_LEX_CSTRING *  m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4, static members: 1 */
	/* last cacheline: 32 bytes */
};
struct ORDER {
	bool is_item_original(const class ORDER  *);

	class ORDER *              next;                 /*     0     8 */
	class Item *               item_initial;         /*     8     8 */
	class Item * *             item;                 /*    16     8 */
	class Item_rollup_group_item * rollup_item;      /*    24     8 */
	enum enum_order            direction;            /*    32     4 */
	bool                       in_field_list;        /*    36     1 */
	bool                       used_alias;           /*    37     1 */

	/* XXX 2 bytes hole, try to pack */

	class Field *              field_in_tmp_table;   /*    40     8 */
	char *                     buff;                 /*    48     8 */
	table_map                  used;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	table_map                  depend_map;           /*    64     8 */
	bool                       is_position;          /*    72     1 */
	bool                       is_explicit;          /*    73     1 */

	/* size: 80, cachelines: 2, members: 13 */
	/* sum members: 72, holes: 1, sum holes: 2 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct GRANT_INTERNAL_INFO {
	bool                       m_schema_lookup_done; /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	const class ACL_internal_schema_access  * m_schema_access; /*     8     8 */
	bool                       m_table_lookup_done;  /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	const class ACL_internal_table_access  * m_table_access; /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct GRANT_INFO {
	void GRANT_INFO(class GRANT_INFO *);

	class GRANT_TABLE *        grant_table;          /*     0     8 */
	uint                       version;              /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      privilege;            /*    16     8 */
	struct GRANT_INTERNAL_INFO m_internal;           /*    24    32 */

	/* size: 56, cachelines: 1, members: 4 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct TABLE_FIELD_TYPE {
	LEX_CSTRING                name;                 /*     0    16 */
	LEX_CSTRING                type;                 /*    16    16 */
	LEX_CSTRING                cset;                 /*    32    16 */

	/* size: 48, cachelines: 1, members: 3 */
	/* last cacheline: 48 bytes */
};
struct TABLE_FIELD_DEF {
	uint                       count;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const class TABLE_FIELD_TYPE  * field;           /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, I_P_List_null_counter, I_P_List_no_push_back<Wait_for_flush> > : public I_P_List_null_counter, public I_P_List_no_push_back<Wait_for_flush> {
public:

	/* class I_P_List_null_counter <ancestor>; */    /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	/* class I_P_List_no_push_back<Wait_for_flush> <ancestor>; */ /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class Wait_for_flush *     m_first;              /*     0     8 */
	void I_P_List(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	void clear(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	bool is_empty(const class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_);

	void push_front(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *);

	void push_back(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *);

	void insert_after(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *, class Wait_for_flush *);

	void remove(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *);

	class Wait_for_flush * front(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	const class Wait_for_flush  * front(const class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_);

	class Wait_for_flush * pop_front(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	void swap(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);


	/* size: 8, cachelines: 1, members: 3 */
	/* paddings: 2, sum paddings: 2 */
	/* last cacheline: 8 bytes */
};
struct Table_share_foreign_key_info {
	LEX_CSTRING                referenced_table_db;  /*     0    16 */
	LEX_CSTRING                referenced_table_name; /*    16    16 */
	LEX_CSTRING                unique_constraint_name; /*    32    16 */
	enum enum_rule             update_rule;          /*    48     4 */
	enum enum_rule             delete_rule;          /*    52     4 */
	uint                       columns;              /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	LEX_CSTRING *              column_name;          /*    64     8 */

	/* size: 72, cachelines: 2, members: 7 */
	/* sum members: 68, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct Table_share_foreign_key_parent_info {
	LEX_CSTRING                referencing_table_db; /*     0    16 */
	LEX_CSTRING                referencing_table_name; /*    16    16 */
	enum enum_rule             update_rule;          /*    32     4 */
	enum enum_rule             delete_rule;          /*    36     4 */

	/* size: 40, cachelines: 1, members: 4 */
	/* last cacheline: 40 bytes */
};
struct Key_name {
	char                       name[64];             /*     0    64 */

	/* size: 64, cachelines: 1, members: 1 */
};
class I_P_List_no_push_back<Wait_for_flush> {
protected:

	void I_P_List_no_push_back(class I_P_List_no_push_back<Wait_for_flush> *, class Wait_for_flush * *);

	void set_last(class I_P_List_no_push_back<Wait_for_flush> *, class Wait_for_flush * *);

	void swap(class I_P_List_no_push_back<Wait_for_flush> *, class I_P_List_no_push_back<Wait_for_flush> &);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class Table_cache_element {
	typedef struct I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_back<TABLE> > TABLE_list;

	TABLE_list                 used_tables;          /*     0     8 */
	TABLE_list                 free_tables;          /*     8     8 */
	class TABLE_SHARE *        share;                /*    16     8 */
public:

	void Table_cache_element(class Table_cache_element *, class TABLE_SHARE *);

	class TABLE_SHARE * get_share(const class Table_cache_element  *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Query_block {
	enum Resolve_place {
		RESOLVE_NONE        = 0,
		RESOLVE_JOIN_NEST   = 1,
		RESOLVE_CONDITION   = 2,
		RESOLVE_HAVING      = 3,
		RESOLVE_SELECT_LIST = 4,
	};

public:

	void Query_block(class Query_block *, class MEM_ROOT *, class Item *, class Item *);

	class Item * where_cond(const class Query_block  *);

	class Item * * where_cond_ref(class Query_block *);

	void set_where_cond(class Query_block *, class Item *);

	class Item * having_cond(const class Query_block  *);

	class Item * * having_cond_ref(class Query_block *);

	void set_having_cond(class Query_block *, class Item *);

	void set_query_result(class Query_block *, class Query_result *);

	class Query_result * query_result(const class Query_block  *);

	bool change_query_result(class Query_block *, class THD *, class Query_result_interceptor *, class Query_result_interceptor *);

	void set_base_options(class Query_block *, ulonglong);

	void add_base_options(class Query_block *, ulonglong);

	void remove_base_options(class Query_block *, ulonglong);

	void make_active_options(class Query_block *, ulonglong, ulonglong);

	void add_active_options(class Query_block *, ulonglong);

	ulonglong active_options(const class Query_block  *);

	void set_tables_readonly(class Query_block *);

	table_map all_tables_map(const class Query_block  *);

	void remove_derived(class Query_block *, class THD *, class TABLE_LIST *);

	bool remove_aggregates(class Query_block *, class THD *, class Query_block *);

	class Query_expression * master_query_expression(const class Query_block  *);

	class Query_expression * first_inner_query_expression(const class Query_block  *);

	class Query_block * outer_query_block(const class Query_block  *);

	class Query_block * next_query_block(const class Query_block  *);

	class TABLE_LIST * find_table_by_name(class Query_block *, const class Table_ident  *);

	bool is_straight_join(class Query_block *);

	class Query_block * last_query_block(class Query_block *);

	class Query_block * next_select_in_list(const class Query_block  *);

	void mark_as_dependent(class Query_block *, class Query_block *, bool);

	bool is_explicitly_grouped(const class Query_block  *);

	bool is_implicitly_grouped(const class Query_block  *);

	bool is_single_grouped(const class Query_block  *);

	bool is_grouped(const class Query_block  *);

	bool is_distinct(const class Query_block  *);

	bool is_ordered(const class Query_block  *);

	bool can_skip_distinct(const class Query_block  *);

	bool has_limit(const class Query_block  *);

	bool has_ft_funcs(const class Query_block  *);

	bool is_recursive(const class Query_block  *);

	bool is_in_select_list(class Query_block *, class Item *);

	class ORDER * find_in_group_list(const class Query_block  *, class Item *, int *);

	int group_list_size(const class Query_block  *);

	bool has_windows(const class Query_block  *);

	void invalidate(class Query_block *);

	uint get_in_sum_expr(const class Query_block  *);

	bool add_item_to_list(class Query_block *, class Item *);

	bool add_ftfunc_to_list(class Query_block *, class Item_func_match *);

	void add_order_to_list(class Query_block *, class ORDER *);

	class TABLE_LIST * add_table_to_list(class Query_block *, class THD *, class Table_ident *, const char  *, ulong, enum thr_lock_type, enum enum_mdl_type, class List<Index_hint> *, class List<String> *, LEX_STRING *, class Parse_context *);

	class Item * * add_hidden_item(class Query_block *, class Item *);

	void remove_hidden_items(class Query_block *);

	class TABLE_LIST * get_table_list(const class Query_block  *);

	bool init_nested_join(class Query_block *, class THD *);

	class TABLE_LIST * end_nested_join(class Query_block *);

	class TABLE_LIST * nest_last_join(class Query_block *, class THD *, size_t);

	bool add_joined_table(class Query_block *, class TABLE_LIST *);

	class mem_root_deque<Item*> * get_fields_list(class Query_block *);

	void  visible_fields(class Query_block *);

	void  visible_fields(const class Query_block  *);

	bool check_view_privileges(class Query_block *, class THD *, ulong, ulong);

	bool check_column_privileges(class Query_block *, class THD *);

	bool check_privileges_for_subqueries(class Query_block *, class THD *);

	bool setup_tables(class Query_block *, class THD *, class TABLE_LIST *, bool);

	bool resolve_limits(class Query_block *, class THD *);

	bool resolve_placeholder_tables(class Query_block *, class THD *, bool);

	void propagate_unique_test_exclusion(class Query_block *);

	void merge_contexts(class Query_block *, class Query_block *);

	bool merge_derived(class Query_block *, class THD *, class TABLE_LIST *);

	bool flatten_subqueries(class Query_block *, class THD *);

	void update_semijoin_strategies(class Query_block *, class THD *);

	enum Subquery_strategy subquery_strategy(const class Query_block  *, const class THD  *);

	bool semijoin_enabled(const class Query_block  *, const class THD  *);

	void set_sj_candidates(class Query_block *, class Mem_root_array<Item_exists_subselect*> *);

	bool has_sj_candidates(const class Query_block  *);

	bool add_ftfunc_list(class Query_block *, class List<Item_func_match> *);

	void set_lock_for_table(class Query_block *, const class Lock_descriptor  &, class TABLE_LIST *);

	void set_lock_for_tables(class Query_block *, enum thr_lock_type);

	void init_order(class Query_block *);

	void cut_subtree(class Query_block *);

	bool test_limit(class Query_block *);

	ha_rows get_offset(class Query_block *, class THD *);

	ha_rows get_limit(class Query_block *, class THD *);

	bool set_context(class Query_block *, class Name_resolution_context *);

	bool setup_base_ref_items(class Query_block *, class THD *);

	void print(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_query_block(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_update(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_delete(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_insert(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_hints(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	bool print_error(class Query_block *, const class THD  *, class String *);

	void print_select_options(class Query_block *, class String *);

	void print_update_options(class Query_block *, class String *);

	void print_delete_options(class Query_block *, class String *);

	void print_insert_options(class Query_block *, class String *);

	void print_table_references(class Query_block *, const class THD  *, class String *, class TABLE_LIST *, enum enum_query_type);

	void print_item_list(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_update_list(class Query_block *, const class THD  *, class String *, enum enum_query_type, const class mem_root_deque<Item*>  &, const class mem_root_deque<Item*>  &);

	void print_insert_fields(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_values(class Query_block *, const class THD  *, class String *, enum enum_query_type, const class mem_root_deque<mem_root_deque<Item*>*>  &, const char  *);

	void print_from_clause(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_where_cond(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_group_by(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_having(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_windows(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_order_by(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	void print_order(const class THD  *, class String *, class ORDER *, enum enum_query_type);

	void print_limit(class Query_block *, const class THD  *, class String *, enum enum_query_type);

	bool save_properties(class Query_block *, class THD *);

	bool accept(class Query_block *, class Select_lex_visitor *);

	void cleanup(class Query_block *, class THD *, bool);

	void cleanup_all_joins(class Query_block *);

	void destroy(class Query_block *);

	bool is_part_of_union(const class Query_block  *);

	bool is_empty_query(const class Query_block  *);

	void set_empty_query(class Query_block *);

	bool agg_func_used(const class Query_block  *);

	bool json_agg_func_used(const class Query_block  *);

	void set_agg_func_used(class Query_block *, bool);

	void set_json_agg_func_used(class Query_block *, bool);

	bool right_joins(const class Query_block  *);

	void set_right_joins(class Query_block *);

	enum enum_explain_type type(class Query_block *);

	const char  * get_type_str(class Query_block *);

	const char  * get_type_str(enum enum_explain_type);

	bool is_dependent(const class Query_block  *);

	bool is_cacheable(const class Query_block  *);

	bool source_table_is_one_row(const class Query_block  *);

	void include_down(class Query_block *, class LEX *, class Query_expression *);

	void include_neighbour(class Query_block *, class LEX *, class Query_block *);

	void include_standalone(class Query_block *, class Query_expression *, class Query_block * *);

	void include_in_global(class Query_block *, class Query_block * *);

	void include_chain_in_global(class Query_block *, class Query_block * *);

	void renumber(class Query_block *, class LEX *);

	bool apply_local_transforms(class Query_block *, class THD *, bool);

	bool push_conditions_to_derived_tables(class Query_block *, class THD *);

	bool get_optimizable_conditions(class Query_block *, class THD *, class Item * *, class Item * *);

	bool validate_outermost_option(const class Query_block  *, class LEX *, const char  *);

	bool validate_base_options(const class Query_block  *, class LEX *, ulonglong);

	bool walk(class Query_block *, Item_processor, enum enum_walk, uchar *);

	bool add_tables(class Query_block *, class THD *, const class Mem_root_array<Table_ident*>  *, ulong, enum thr_lock_type, enum enum_mdl_type);

	bool resolve_rollup_wfs(class Query_block *, class THD *);

	bool setup_conds(class Query_block *, class THD *);

	bool prepare(class Query_block *, class THD *, class mem_root_deque<Item*> *);

	bool optimize(class Query_block *, class THD *);

	void reset_nj_counters(class Query_block *, class mem_root_deque<TABLE_LIST*> *);

	bool change_group_ref_for_func(class Query_block *, class THD *, class Item *, bool *);

	bool change_group_ref_for_cond(class Query_block *, class THD *, class Item_cond *, bool *);

	class Item * single_visible_field(const class Query_block  *);

	size_t num_visible_fields(const class Query_block  *);

	bool field_list_is_empty(const class Query_block  *);

	void remove_hidden_fields(class Query_block *);

	size_t                     m_added_non_hidden_fields; /*     0     8 */
	class mem_root_deque<Item*> fields;              /*     8    40 */
	class List<Window>        m_windows;             /*    48    24 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	class List<Item_func_match> * ftfunc_list;       /*    72     8 */
	class List<Item_func_match> ftfunc_list_alloc;   /*    80    24 */
	class mem_root_deque<mem_root_deque<Item*>*> * row_value_list; /*   104     8 */
	class mem_root_deque<TABLE_LIST*> sj_nests;      /*   112    40 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	class SQL_I_List<TABLE_LIST> table_list;         /*   152    24 */
	class SQL_I_List<ORDER>   order_list;            /*   176    24 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	Group_list_ptrs *          order_list_ptrs;      /*   200     8 */
	class SQL_I_List<ORDER>   group_list;            /*   208    24 */
	Group_list_ptrs *          group_list_ptrs;      /*   232     8 */
	class Prealloced_array<Item_rollup_group_item*, 4> rollup_group_items; /*   240    40 */
	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	class Prealloced_array<Item_rollup_sum_switcher*, 4> rollup_sums; /*   280    40 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	class Opt_hints_qb *       opt_hints_qb;         /*   320     8 */
	char *                     db;                   /*   328     8 */
	class TABLE_LIST *         recursive_reference;  /*   336     8 */
	class LEX *                parent_lex;           /*   344     8 */
	table_map                  select_list_tables;   /*   352     8 */
	table_map                  outer_join;           /*   360     8 */
	struct Name_resolution_context context;          /*   368    80 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	class Name_resolution_context * first_context;   /*   448     8 */
	class JOIN *               join;                 /*   456     8 */
	class mem_root_deque<TABLE_LIST*> top_join_list; /*   464    40 */
	class mem_root_deque<TABLE_LIST*> * join_list;   /*   504     8 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	class TABLE_LIST *         embedding;            /*   512     8 */
	class TABLE_LIST *         leaf_tables;          /*   520     8 */
	class TABLE_LIST *         end_lateral_table;    /*   528     8 */
	class Item *               select_limit;         /*   536     8 */
	class Item *               offset_limit;         /*   544     8 */
	class Item_sum *           inner_sum_func_list;  /*   552     8 */
	Ref_item_array             base_ref_items;       /*   560    16 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	uint                       select_number;        /*   576     4 */
	enum cond_result           cond_value;           /*   580     4 */
	enum cond_result           having_value;         /*   584     4 */
	enum enum_parsing_context  parsing_place;        /*   588     4 */
	uint                       in_sum_expr;          /*   592     4 */
	enum Resolve_place         resolve_place;        /*   596     4 */
	uint                       select_n_where_fields; /*   600     4 */
	uint                       select_n_having_items; /*   604     4 */
	uint                       cond_count;           /*   608     4 */
	uint                       between_count;        /*   612     4 */
	uint                       max_equal_elems;      /*   616     4 */
	uint                       n_sum_items;          /*   620     4 */
	uint                       n_child_sum_items;    /*   624     4 */
	uint                       n_scalar_subqueries;  /*   628     4 */
	uint                       materialized_derived_table_count; /*   632     4 */
	uint                       partitioned_table_count; /*   636     4 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	uint                       with_wild;            /*   640     4 */
	uint                       leaf_table_count;     /*   644     4 */
	uint                       derived_table_count;  /*   648     4 */
	uint                       table_func_count;     /*   652     4 */
	int                        nest_level;           /*   656     4 */
	enum olap_type             olap;                 /*   660     4 */
	enum enum_condition_context condition_context;   /*   664     4 */
	bool                       is_table_value_constructor; /*   668     1 */

	/* XXX 3 bytes hole, try to pack */

	enum sub_select_type       linkage;              /*   672     4 */
	uint8                      uncacheable;          /*   676     1 */
	void update_used_tables(class Query_block *);

	void restore_cmd_properties(class Query_block *);

	bool save_cmd_properties(class Query_block *, class THD *);

	bool                       first_execution;      /*   677     1 */
	bool                       sj_pullout_done;      /*   678     1 */
	bool                       m_was_implicitly_grouped; /*   679     1 */
	bool                       skip_local_transforms; /*   680     1 */
	bool                       is_item_list_lookup;  /*   681     1 */
	bool                       having_fix_field;     /*   682     1 */
	bool                       group_fix_field;      /*   683     1 */
	bool                       with_sum_func;        /*   684     1 */
	bool                       subquery_in_having;   /*   685     1 */
	bool                       m_use_select_limit;   /*   686     1 */
	bool                       m_internal_limit;     /*   687     1 */
	bool                       exclude_from_table_unique_test; /*   688     1 */
	bool                       no_table_names_allowed; /*   689     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       hidden_items_from_optimization; /*   692     4 */
	bool save_order_properties(class Query_block *, class THD *, class SQL_I_List<ORDER> *, Group_list_ptrs * *);

	bool record_join_nest_info(class Query_block *, class mem_root_deque<TABLE_LIST*> *);

	bool simplify_joins(class Query_block *, class THD *, class mem_root_deque<TABLE_LIST*> *, bool, bool, class Item * *, uint *);

	void clear_sj_expressions(class Query_block *, class NESTED_JOIN *);

	bool build_sj_cond(class Query_block *, class THD *, class NESTED_JOIN *, class Query_block *, table_map, class Item * *);

	bool decorrelate_condition(class Query_block *, class Semijoin_decorrelation &, class TABLE_LIST *);

	bool convert_subquery_to_semijoin(class Query_block *, class THD *, class Item_exists_subselect *);

	class TABLE_LIST * synthesize_derived(class Query_block *, class THD *, class Query_expression *, class Item *, bool, bool);

	bool transform_subquery_to_derived(class Query_block *, class THD *, class TABLE_LIST * *, class Query_expression *, class Item_subselect *, bool, bool, class Item *, class Item *);

	bool transform_table_subquery_to_join_with_derived(class Query_block *, class THD *, class Item_exists_subselect *);

	bool decorrelate_derived_scalar_subquery_pre(class Query_block *, class THD *, class TABLE_LIST *, class Item *, class Lifted_fields_map *, bool *);

	bool decorrelate_derived_scalar_subquery_post(class Query_block *, class THD *, class TABLE_LIST *, class Lifted_fields_map *, bool);

	void remap_tables(class Query_block *, class THD *);

	bool resolve_subquery(class Query_block *, class THD *);

	void mark_item_as_maybe_null_if_rollup_item(class Query_block *, class Item *);

	class Item * resolve_rollup_item(class Query_block *, class THD *, class Item *);

	bool resolve_rollup(class Query_block *, class THD *);

	bool setup_wild(class Query_block *, class THD *);

	bool setup_order_final(class Query_block *, class THD *);

	bool setup_group(class Query_block *, class THD *);

	void fix_after_pullout(class Query_block *, class Query_block *, class Query_block *);

	void remove_redundant_subquery_clauses(class Query_block *, class THD *, int);

	void repoint_contexts_of_join_nests(class Query_block *, class mem_root_deque<TABLE_LIST*>);

	void empty_order_list(class Query_block *, class Query_block *);

	bool setup_join_cond(class Query_block *, class THD *, class mem_root_deque<TABLE_LIST*> *, bool);

	bool find_common_table_expr(class Query_block *, class THD *, class Table_ident *, class TABLE_LIST *, class Parse_context *, bool *);

	bool transform_scalar_subqueries_to_join_with_derived(class Query_block *, class THD *);

	bool supported_correlated_scalar_subquery(class Query_block *, class THD *, class Css_info *, class Item * *);

	bool transform_grouped_to_derived(class Query_block *, class THD *, bool *);

	bool replace_subquery_in_expr(class Query_block *, class THD *, class Css_info *, class TABLE_LIST *, class Item * *);

	bool nest_derived(class Query_block *, class THD *, class Item *, class mem_root_deque<TABLE_LIST*> *, class TABLE_LIST *);

	bool resolve_table_value_constructor_values(class Query_block *, class THD *);

	void delete_unused_merged_columns(class Query_block *, class mem_root_deque<TABLE_LIST*> *);

	void fix_prepare_information_for_order(class Query_block *, class THD *, class SQL_I_List<ORDER> *, Group_list_ptrs * *);

	bool prepare_values(class Query_block *, class THD *);

	bool check_only_full_group_by(class Query_block *, class THD *);

	bool is_row_count_valid_for_semi_join(class Query_block *);

	class Mem_root_array<Item_exists_subselect*> * sj_candidates; /*   696     8 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	int                        hidden_order_field_count; /*   704     4 */

	/* XXX 4 bytes hole, try to pack */

	class Query_block *        next;                 /*   712     8 */
	class Query_block * *      prev;                 /*   720     8 */
	class Query_expression *   master;               /*   728     8 */
	class Query_expression *   slave;                /*   736     8 */
	class Query_block *        link_next;            /*   744     8 */
	class Query_block * *      link_prev;            /*   752     8 */
	class Query_result *       m_query_result;       /*   760     8 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	ulonglong                  m_base_options;       /*   768     8 */
	ulonglong                  m_active_options;     /*   776     8 */
	class TABLE_LIST *         resolve_nest;         /*   784     8 */
	class Item *               m_where_cond;         /*   792     8 */
	class Item *               m_having_cond;        /*   800     8 */
	int                        hidden_group_field_count; /*   808     4 */
	bool                       has_sj_nests;         /*   812     1 */
	bool                       has_aj_nests;         /*   813     1 */
	bool                       m_right_joins;        /*   814     1 */
	bool                       allow_merge_derived;  /*   815     1 */
	bool                       m_agg_func_used;      /*   816     1 */
	bool                       m_json_agg_func_used; /*   817     1 */
	bool                       m_empty_query;        /*   818     1 */

	/* Bitfield combined with previous fields */

	static const char  *              type_str[8];   /*     0     0 */

	/* size: 824, cachelines: 13, members: 94, static members: 1 */
	/* sum members: 810, holes: 3, sum holes: 9 */
	/* padding: 5 */
	/* last cacheline: 56 bytes */
};
class Blob_mem_storage {
	struct MEM_ROOT            storage;              /*     0    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	bool                       truncated_value;      /*    80     1 */
public:

	void Blob_mem_storage(class Blob_mem_storage *);

	void ~Blob_mem_storage(class Blob_mem_storage *, int);

	void reset(class Blob_mem_storage *);

	char * store(class Blob_mem_storage *, const char  *, size_t);

	void set_truncated_value(class Blob_mem_storage *, bool);

	bool is_truncated_value(const class Blob_mem_storage  *);


	/* size: 88, cachelines: 2, members: 2 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */
};
class Bitmap<4096> {
	struct MY_BITMAP           map;                  /*     0    32 */
	uint32                     buffer[128];          /*    32   512 */
public:

	void Bitmap(class Bitmap<4096> *);

	void Bitmap(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void Bitmap(class Bitmap<4096> *, uint);

	void init(class Bitmap<4096> *);

	void init(class Bitmap<4096> *, uint);

	uint length(const class Bitmap<4096>  *);

	class Bitmap<4096> & operator=(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void set_bit(class Bitmap<4096> *, uint);

	void clear_bit(class Bitmap<4096> *, uint);

	void set_prefix(class Bitmap<4096> *, uint);

	void set_all(class Bitmap<4096> *);

	void clear_all(class Bitmap<4096> *);

	void intersect(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void intersect(class Bitmap<4096> *, ulonglong);

	void intersect_extended(class Bitmap<4096> *, ulonglong);

	void subtract(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void merge(class Bitmap<4096> *, const class Bitmap<4096>  &);

	bool is_set(const class Bitmap<4096>  *, uint);

	bool is_prefix(const class Bitmap<4096>  *, uint);

	bool is_clear_all(const class Bitmap<4096>  *);

	bool is_set_all(const class Bitmap<4096>  *);

	bool is_subset(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	bool is_overlapping(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	bool operator==(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	bool operator!=(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	char * print(const class Bitmap<4096>  *, char *);

	ulonglong to_ulonglong(const class Bitmap<4096>  *);

	uint bits_set(const class Bitmap<4096>  *);

	uint get_first_set(const class Bitmap<4096>  *);


	/* size: 544, cachelines: 9, members: 2 */
	/* last cacheline: 32 bytes */
};
class JOIN_TAB : public QEP_shared_owner {
public:

	/* class QEP_shared_owner    <ancestor>; */      /*     0     8 */
	void JOIN_TAB(class JOIN_TAB *);

	void set_table(class JOIN_TAB *, class TABLE *);

	void init_join_cond_ref(class JOIN_TAB *, class TABLE_LIST *);

	class Item * join_cond(const class JOIN_TAB  *);

	void set_join_cond(class JOIN_TAB *, class Item *);

	void set_condition(class JOIN_TAB *, class Item *);

	uint use_join_cache(const class JOIN_TAB  *);

	void set_use_join_cache(class JOIN_TAB *, uint);

	class Key_use * keyuse(const class JOIN_TAB  *);

	void set_keyuse(class JOIN_TAB *, class Key_use *);

	class TABLE_LIST *         table_ref;            /*     8     8 */
	class Key_use *            m_keyuse;             /*    16     8 */
	class Item * *             m_join_cond_ref;      /*    24     8 */
	class COND_EQUAL *         cond_equal;           /*    32     8 */
	double                     worst_seeks;          /*    40     8 */
	Key_map                    const_keys;           /*    48     8 */
	Key_map                    checked_keys;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Key_map                    skip_scan_keys;       /*    64     8 */
	Key_map                    needed_reg;           /*    72     8 */
	Key_map                    quick_order_tested;   /*    80     8 */
	ha_rows                    found_records;        /*    88     8 */
	double                     read_time;            /*    96     8 */
	table_map                  dependent;            /*   104     8 */
	table_map                  key_dependent;        /*   112     8 */
	uint                       used_fieldlength;     /*   120     4 */
	enum quick_type            use_quick;            /*   124     4 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint                       m_use_join_cache;     /*   128     4 */

	/* XXX 4 bytes hole, try to pack */

	class TABLE_LIST *         emb_sj_nest;          /*   136     8 */
	nested_join_map            embedding_map;        /*   144     8 */
	uint                       join_cache_flags;     /*   152     4 */
	bool                       reversed_access;      /*   156     1 */
	void cleanup(class JOIN_TAB *);

	uint get_sj_strategy(const class JOIN_TAB  *);

	void JOIN_TAB(class JOIN_TAB *, const class JOIN_TAB  &);

	class JOIN_TAB & operator=(class JOIN_TAB *, const class JOIN_TAB  &);


	/* size: 160, cachelines: 3, members: 22 */
	/* sum members: 145, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 160 bytes != 145 (member bytes) + 0 (member bits) + 4 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class Value_generator {
public:

	class Item *               expr_item;            /*     0     8 */
	LEX_STRING                 expr_str;             /*     8    16 */
	uint32                     m_backup_binlog_stmt_flags; /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	class Item *               item_list;            /*    32     8 */
	struct MY_BITMAP           base_columns_map;     /*    40    32 */
	void Value_generator(class Value_generator *);

	void ~Value_generator(class Value_generator *, int);

	enum enum_field_types get_real_type(const class Value_generator  *);

	void set_field_type(class Value_generator *, enum enum_field_types);

	void backup_stmt_unsafe_flags(class Value_generator *, uint32);

	uint32 get_stmt_unsafe_flags(class Value_generator *);

	bool get_field_stored(const class Value_generator  *);

	void set_field_stored(class Value_generator *, bool);

	bool register_base_columns(class Value_generator *, class TABLE *);

	uint non_virtual_base_columns(const class Value_generator  *);

	void dup_expr_str(class Value_generator *, class MEM_ROOT *, const char  *, size_t);

	void print_expr(class Value_generator *, class THD *, class String *);

	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	enum enum_field_types      field_type;           /*    72     4 */
	bool                       stored_in_db;         /*    76     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       num_non_virtual_base_cols; /*    80     4 */
	bool                       permanent_changes_completed; /*    84     1 */

	/* size: 88, cachelines: 2, members: 9 */
	/* sum members: 78, holes: 2, sum holes: 7 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct ST_FIELD_INFO {
	const char  *              field_name;           /*     0     8 */
	uint                       field_length;         /*     8     4 */
	enum enum_field_types      field_type;           /*    12     4 */
	int                        value;                /*    16     4 */
	uint                       field_flags;          /*    20     4 */
	const char  *              old_name;             /*    24     8 */
	uint                       open_method;          /*    32     4 */

	/* size: 40, cachelines: 1, members: 7 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct ST_SCHEMA_TABLE {
	const char  *              table_name;           /*     0     8 */
	class ST_FIELD_INFO *      fields_info;          /*     8     8 */
	int                        (*fill_table)(class THD *, class TABLE_LIST *, class Item *); /*    16     8 */
	int                        (*old_format)(class THD *, class ST_SCHEMA_TABLE *); /*    24     8 */
	int                        (*process_table)(class THD *, class TABLE_LIST *, class TABLE *, bool, LEX_CSTRING, LEX_CSTRING); /*    32     8 */
	bool                       hidden;               /*    40     1 */

	/* size: 48, cachelines: 1, members: 6 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */
};
struct Field_translator {
	class Item *               item;                 /*     0     8 */
	const char  *              name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct LEX_ALTER {
	bool                       update_password_expired_fields; /*     0     1 */
	bool                       update_password_expired_column; /*     1     1 */
	bool                       use_default_password_lifetime; /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	uint16                     expire_after_days;    /*     4     2 */
	bool                       update_account_locked_column; /*     6     1 */
	bool                       account_locked;       /*     7     1 */
	uint32                     password_history_length; /*     8     4 */
	bool                       use_default_password_history; /*    12     1 */
	bool                       update_password_history; /*    13     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32                     password_reuse_interval; /*    16     4 */
	bool                       use_default_password_reuse_interval; /*    20     1 */
	bool                       update_password_reuse_interval; /*    21     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       failed_login_attempts; /*    24     4 */
	bool                       update_failed_login_attempts; /*    28     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        password_lock_time;   /*    32     4 */
	bool                       update_password_lock_time; /*    36     1 */

	/* XXX 3 bytes hole, try to pack */

	enum Lex_acl_attrib_udyn   update_password_require_current; /*    40     4 */
	void cleanup(class LEX_ALTER *);


	/* size: 44, cachelines: 1, members: 17 */
	/* sum members: 33, holes: 5, sum holes: 11 */
	/* last cacheline: 44 bytes */
};
class Derived_key {
public:

	table_map                  referenced_by;        /*     0     8 */
	Field_map                  used_fields;          /*     8   544 */
	/* --- cacheline 8 boundary (512 bytes) was 40 bytes ago --- */
	uint                       key_part_count;       /*   552     4 */

	/* size: 560, cachelines: 9, members: 3 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
class List<Derived_key> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Derived_key> *);

	void List(class List<Derived_key> *, const class List<Derived_key>  &);

	class List<Derived_key> & operator=(class List<Derived_key> *, const class List<Derived_key>  &);

	void List(class List<Derived_key> *, const class List<Derived_key>  &, class MEM_ROOT *);

	bool push_back(class List<Derived_key> *, class Derived_key *);

	bool push_back(class List<Derived_key> *, class Derived_key *, class MEM_ROOT *);

	bool push_front(class List<Derived_key> *, class Derived_key *);

	bool push_front(class List<Derived_key> *, class Derived_key *, class MEM_ROOT *);

	class Derived_key * head(class List<Derived_key> *);

	const class Derived_key  * head(const class List<Derived_key>  *);

	class Derived_key * * head_ref(class List<Derived_key> *);

	class Derived_key * pop(class List<Derived_key> *);

	void concat(class List<Derived_key> *, class List<Derived_key> *);

	void disjoin(class List<Derived_key> *, class List<Derived_key> *);

	void prepend(class List<Derived_key> *, class List<Derived_key> *);

	void delete_elements(class List<Derived_key> *);

	void destroy_elements(class List<Derived_key> *);

	class Derived_key * operator[](const class List<Derived_key>  *, uint);

	void replace(class List<Derived_key> *, uint, class Derived_key *);

	bool swap_elts(class List<Derived_key> *, uint, uint);

	typedef struct List_STL_Iterator<Derived_key> iterator;

	iterator begin(class List<Derived_key> *);

	iterator end(class List<Derived_key> *);

	typedef struct List_STL_Iterator<const Derived_key> const_iterator;

	const_iterator begin(const class List<Derived_key>  *);

	const_iterator end(const class List<Derived_key>  *);

	const_iterator cbegin(const class List<Derived_key>  *);

	const_iterator cend(const class List<Derived_key>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class mem_root_deque<TABLE_LIST*> {
public:

	void mem_root_deque(class mem_root_deque<TABLE_LIST*> *, class MEM_ROOT *);

	void mem_root_deque(class mem_root_deque<TABLE_LIST*> *, const class mem_root_deque<TABLE_LIST*>  &);

	class mem_root_deque<TABLE_LIST*> & operator=(class mem_root_deque<TABLE_LIST*> *, const class mem_root_deque<TABLE_LIST*>  &);

	void mem_root_deque(class mem_root_deque<TABLE_LIST*> *, );

	class mem_root_deque<TABLE_LIST*> & operator=(class mem_root_deque<TABLE_LIST*> *, );

	void ~mem_root_deque(class mem_root_deque<TABLE_LIST*> *, int);

	class TABLE_LIST * & operator[](const class mem_root_deque<TABLE_LIST*>  *, size_t);

	bool push_back(class mem_root_deque<TABLE_LIST*> *, class TABLE_LIST * const &);

	bool push_back(class mem_root_deque<TABLE_LIST*> *, );

	bool push_front(class mem_root_deque<TABLE_LIST*> *, class TABLE_LIST * const &);

	bool push_front(class mem_root_deque<TABLE_LIST*> *, );

	void pop_back(class mem_root_deque<TABLE_LIST*> *);

	void pop_front(class mem_root_deque<TABLE_LIST*> *);

	class TABLE_LIST * & front(class mem_root_deque<TABLE_LIST*> *);

	class TABLE_LIST * const & front(const class mem_root_deque<TABLE_LIST*>  *);

	class TABLE_LIST * & back(class mem_root_deque<TABLE_LIST*> *);

	class TABLE_LIST * const & back(const class mem_root_deque<TABLE_LIST*>  *);

	void clear(class mem_root_deque<TABLE_LIST*> *);

	typedef struct Iterator<TABLE_LIST*> iterator;

	class Iterator<TABLE_LIST*> {

		/* size: 0, cachelines: 0, members: 0 */
	};

	iterator begin(class mem_root_deque<TABLE_LIST*> *);

	iterator end(class mem_root_deque<TABLE_LIST*> *);

	typedef struct reverse_iterator<mem_root_deque<TABLE_LIST*>::Iterator<TABLE_LIST*> > reverse_iterator;

	reverse_iterator rbegin(class mem_root_deque<TABLE_LIST*> *);

	reverse_iterator rend(class mem_root_deque<TABLE_LIST*> *);

	typedef struct Iterator<TABLE_LIST* const> const_iterator;

	class Iterator<TABLE_LIST* const> {

		/* size: 0, cachelines: 0, members: 0 */
	};

	const_iterator cbegin(class mem_root_deque<TABLE_LIST*> *);

	const_iterator cend(class mem_root_deque<TABLE_LIST*> *);

	const_iterator begin(const class mem_root_deque<TABLE_LIST*>  *);

	const_iterator end(const class mem_root_deque<TABLE_LIST*>  *);

	typedef struct reverse_iterator<mem_root_deque<TABLE_LIST*>::Iterator<TABLE_LIST* const> > reverse_const_iterator;

	reverse_const_iterator crbegin(const class mem_root_deque<TABLE_LIST*>  *);

	reverse_const_iterator crend(const class mem_root_deque<TABLE_LIST*>  *);

	reverse_const_iterator rbegin(const class mem_root_deque<TABLE_LIST*>  *);

	reverse_const_iterator rend(const class mem_root_deque<TABLE_LIST*>  *);

	size_t size(const class mem_root_deque<TABLE_LIST*>  *);

	bool empty(const class mem_root_deque<TABLE_LIST*>  *);

	iterator erase(class mem_root_deque<TABLE_LIST*> *, const_iterator, const_iterator);

	iterator erase(class mem_root_deque<TABLE_LIST*> *, const_iterator);

	iterator insert(class mem_root_deque<TABLE_LIST*> *, const_iterator, class TABLE_LIST * const &);

	iterator insert(class mem_root_deque<TABLE_LIST*> *, const_iterator, );

	static const size_t               block_elements; /*     0     0 */
	struct Block {

		/* size: 0, cachelines: 0, members: 0 */
	};

	class Block *              m_blocks;             /*     0     8 */
	size_t                     m_begin_idx;          /*     8     8 */
	size_t                     m_end_idx;            /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */
	class MEM_ROOT *           m_root;               /*    32     8 */
	void invalidate_iterators(class mem_root_deque<TABLE_LIST*> *);

	bool add_initial_block(class mem_root_deque<TABLE_LIST*> *);

	bool add_block_back(class mem_root_deque<TABLE_LIST*> *);

	bool add_block_front(class mem_root_deque<TABLE_LIST*> *);

	size_t num_blocks(const class mem_root_deque<TABLE_LIST*>  *);

	class TABLE_LIST * & get(const class mem_root_deque<TABLE_LIST*>  *, size_t);


	/* size: 40, cachelines: 1, members: 5, static members: 1 */
	/* last cacheline: 40 bytes */
};
class Query_expression {
	enum enum_clean_state {
		UC_DIRTY      = 0,
		UC_PART_CLEAN = 1,
		UC_CLEAN      = 2,
	};

	class Query_expression *   next;                 /*     0     8 */
	class Query_expression * * prev;                 /*     8     8 */
	class Query_block *        master;               /*    16     8 */
	class Query_block *        slave;                /*    24     8 */
	enum enum_parsing_context  explain_marker;       /*    32     4 */
	bool                       prepared;             /*    36     1 */
	bool                       optimized;            /*    37     1 */
	bool                       executed;             /*    38     1 */

	/* XXX 1 byte hole, try to pack */

	struct TABLE_LIST          result_table_list;    /*    40  1600 */
	/* --- cacheline 25 boundary (1600 bytes) was 40 bytes ago --- */
	class Query_result_union * union_result;         /*  1640     8 */
	class TABLE *              table;                /*  1648     8 */
	class Query_result *       m_query_result;       /*  1656     8 */
	/* --- cacheline 26 boundary (1664 bytes) --- */
	unique_ptr_destroy_only    m_root_iterator;      /*  1664     8 */
	class AccessPath *         m_root_access_path;   /*  1672     8 */
	class Mem_root_array<MaterializePathParameters::QueryBlock> m_query_blocks_to_materialize; /*  1680    32 */
	class Mem_root_array<MaterializePathParameters::QueryBlock> setup_materialization(class Query_expression *, class THD *, class TABLE *, bool);

	void create_access_paths(class Query_expression *, class THD *);

public:

	uint8                      uncacheable;          /*  1712     1 */

	/* XXX 3 bytes hole, try to pack */
	void Query_expression(class Query_expression *, enum enum_parsing_context);

	bool is_simple(const class Query_expression  *);


	enum enum_clean_state      cleaned;              /*  1716     4 */
	class mem_root_deque<Item*> item_list;           /*  1720    40 */
	/* --- cacheline 27 boundary (1728 bytes) was 32 bytes ago --- */
	class mem_root_deque<Item*> types;               /*  1760    40 */
	class Query_block * global_parameters(const class Query_expression  *);

	/* --- cacheline 28 boundary (1792 bytes) was 8 bytes ago --- */
	ha_rows                    select_limit_cnt;     /*  1800     8 */
	ha_rows                    offset_limit_cnt;     /*  1808     8 */
	class Item_subselect *     item;                 /*  1816     8 */
	class Query_block *        fake_query_block;     /*  1824     8 */
	class Query_block *        saved_fake_query_block; /*  1832     8 */
	class Query_block *        union_distinct;       /*  1840     8 */
	class PT_with_clause *     m_with_clause;        /*  1848     8 */
	/* --- cacheline 29 boundary (1856 bytes) --- */
	class TABLE_LIST *         derived_table;        /*  1856     8 */
	class Query_block *        first_recursive;      /*  1864     8 */
	table_map                  m_lateral_deps;       /*  1872     8 */
	bool                       got_all_recursive_rows; /*  1880     1 */
	bool                       m_union_needs_tmp_table; /*  1881     1 */
	bool                       m_reject_multiple_rows; /*  1882     1 */

	/* XXX 5 bytes hole, try to pack */
	bool is_mergeable(const class Query_expression  *);

	bool merge_heuristic(const class Query_expression  *, const class LEX  *);

	class Query_block * outer_query_block(const class Query_expression  *);

	class Query_block * first_query_block(const class Query_expression  *);

	class Query_expression * next_query_expression(const class Query_expression  *);

	class Query_result * query_result(const class Query_expression  *);

	class RowIterator * root_iterator(const class Query_expression  *);

	unique_ptr_destroy_only release_root_iterator(class Query_expression *);

	class AccessPath * root_access_path(const class Query_expression  *);

	void change_to_access_path_without_in2exists(class Query_expression *, class THD *);

	void clear_root_access_path(class Query_expression *);

	bool force_create_iterators(class Query_expression *, class THD *);

	bool unfinished_materialization(const class Query_expression  *);

	class Mem_root_array<MaterializePathParameters::QueryBlock> release_query_blocks_to_materialize(class Query_expression *);

	void set_query_result(class Query_expression *, class Query_result *);

	bool can_materialize_directly_into_result(const class Query_expression  *);

	bool prepare(class Query_expression *, class THD *, class Query_result *, class mem_root_deque<Item*> *, ulonglong, ulonglong);

	bool optimize(class Query_expression *, class THD *, class TABLE *, bool);

	bool ClearForExecution(class Query_expression *, class THD *);

	bool ExecuteIteratorQuery(class Query_expression *, class THD *);

	bool execute(class Query_expression *, class THD *);

	bool explain(class Query_expression *, class THD *, const class THD  *);

	void cleanup(class Query_expression *, class THD *, bool);

	void destroy(class Query_expression *);

	void print(class Query_expression *, const class THD  *, class String *, enum enum_query_type);

	bool accept(class Query_expression *, class Select_lex_visitor *);

	bool add_fake_query_block(class Query_expression *, class THD *);

	bool prepare_fake_query_block(class Query_expression *, class THD *);

	void set_prepared(class Query_expression *);

	void set_optimized(class Query_expression *);

	void set_executed(class Query_expression *);

	void reset_executed(class Query_expression *);

	void clear_execution(class Query_expression *);

	bool is_prepared(const class Query_expression  *);

	bool is_optimized(const class Query_expression  *);

	bool is_executed(const class Query_expression  *);

	bool change_query_result(class Query_expression *, class THD *, class Query_result_interceptor *, class Query_result_interceptor *);

	bool set_limit(class Query_expression *, class THD *, class Query_block *);

	bool is_union(const class Query_expression  *);

	bool union_needs_tmp_table(class Query_expression *, class LEX *);

	bool mixed_union_operators(const class Query_expression  *);

	void include_down(class Query_expression *, class LEX *, class Query_block *);

	void exclude_level(class Query_expression *);

	void exclude_tree(class Query_expression *, class THD *);

	void renumber_selects(class Query_expression *, class LEX *);

	void restore_cmd_properties(class Query_expression *);

	bool save_cmd_properties(class Query_expression *, class THD *);

	class mem_root_deque<Item*> * get_unit_column_types(class Query_expression *);

	class mem_root_deque<Item*> * get_field_list(class Query_expression *);

	size_t num_visible_fields(const class Query_expression  *);


	ha_rows                    send_records;         /*  1888     8 */
	enum enum_parsing_context get_explain_marker(const class Query_expression  *, const class THD  *);

	void set_explain_marker(class Query_expression *, class THD *, enum enum_parsing_context);

	void set_explain_marker_from(class Query_expression *, class THD *, const class Query_expression  *);

	void assert_not_fully_clean(class Query_expression *);

	void invalidate(class Query_expression *);

	bool is_recursive(const class Query_expression  *);

	bool check_materialized_derived_query_blocks(class Query_expression *, class THD *);

	bool clear_correlated_query_blocks(class Query_expression *);

	void fix_after_pullout(class Query_expression *, class Query_block *, class Query_block *);

	void accumulate_used_tables(class Query_expression *, table_map);

	enum enum_parsing_context place(const class Query_expression  *);

	bool walk(class Query_expression *, Item_processor, enum enum_walk, uchar *);


	/* size: 1896, cachelines: 30, members: 33 */
	/* sum members: 1887, holes: 3, sum holes: 9 */
	/* last cacheline: 40 bytes */
};
struct Name_resolution_context {
	class Name_resolution_context * outer_context;   /*     0     8 */
	class Name_resolution_context * next_context;    /*     8     8 */
	class TABLE_LIST *         table_list;           /*    16     8 */
	class TABLE_LIST *         first_name_resolution_table; /*    24     8 */
	class TABLE_LIST *         last_name_resolution_table; /*    32     8 */
	class Query_block *        query_block;          /*    40     8 */
	bool                       view_error_handler;   /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	class TABLE_LIST *         view_error_handler_arg; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       resolve_in_select_list; /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	class Security_context *   security_ctx;         /*    72     8 */
	void Name_resolution_context(class Name_resolution_context *);

	void init(class Name_resolution_context *);

	void resolve_in_table_list_only(class Name_resolution_context *, class TABLE_LIST *);


	/* size: 80, cachelines: 2, members: 10 */
	/* sum members: 66, holes: 2, sum holes: 14 */
	/* last cacheline: 16 bytes */
};
class Common_table_expr {
public:

	void Common_table_expr(class Common_table_expr *, class MEM_ROOT *);

	class TABLE * clone_tmp_table(class Common_table_expr *, class THD *, class TABLE_LIST *);

	bool substitute_recursive_reference(class Common_table_expr *, class THD *, class Query_block *);

	bool clear_all_references(class Common_table_expr *);

	class Mem_root_array<TABLE_LIST*> references;    /*     0    32 */
	bool                       recursive;            /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	class Mem_root_array<TABLE_LIST*> tmp_tables;    /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	LEX_STRING                 name;                 /*    72    16 */

	/* size: 88, cachelines: 2, members: 4 */
	/* sum members: 81, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
class View_creation_ctx : public Default_object_creation_ctx {
public:

	/* class Default_object_creation_ctx <ancestor>; */ /*     0     0 */
	class View_creation_ctx * create(class THD *);

	class View_creation_ctx * create(class THD *, class TABLE_LIST *);

	void View_creation_ctx(class View_creation_ctx *, class THD *);

	virtual void ~View_creation_ctx(class View_creation_ctx *, int);


	/* size: 24, cachelines: 1, members: 1 */
	/* padding: 24 */
	/* last cacheline: 24 bytes */
};
class COND_EQUAL {
public:

	uint                       max_members;          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class COND_EQUAL *         upper_levels;         /*     8     8 */
	class List<Item_equal>    current_level;         /*    16    24 */
	void COND_EQUAL(class COND_EQUAL *);


	/* size: 40, cachelines: 1, members: 3 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
class Mem_root_array_YY<TABLE_LIST*> {
	static const bool                 has_trivial_destructor = 1; /*     0     0 */
public:

	void init(class Mem_root_array_YY<TABLE_LIST*> *, class MEM_ROOT *);

	void init_empty_const(class Mem_root_array_YY<TABLE_LIST*> *);

	class TABLE_LIST * & at(class Mem_root_array_YY<TABLE_LIST*> *, size_t);

	class TABLE_LIST * const & at(const class Mem_root_array_YY<TABLE_LIST*>  *, size_t);

	class TABLE_LIST * & operator[](class Mem_root_array_YY<TABLE_LIST*> *, size_t);

	class TABLE_LIST * const & operator[](const class Mem_root_array_YY<TABLE_LIST*>  *, size_t);

	class TABLE_LIST * & back(class Mem_root_array_YY<TABLE_LIST*> *);

	class TABLE_LIST * const & back(const class Mem_root_array_YY<TABLE_LIST*>  *);

	class TABLE_LIST * * begin(class Mem_root_array_YY<TABLE_LIST*> *);

	class TABLE_LIST * const * begin(const class Mem_root_array_YY<TABLE_LIST*>  *);

	class TABLE_LIST * * end(class Mem_root_array_YY<TABLE_LIST*> *);

	class TABLE_LIST * const * end(const class Mem_root_array_YY<TABLE_LIST*>  *);

	typedef class TABLE_LIST * const * const_iterator;

	const_iterator cbegin(const class Mem_root_array_YY<TABLE_LIST*>  *);

	const_iterator cend(const class Mem_root_array_YY<TABLE_LIST*>  *);

	void clear(class Mem_root_array_YY<TABLE_LIST*> *);

	void chop(class Mem_root_array_YY<TABLE_LIST*> *, size_t);

	bool reserve(class Mem_root_array_YY<TABLE_LIST*> *, size_t);

	bool push_back(class Mem_root_array_YY<TABLE_LIST*> *, class TABLE_LIST * const &);

	bool push_back(class Mem_root_array_YY<TABLE_LIST*> *, );

	bool push_front(class Mem_root_array_YY<TABLE_LIST*> *, class TABLE_LIST * const &);

	bool push_front(class Mem_root_array_YY<TABLE_LIST*> *, );

	void pop_back(class Mem_root_array_YY<TABLE_LIST*> *);

	void resize(class Mem_root_array_YY<TABLE_LIST*> *, size_t, const value_type  &);

	typedef class TABLE_LIST * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void resize(class Mem_root_array_YY<TABLE_LIST*> *, size_t);

	typedef class TABLE_LIST * * iterator;

	iterator erase(class Mem_root_array_YY<TABLE_LIST*> *, const_iterator, const_iterator);

	iterator erase(class Mem_root_array_YY<TABLE_LIST*> *, const_iterator);

	iterator erase(class Mem_root_array_YY<TABLE_LIST*> *, size_t);

	iterator insert(class Mem_root_array_YY<TABLE_LIST*> *, const_iterator, class TABLE_LIST * const &);

	size_t erase_value(class Mem_root_array_YY<TABLE_LIST*> *, const value_type  &);

	iterator erase(class Mem_root_array_YY<TABLE_LIST*> *, iterator);

	size_t capacity(const class Mem_root_array_YY<TABLE_LIST*>  *);

	size_t element_size(const class Mem_root_array_YY<TABLE_LIST*>  *);

	bool empty(const class Mem_root_array_YY<TABLE_LIST*>  *);

	size_t size(const class Mem_root_array_YY<TABLE_LIST*>  *);

protected:

	class MEM_ROOT *           m_root;               /*     0     8 */
	class TABLE_LIST * *       m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4, static members: 1 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<TABLE_LIST*> : public Mem_root_array_YY<TABLE_LIST*> {
public:

	/* class Mem_root_array_YY<TABLE_LIST*> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *);

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, class MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, );

	class Mem_root_array<TABLE_LIST*> & operator=(class Mem_root_array<TABLE_LIST*> *, );

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, class MEM_ROOT *, size_t);

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, class MEM_ROOT *, size_t, const value_type  &);

	typedef class TABLE_LIST * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, class MEM_ROOT *, const_iterator, const_iterator);

	typedef const_iterator const_iterator;

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, class MEM_ROOT *, const class Mem_root_array<TABLE_LIST*>  &);

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, class initializer_list<TABLE_LIST*>);

	void ~Mem_root_array(class Mem_root_array<TABLE_LIST*> *, int);

	void Mem_root_array(class Mem_root_array<TABLE_LIST*> *, const class Mem_root_array<TABLE_LIST*>  &);

	class Mem_root_array<TABLE_LIST*> & operator=(class Mem_root_array<TABLE_LIST*> *, const class Mem_root_array<TABLE_LIST*>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Send_field {
public:

	const char  *              db_name;              /*     0     8 */
	const char  *              table_name;           /*     8     8 */
	const char  *              org_table_name;       /*    16     8 */
	const char  *              col_name;             /*    24     8 */
	const char  *              org_col_name;         /*    32     8 */
	ulong                      length;               /*    40     8 */
	uint                       charsetnr;            /*    48     4 */
	uint                       flags;                /*    52     4 */
	uint                       decimals;             /*    56     4 */
	enum enum_field_types      type;                 /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       field;                /*    64     1 */
	void Send_field(class Send_field *);


	/* size: 72, cachelines: 2, members: 11 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
struct Symbol_location {
	const char  *              start;                /*     0     8 */
	const char  *              end;                  /*     8     8 */
	bool is_empty(const class Symbol_location  *);

	size_t length(const class Symbol_location  *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct YYLTYPE {
	struct Symbol_location     cpp;                  /*     0    16 */
	struct Symbol_location     raw;                  /*    16    16 */
	bool is_empty(const class YYLTYPE  *);


	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
struct Parse_context {
	const class THD *          thd;                  /*     0     8 */
	class MEM_ROOT *           mem_root;             /*     8     8 */
	class Query_block *        select;               /*    16     8 */
	void Parse_context(class Parse_context *, class THD *, class Query_block *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Parse_tree_node_tmpl<Parse_context> {
public:

	int ()(void) * *           _vptr.Parse_tree_node_tmpl; /*     0     8 */
	void Parse_tree_node_tmpl(class Parse_tree_node_tmpl<Parse_context> *, const class Parse_tree_node_tmpl<Parse_context>  &);

	void operator=(class Parse_tree_node_tmpl<Parse_context> *, const class Parse_tree_node_tmpl<Parse_context>  &);

	void * operator new(size_t, class MEM_ROOT *, const class nothrow_t  &);

	void operator delete(void *, size_t);

	void operator delete(void *, class MEM_ROOT *, const class nothrow_t  &);

protected:

	void Parse_tree_node_tmpl(class Parse_tree_node_tmpl<Parse_context> *);

public:

	virtual void ~Parse_tree_node_tmpl(class Parse_tree_node_tmpl<Parse_context> *, int);

	virtual bool contextualize(class Parse_tree_node_tmpl<Parse_context> *, class Parse_context *);

	void error(const class Parse_tree_node_tmpl<Parse_context>  *, class Parse_context *, const POS  &);

	void error(const class Parse_tree_node_tmpl<Parse_context>  *, class Parse_context *, const POS  &, const char  *);

	void errorf(const class Parse_tree_node_tmpl<Parse_context>  *, class Parse_context *, const POS  &, const char  *, ...);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Bounds_checked_array<Item*> {
public:

	void Bounds_checked_array(class Bounds_checked_array<Item*> *);

	void Bounds_checked_array(class Bounds_checked_array<Item*> *, class Item * *, size_t);

	class Bounds_checked_array<Item*> Alloc(class MEM_ROOT *, size_t);

	void reset(class Bounds_checked_array<Item*> *);

	void reset(class Bounds_checked_array<Item*> *, class Item * *, size_t);

	void resize(class Bounds_checked_array<Item*> *, size_t);

	class Bounds_checked_array<Item*> prefix(class Bounds_checked_array<Item*> *, size_t);

	class Item * & operator[](class Bounds_checked_array<Item*> *, size_t);

	class Item * const & operator[](const class Bounds_checked_array<Item*>  *, size_t);

	typedef class Item * * iterator;

	iterator begin(class Bounds_checked_array<Item*> *);

	iterator end(class Bounds_checked_array<Item*> *);

	typedef class Item * const * const_iterator;

	const_iterator begin(const class Bounds_checked_array<Item*>  *);

	const_iterator end(const class Bounds_checked_array<Item*>  *);

	class Bounds_checked_array<Item*> without_back(const class Bounds_checked_array<Item*>  *);

	size_t element_size(const class Bounds_checked_array<Item*>  *);

	size_t size(const class Bounds_checked_array<Item*>  *);

	bool empty(const class Bounds_checked_array<Item*>  *);

	bool is_null(const class Bounds_checked_array<Item*>  *);

	void pop_front(class Bounds_checked_array<Item*> *);

	class Item * * array(const class Bounds_checked_array<Item*>  *);

	bool operator==(const class Bounds_checked_array<Item*>  *, const class Bounds_checked_array<Item*>  &);

	bool operator!=(const class Bounds_checked_array<Item*>  *, const class Bounds_checked_array<Item*>  &);

	class Item * *             m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class DTCollation {
public:

	const class CHARSET_INFO  * collation;           /*     0     8 */
	enum Derivation            derivation;           /*     8     4 */
	uint                       repertoire;           /*    12     4 */
	void set_repertoire_from_charset(class DTCollation *, const class CHARSET_INFO  *);

	void DTCollation(class DTCollation *);

	void DTCollation(class DTCollation *, const class CHARSET_INFO  *, enum Derivation);

	void set(class DTCollation *, const class DTCollation  &);

	void set(class DTCollation *, const class CHARSET_INFO  *, enum Derivation);

	void set(class DTCollation *, const class CHARSET_INFO  *, enum Derivation, uint);

	void set_numeric(class DTCollation *);

	void set(class DTCollation *, const class CHARSET_INFO  *);

	void set(class DTCollation *, enum Derivation);

	void set_repertoire(class DTCollation *, uint);

	bool aggregate(class DTCollation *, class DTCollation &, uint);

	bool set(class DTCollation *, class DTCollation &, class DTCollation &, uint);

	const char  * derivation_name(const class DTCollation  *);


	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
class Mark_field {
public:

	void Mark_field(class Mark_field *, class TABLE *, enum enum_mark_columns);

	void Mark_field(class Mark_field *, enum enum_mark_columns);

	const class TABLE *        table;                /*     0     8 */
	const enum enum_mark_columns mark;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
class Name_string : public Simple_cstring {
public:

	/* class Simple_cstring      <ancestor>; */      /*     0    16 */
	void set_or_copy(class Name_string *, const char  *, size_t, bool);

	void Name_string(class Name_string *);

	void Name_string(class Name_string *, const char  *, size_t);

	void Name_string(class Name_string *, LEX_STRING);

	void Name_string(class Name_string *, LEX_CSTRING);

	void Name_string(class Name_string *, const char  *, size_t, bool);

	void Name_string(class Name_string *, LEX_STRING, bool);

	void copy(class Name_string *, const char  *, size_t, const class CHARSET_INFO  *);

	void copy(class Name_string *, const char  *, size_t);

	void copy(class Name_string *, const char  *);

	void copy(class Name_string *, LEX_STRING);

	void copy(class Name_string *, const LEX_STRING  *);

	void copy(class Name_string *, class Name_string);

	bool eq(const class Name_string  *, const char  *);

	bool eq_safe(const class Name_string  *, const char  *);

	bool eq(const class Name_string  *, class Name_string);

	bool eq_safe(const class Name_string  *, class Name_string);


	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class Item_name_string : public Name_string {
	using ::copy;

	using ::copy;

	using ::copy;

	using ::copy;

	using ::copy;

	using ::copy;

public:

	/* class Name_string         <ancestor>; */      /*     0    16 */
	bool                       m_is_autogenerated;   /*    16     1 */
	void Item_name_string(class Item_name_string *);

	void Item_name_string(class Item_name_string *, class Name_string);

	void set_autogenerated(class Item_name_string *, bool);

	bool is_autogenerated(const class Item_name_string  *);

	void copy(class Item_name_string *, const char  *, size_t, const class CHARSET_INFO  *, bool);


	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 1 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
struct Check_function_as_value_generator_parameters {
	void Check_function_as_value_generator_parameters(class Check_function_as_value_generator_parameters *, int, enum Value_generator_source);

	int                        col_index;            /*     0     4 */
	int                        err_code;             /*     4     4 */
	enum Value_generator_source source;              /*     8     2 */

	/* XXX 6 bytes hole, try to pack */

	const char  *              banned_function_name; /*    16     8 */
	int get_unnamed_function_error_code(const class Check_function_as_value_generator_parameters  *);


	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 1, sum holes: 6 */
	/* last cacheline: 24 bytes */
};
class Bool3 {
	enum value {
		v_FALSE   = 0,
		v_UNKNOWN = 1,
		v_TRUE    = 2,
	};

public:

	const class Bool3  false3(void);

	const class Bool3  unknown3(void);

	const class Bool3  true3(void);

	bool is_true(const class Bool3  *);

	bool is_unknown(const class Bool3  *);

	bool is_false(const class Bool3  *);

	void Bool3(class Bool3 *, enum value);

	enum value                 m_val;                /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Type_properties {
public:

	void Type_properties(class Type_properties *, enum enum_field_types);

	void Type_properties(class Type_properties *, enum enum_field_types, bool);

	void Type_properties(class Type_properties *, enum enum_field_types, const class CHARSET_INFO  *);

	void Type_properties(class Type_properties *, class Item &);

	const enum enum_field_types m_type;              /*     0     4 */
	const bool                 m_unsigned_flag;      /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	const uint32               m_max_length;         /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const class DTCollation   m_collation;           /*    16    16 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 2, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct udf_func {
	LEX_STRING                 name;                 /*     0    16 */
	enum Item_result           returns;              /*    16     4 */
	enum Item_udftype          type;                 /*    20     4 */
	char *                     dl;                   /*    24     8 */
	void *                     dlhandle;             /*    32     8 */
	Udf_func_any               func;                 /*    40     8 */
	Udf_func_init              func_init;            /*    48     8 */
	Udf_func_deinit            func_deinit;          /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Udf_func_clear             func_clear;           /*    64     8 */
	Udf_func_add               func_add;             /*    72     8 */
	ulong                      usage_count;          /*    80     8 */

	/* size: 88, cachelines: 2, members: 11 */
	/* last cacheline: 24 bytes */
};
struct Udf_args_extension {
	void Udf_args_extension(class Udf_args_extension *);

	const class CHARSET_INFO  * * charset_info;      /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct Udf_return_value_extension {
	void Udf_return_value_extension(class Udf_return_value_extension *, const class CHARSET_INFO  *, enum Item_result);

	const class CHARSET_INFO  * charset_info;        /*     0     8 */
	enum Item_result           result_type;          /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
class udf_handler {
protected:

	class udf_func *           u_d;                  /*     0     8 */
	class String *             buffers;              /*     8     8 */
	UDF_ARGS                   f_args;               /*    16    64 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	UDF_INIT                   initid;               /*    80    40 */
	char *                     num_buffer;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uchar                      error;                /*   128     1 */
	uchar                      is_null;              /*   129     1 */
	bool                       m_initialized;        /*   130     1 */

	/* XXX 5 bytes hole, try to pack */

	class Item * *             args;                 /*   136     8 */
	struct Udf_args_extension  m_args_extension;     /*   144     8 */
	struct Udf_return_value_extension m_return_value_extension; /*   152    16 */

	/* XXX last struct has 4 bytes of padding */
public:


	table_map                  used_tables_cache;    /*   168     8 */
	bool                       m_original;           /*   176     1 */
	void udf_handler(class udf_handler *, class udf_func *);

	void udf_handler(class udf_handler *, const class udf_handler  &);

	void udf_handler(class udf_handler *, );

	class udf_handler & operator=(class udf_handler *, const class udf_handler  &);

	class udf_handler & operator=(class udf_handler *, );

	void clean_buffers(class udf_handler *);

	void free_handler(class udf_handler *);

	bool is_initialized(const class udf_handler  *);

	const char  * name(const class udf_handler  *);

	enum Item_result result_type(const class udf_handler  *);

	bool fix_fields(class udf_handler *, class THD *, class Item_result_field *, uint, class Item * *);

	void cleanup(class udf_handler *);

	bool call_init_func(class udf_handler *);

	double val_real(class udf_handler *, bool *);

	longlong val_int(class udf_handler *, bool *);

	class my_decimal * val_decimal(class udf_handler *, bool *, class my_decimal *);

	class String * val_str(class udf_handler *, class String *, class String *);

	void clear(class udf_handler *);

	void add(class udf_handler *, bool *);

	bool get_arguments(class udf_handler *);

	class String * result_string(class udf_handler *, const char  *, size_t, class String *, class String *);

	void get_string(class udf_handler *, uint);

	bool get_and_convert_string(class udf_handler *, uint);


	/* size: 184, cachelines: 3, members: 13 */
	/* sum members: 172, holes: 1, sum holes: 5 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 56 bytes */
};
class Prealloced_array<Log_event*, 32> {
	struct External {
		class Log_event * *        m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Log_event *          m_buff[32];           /*     0   256 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Log_event*, 32>  *);

	class Log_event * * buffer(class Prealloced_array<Log_event*, 32> *);

	class Log_event * const * buffer(const class Prealloced_array<Log_event*, 32>  *);

	void set_size(class Prealloced_array<Log_event*, 32> *, size_t);

	void adjust_size(class Prealloced_array<Log_event*, 32> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Log_event*, 32> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Log_event*, 32> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Log_event*, 32> *, const class Prealloced_array<Log_event*, 32>  &);

	void Prealloced_array(class Prealloced_array<Log_event*, 32> *, );

	void Prealloced_array(class Prealloced_array<Log_event*, 32> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Log_event * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Log_event*, 32> *, class initializer_list<Log_event*>);

	class Prealloced_array<Log_event*, 32> & operator=(class Prealloced_array<Log_event*, 32> *, const class Prealloced_array<Log_event*, 32>  &);

	class Prealloced_array<Log_event*, 32> & operator=(class Prealloced_array<Log_event*, 32> *, );

	void ~Prealloced_array(class Prealloced_array<Log_event*, 32> *, int);

	size_t capacity(const class Prealloced_array<Log_event*, 32>  *);

	size_t element_size(const class Prealloced_array<Log_event*, 32>  *);

	bool empty(const class Prealloced_array<Log_event*, 32>  *);

	size_t size(const class Prealloced_array<Log_event*, 32>  *);

	class Log_event * & at(class Prealloced_array<Log_event*, 32> *, size_t);

	class Log_event * const & at(const class Prealloced_array<Log_event*, 32>  *, size_t);

	class Log_event * & operator[](class Prealloced_array<Log_event*, 32> *, size_t);

	class Log_event * const & operator[](const class Prealloced_array<Log_event*, 32>  *, size_t);

	class Log_event * & back(class Prealloced_array<Log_event*, 32> *);

	class Log_event * const & back(const class Prealloced_array<Log_event*, 32>  *);

	class Log_event * & front(class Prealloced_array<Log_event*, 32> *);

	class Log_event * const & front(const class Prealloced_array<Log_event*, 32>  *);

	typedef class Log_event * * iterator;

	iterator begin(class Prealloced_array<Log_event*, 32> *);

	iterator end(class Prealloced_array<Log_event*, 32> *);

	const_iterator begin(const class Prealloced_array<Log_event*, 32>  *);

	const_iterator end(const class Prealloced_array<Log_event*, 32>  *);

	const_iterator cbegin(const class Prealloced_array<Log_event*, 32>  *);

	const_iterator cend(const class Prealloced_array<Log_event*, 32>  *);

	bool assign_at(class Prealloced_array<Log_event*, 32> *, size_t, const value_type  &);

	typedef class Log_event * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Log_event*, 32> *, size_t);

	bool push_back(class Prealloced_array<Log_event*, 32> *, class Log_event * const &);

	bool push_back(class Prealloced_array<Log_event*, 32> *, );

	void pop_back(class Prealloced_array<Log_event*, 32> *);

	iterator insert(class Prealloced_array<Log_event*, 32> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Log_event*, 32> *, const_iterator, );

	class pair<Log_event**, bool> insert_unique(class Prealloced_array<Log_event*, 32> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Log_event*, 32> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Log_event*, 32>  *, const value_type  &);

	iterator erase(class Prealloced_array<Log_event*, 32> *, const_iterator);

	iterator erase(class Prealloced_array<Log_event*, 32> *, size_t);

	void erase_at_end(class Prealloced_array<Log_event*, 32> *, const_iterator);

	iterator erase(class Prealloced_array<Log_event*, 32> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Log_event*, 32> *, class Prealloced_array<Log_event*, 32> &);

	void shrink_to_fit(class Prealloced_array<Log_event*, 32> *);

	void resize(class Prealloced_array<Log_event*, 32> *, size_t, class Log_event * const &);

	void clear(class Prealloced_array<Log_event*, 32> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Log_event *  m_buff[32];           /*     8   256 */
	};                                               /*     8   256 */

	/* size: 264, cachelines: 5, members: 3, static members: 2 */
	/* last cacheline: 8 bytes */
};
class Deferred_log_events {
	class Prealloced_array<Log_event*, 32> m_array;  /*     0   264 */
public:

	void Deferred_log_events(class Deferred_log_events *);

	void ~Deferred_log_events(class Deferred_log_events *, int);

	int add(class Deferred_log_events *, class Log_event *);

	bool is_empty(class Deferred_log_events *);

	bool execute(class Deferred_log_events *, class Relay_log_info *);

	void rewind(class Deferred_log_events *);


	/* size: 264, cachelines: 5, members: 1 */
	/* last cacheline: 8 bytes */
};
class base_ilist<i_string> {
	class i_string *           first;                /*     0     8 */
	class ilink<i_string>     sentinel;              /*     8    16 */
public:

	void clear(class base_ilist<i_string> *);

	void base_ilist(class base_ilist<i_string> *);

	bool is_empty(const class base_ilist<i_string>  *);

	void push_front(class base_ilist<i_string> *, class i_string *);

	void push_back(class base_ilist<i_string> *, class i_string *);

	class i_string * get(class base_ilist<i_string> *);

	class i_string * head(class base_ilist<i_string> *);

	void move_elements_to(class base_ilist<i_string> *, class base_ilist<i_string> *);

	void base_ilist(class base_ilist<i_string> *, const class base_ilist<i_string>  &);

	void operator=(class base_ilist<i_string> *, const class base_ilist<i_string>  &);


	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::al, reference);

	typedef class pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > & reference;

	typedef const class pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, st  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::al, const_reference);

	typedef const class pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, st  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocato, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocato, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocato, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocato, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::al);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::al);

	struct rebind<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > > > {
		typedef struct Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > > > other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > > > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > > * pointer;

public:

	pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsi, reference);

	typedef class _Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > > & reference;

	typedef const class _Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<u  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsi, const_reference);

	typedef const class _Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<u  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned c, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned c, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned c, pointer, size_type);

	void destroy(class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned c, pointer);

	size_type max_size(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsi);

	PSI_memory_key psi_key(const class Malloc_allocator<std::_Rb_tree_node<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsi);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class MDL_context_backup_manager {
	void MDL_context_backup_manager(class MDL_context_backup_manager *, PSI_memory_key);

	static class MDL_context_backup_manager * m_single; /*     0     0 */
public:

	void MDL_context_backup_manager(class MDL_context_backup_manager *, const class MDL_context_backup_manager  &);

	void operator=(class MDL_context_backup_manager *, const class MDL_context_backup_manager  &);

	bool init(void);

	class MDL_context_backup_manager & instance(void);

	void destroy(void);

	void ~MDL_context_backup_manager(class MDL_context_backup_manager *, int);

	void init_psi_keys(void);

	bool create_backup(class MDL_context_backup_manager *, const class MDL_context  *, const uchar  *, size_t);

	bool create_backup(class MDL_context_backup_manager *, MDL_request_list *, const uchar  *, size_t);

	bool restore_backup(class MDL_context_backup_manager *, class MDL_context *, const uchar  *, size_t);

	void delete_backup(class MDL_context_backup_manager *, const uchar  *, size_t);

	typedef struct map<std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> >, std::less<std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> > >, Malloc_allocator<std::pair<const std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >, std::unique_ptr<MDL_context_backup_manager::MDL_context_backup, std::default_delete<MDL_context_backup_manager::MDL_context_backup> > > > > Element_map_type;

	Element_map_type           m_backup_map;         /*     0    48 */
	struct mysql_mutex_t       m_LOCK_mdl_context_backup; /*    48    48 */
	bool check_key_exist(class MDL_context_backup_manager *, const MDL_context_backup_key  &);

	typedef struct basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> > MDL_context_backup_key;

	/* tag__fprintf: const_type tag not supported! */;


	/* size: 96, cachelines: 2, members: 2, static members: 1 */
	/* last cacheline: 32 bytes */
};
class Prealloced_array<THD*, 60> {
	struct External {
		class THD * *              m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class THD *                m_buff[60];           /*     0   480 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<THD*, 60>  *);

	class THD * * buffer(class Prealloced_array<THD*, 60> *);

	class THD * const * buffer(const class Prealloced_array<THD*, 60>  *);

	void set_size(class Prealloced_array<THD*, 60> *, size_t);

	void adjust_size(class Prealloced_array<THD*, 60> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<THD*, 60> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<THD*, 60> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<THD*, 60> *, const class Prealloced_array<THD*, 60>  &);

	void Prealloced_array(class Prealloced_array<THD*, 60> *, );

	void Prealloced_array(class Prealloced_array<THD*, 60> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class THD * const * const_iterator;

	void Prealloced_array(class Prealloced_array<THD*, 60> *, class initializer_list<THD*>);

	class Prealloced_array<THD*, 60> & operator=(class Prealloced_array<THD*, 60> *, const class Prealloced_array<THD*, 60>  &);

	class Prealloced_array<THD*, 60> & operator=(class Prealloced_array<THD*, 60> *, );

	void ~Prealloced_array(class Prealloced_array<THD*, 60> *, int);

	size_t capacity(const class Prealloced_array<THD*, 60>  *);

	size_t element_size(const class Prealloced_array<THD*, 60>  *);

	bool empty(const class Prealloced_array<THD*, 60>  *);

	size_t size(const class Prealloced_array<THD*, 60>  *);

	class THD * & at(class Prealloced_array<THD*, 60> *, size_t);

	class THD * const & at(const class Prealloced_array<THD*, 60>  *, size_t);

	class THD * & operator[](class Prealloced_array<THD*, 60> *, size_t);

	class THD * const & operator[](const class Prealloced_array<THD*, 60>  *, size_t);

	class THD * & back(class Prealloced_array<THD*, 60> *);

	class THD * const & back(const class Prealloced_array<THD*, 60>  *);

	class THD * & front(class Prealloced_array<THD*, 60> *);

	class THD * const & front(const class Prealloced_array<THD*, 60>  *);

	typedef class THD * * iterator;

	iterator begin(class Prealloced_array<THD*, 60> *);

	iterator end(class Prealloced_array<THD*, 60> *);

	const_iterator begin(const class Prealloced_array<THD*, 60>  *);

	const_iterator end(const class Prealloced_array<THD*, 60>  *);

	const_iterator cbegin(const class Prealloced_array<THD*, 60>  *);

	const_iterator cend(const class Prealloced_array<THD*, 60>  *);

	bool assign_at(class Prealloced_array<THD*, 60> *, size_t, const value_type  &);

	typedef class THD * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<THD*, 60> *, size_t);

	bool push_back(class Prealloced_array<THD*, 60> *, class THD * const &);

	bool push_back(class Prealloced_array<THD*, 60> *, );

	void pop_back(class Prealloced_array<THD*, 60> *);

	iterator insert(class Prealloced_array<THD*, 60> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<THD*, 60> *, const_iterator, );

	class pair<THD**, bool> insert_unique(class Prealloced_array<THD*, 60> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<THD*, 60> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<THD*, 60>  *, const value_type  &);

	iterator erase(class Prealloced_array<THD*, 60> *, const_iterator);

	iterator erase(class Prealloced_array<THD*, 60> *, size_t);

	void erase_at_end(class Prealloced_array<THD*, 60> *, const_iterator);

	iterator erase(class Prealloced_array<THD*, 60> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<THD*, 60> *, class Prealloced_array<THD*, 60> &);

	void shrink_to_fit(class Prealloced_array<THD*, 60> *);

	void resize(class Prealloced_array<THD*, 60> *, size_t, class THD * const &);

	void clear(class Prealloced_array<THD*, 60> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class THD *        m_buff[60];           /*     8   480 */
	};                                               /*     8   480 */

	/* size: 488, cachelines: 8, members: 3, static members: 2 */
	/* last cacheline: 40 bytes */
};
class Prealloced_array<unsigned int, 1000> {
	struct External {
		unsigned int *             m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		unsigned int               m_buff[1000];         /*     0  4000 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<unsigned int, 1000>  *);

	unsigned int * buffer(class Prealloced_array<unsigned int, 1000> *);

	const unsigned int  * buffer(const class Prealloced_array<unsigned int, 1000>  *);

	void set_size(class Prealloced_array<unsigned int, 1000> *, size_t);

	void adjust_size(class Prealloced_array<unsigned int, 1000> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<unsigned int, 1000> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<unsigned int, 1000> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<unsigned int, 1000> *, const class Prealloced_array<unsigned int, 1000>  &);

	void Prealloced_array(class Prealloced_array<unsigned int, 1000> *, );

	void Prealloced_array(class Prealloced_array<unsigned int, 1000> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const unsigned int  * const_iterator;

	void Prealloced_array(class Prealloced_array<unsigned int, 1000> *, class initializer_list<unsigned int>);

	class Prealloced_array<unsigned int, 1000> & operator=(class Prealloced_array<unsigned int, 1000> *, const class Prealloced_array<unsigned int, 1000>  &);

	class Prealloced_array<unsigned int, 1000> & operator=(class Prealloced_array<unsigned int, 1000> *, );

	void ~Prealloced_array(class Prealloced_array<unsigned int, 1000> *, int);

	size_t capacity(const class Prealloced_array<unsigned int, 1000>  *);

	size_t element_size(const class Prealloced_array<unsigned int, 1000>  *);

	bool empty(const class Prealloced_array<unsigned int, 1000>  *);

	size_t size(const class Prealloced_array<unsigned int, 1000>  *);

	unsigned int & at(class Prealloced_array<unsigned int, 1000> *, size_t);

	const unsigned int  & at(const class Prealloced_array<unsigned int, 1000>  *, size_t);

	unsigned int & operator[](class Prealloced_array<unsigned int, 1000> *, size_t);

	const unsigned int  & operator[](const class Prealloced_array<unsigned int, 1000>  *, size_t);

	unsigned int & back(class Prealloced_array<unsigned int, 1000> *);

	const unsigned int  & back(const class Prealloced_array<unsigned int, 1000>  *);

	unsigned int & front(class Prealloced_array<unsigned int, 1000> *);

	const unsigned int  & front(const class Prealloced_array<unsigned int, 1000>  *);

	typedef unsigned int * iterator;

	iterator begin(class Prealloced_array<unsigned int, 1000> *);

	iterator end(class Prealloced_array<unsigned int, 1000> *);

	const_iterator begin(const class Prealloced_array<unsigned int, 1000>  *);

	const_iterator end(const class Prealloced_array<unsigned int, 1000>  *);

	const_iterator cbegin(const class Prealloced_array<unsigned int, 1000>  *);

	const_iterator cend(const class Prealloced_array<unsigned int, 1000>  *);

	bool assign_at(class Prealloced_array<unsigned int, 1000> *, size_t, const value_type  &);

	typedef unsigned int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<unsigned int, 1000> *, size_t);

	bool push_back(class Prealloced_array<unsigned int, 1000> *, const unsigned int  &);

	bool push_back(class Prealloced_array<unsigned int, 1000> *, );

	void pop_back(class Prealloced_array<unsigned int, 1000> *);

	iterator insert(class Prealloced_array<unsigned int, 1000> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<unsigned int, 1000> *, const_iterator, );

	class pair<unsigned int*, bool> insert_unique(class Prealloced_array<unsigned int, 1000> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<unsigned int, 1000> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<unsigned int, 1000>  *, const value_type  &);

	iterator erase(class Prealloced_array<unsigned int, 1000> *, const_iterator);

	iterator erase(class Prealloced_array<unsigned int, 1000> *, size_t);

	void erase_at_end(class Prealloced_array<unsigned int, 1000> *, const_iterator);

	iterator erase(class Prealloced_array<unsigned int, 1000> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<unsigned int, 1000> *, class Prealloced_array<unsigned int, 1000> &);

	void shrink_to_fit(class Prealloced_array<unsigned int, 1000> *);

	void resize(class Prealloced_array<unsigned int, 1000> *, size_t, const unsigned int  &);

	void clear(class Prealloced_array<unsigned int, 1000> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		unsigned int       m_buff[1000];         /*     8  4000 */
	};                                               /*     8  4000 */

	/* size: 4008, cachelines: 63, members: 3, static members: 2 */
	/* last cacheline: 40 bytes */
};
class Global_THD_manager {
public:

	static const my_thread_id         reserved_thread_id; /*     0     0 */
	class Global_THD_manager * get_instance(void);

	bool create_instance(void);

	void destroy_instance(void);

	void set_unit_test(class Global_THD_manager *);

	void add_thd(class Global_THD_manager *, class THD *);

	void remove_thd(class Global_THD_manager *, class THD *);

	int get_num_thread_running(const class Global_THD_manager  *);

	void inc_thread_running(class Global_THD_manager *);

	void dec_thread_running(class Global_THD_manager *);

	ulonglong get_num_thread_created(const class Global_THD_manager  *);

	void inc_thread_created(class Global_THD_manager *);

	my_thread_id get_new_thread_id(class Global_THD_manager *);

	void release_thread_id(class Global_THD_manager *, my_thread_id);

	my_thread_id get_thread_id(const class Global_THD_manager  *);

	void set_thread_id_counter(class Global_THD_manager *, my_thread_id);

	uint get_thd_count(void);

	void wait_till_no_thd(class Global_THD_manager *);

	void do_for_all_thd_copy(class Global_THD_manager *, class Do_THD_Impl *);

	void do_for_all_thd(class Global_THD_manager *, class Do_THD_Impl *);

	class THD * find_thd(class Global_THD_manager *, class Find_THD_Impl *);

	class THD * find_thd(class Global_THD_manager *, class Find_thd_with_id *);

	static struct atomic<unsigned int> atomic_global_thd_count; /*     0     0 */
	static const int                  NUM_PARTITIONS = 8; /*     0     0 */
	void Global_THD_manager(class Global_THD_manager *);

	void ~Global_THD_manager(class Global_THD_manager *, int);

	static class Global_THD_manager * thd_manager;   /*     0     0 */
	typedef struct Prealloced_array<THD*, 60> THD_array;

	THD_array                  thd_list[8];          /*     0  3904 */
	typedef struct Prealloced_array<unsigned int, 1000> Thread_id_array;

	/* --- cacheline 61 boundary (3904 bytes) --- */
	Thread_id_array            thread_ids;           /*  3904  4008 */
	/* --- cacheline 123 boundary (7872 bytes) was 40 bytes ago --- */
	struct mysql_cond_t        COND_thd_list[8];     /*  7912   448 */
	/* --- cacheline 130 boundary (8320 bytes) was 40 bytes ago --- */
	struct mysql_mutex_t       LOCK_thd_list[8];     /*  8360   384 */
	/* --- cacheline 136 boundary (8704 bytes) was 40 bytes ago --- */
	struct mysql_mutex_t       LOCK_thd_remove[8];   /*  8744   384 */
	/* --- cacheline 142 boundary (9088 bytes) was 40 bytes ago --- */
	struct mysql_mutex_t       LOCK_thread_ids;      /*  9128    48 */
	/* --- cacheline 143 boundary (9152 bytes) was 24 bytes ago --- */
	struct atomic<int>         atomic_num_thread_running __attribute__((__aligned__(4))); /*  9176     4 */

	/* XXX 4 bytes hole, try to pack */

	struct atomic<long long unsigned int> atomic_thread_created __attribute__((__aligned__(8))); /*  9184     8 */
	my_thread_id               thread_id_counter;    /*  9192     4 */
	bool                       unit_test;            /*  9196     1 */

	/* size: 9200, cachelines: 144, members: 10, static members: 4 */
	/* sum members: 9193, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* forced alignments: 2, forced holes: 1, sum forced holes: 4 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
class Find_THD_Impl {
public:

	void Find_THD_Impl(class Find_THD_Impl *, const class Find_THD_Impl  &);

	void Find_THD_Impl(class Find_THD_Impl *);

	int ()(void) * *           _vptr.Find_THD_Impl;  /*     0     8 */
	virtual void ~Find_THD_Impl(class Find_THD_Impl *, int);

	virtual bool operator()(class Find_THD_Impl *, class THD *);

	/* vtable has 1 entries: {
	   [2] = operator()((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Destroy_only<RowIterator> {
public:

	void operator()(const class Destroy_only<RowIterator>  *, class RowIterator *);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class RowIterator {
public:

	void RowIterator(class RowIterator *, const class RowIterator  &);

	int ()(void) * *           _vptr.RowIterator;    /*     0     8 */
	void RowIterator(class RowIterator *, class THD *);

	virtual void ~RowIterator(class RowIterator *, int);

	virtual bool Init(class RowIterator *);

	virtual int Read(class RowIterator *);

	virtual void SetNullRowFlag(class RowIterator *, bool);

	virtual void UnlockRow(class RowIterator *);

	virtual string TimingString(const class RowIterator  *);

	virtual void StartPSIBatchMode(class RowIterator *);

	virtual void EndPSIBatchModeIfStarted(class RowIterator *);

	virtual class RowIterator * real_iterator(class RowIterator *);

	virtual const class RowIterator  * real_iterator(const class RowIterator  *);

protected:

	class THD * thd(const class RowIterator  *);

	const class THD *          m_thd;                /*     8     8 */
	/* vtable has 9 entries: {
	   [2] = Init((null)), 
	   [3] = Read((null)), 
	   [4] = SetNullRowFlag((null)), 
	   [5] = UnlockRow((null)), 
	   [6] = TimingString((null)), 
	   [7] = StartPSIBatchMode((null)), 
	   [8] = EndPSIBatchModeIfStarted((null)), 
	   [9] = real_iterator((null)), 
	   [10] = real_iterator((null)), 
	} */
	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Destroy_only<SubqueryWithResult> {
public:

	void operator()(const class Destroy_only<SubqueryWithResult>  *, class SubqueryWithResult *);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class SubqueryWithResult {
public:

	void SubqueryWithResult(class SubqueryWithResult *, class Query_expression *, class Query_result_interceptor *, class Item_subselect *);

	void cleanup(class SubqueryWithResult *, class THD *);

	bool prepare(class SubqueryWithResult *, class THD *);

	void fix_length_and_dec(class SubqueryWithResult *, class Item_cache * *);

	bool exec(class SubqueryWithResult *, class THD *);

	void print(class SubqueryWithResult *, const class THD  *, class String *, enum enum_query_type);

	bool change_query_result(class SubqueryWithResult *, class THD *, class Item_subselect *, class Query_result_subquery *);

	class Query_block * single_query_block(const class SubqueryWithResult  *);

	enum Item_result type(const class SubqueryWithResult  *);

	enum enum_field_types field_type(const class SubqueryWithResult  *);

	bool may_be_null(const class SubqueryWithResult  *);

	class Query_result_interceptor * result;         /*     0     8 */
	class Item_subselect *     item;                 /*     8     8 */
	enum Item_result           res_type;             /*    16     4 */
	enum enum_field_types      res_field_type;       /*    20     4 */
	bool                       maybe_null;           /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	class Query_expression *   unit;                 /*    32     8 */
	void set_row(class SubqueryWithResult *, const class mem_root_deque<Item*>  &, class Item_cache * *, bool);


	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
class Query_result_interceptor : public Query_result {
public:

	/* class Query_result        <ancestor>; */      /*     0     0 */
	void Query_result_interceptor(class Query_result_interceptor *, );

	void Query_result_interceptor(class Query_result_interceptor *, const class Query_result_interceptor  &);

	void Query_result_interceptor(class Query_result_interceptor *);

	virtual uint field_count(const class Query_result_interceptor  *, const class mem_root_deque<Item*>  &);

	virtual bool send_result_set_metadata(class Query_result_interceptor *, class THD *, const class mem_root_deque<Item*>  &, uint);

	virtual bool is_interceptor(const class Query_result_interceptor  *);

	virtual void ~Query_result_interceptor(class Query_result_interceptor *, int);

	/* vtable has 3 entries: {
	   [9] = field_count((null)), 
	   [10] = send_result_set_metadata((null)), 
	   [19] = is_interceptor((null)), 
	} */
	/* size: 32, cachelines: 1, members: 1 */
	/* padding: 32 */
	/* last cacheline: 32 bytes */
};
class Query_result_subquery : public Query_result_interceptor {
public:

	/* class Query_result_interceptor <ancestor>; */ /*     0    32 */

	/* XXX last struct has 32 bytes of padding */
protected:


	class Item_subselect *     item;                 /*    32     8 */
public:

	void Query_result_subquery(class Query_result_subquery *, class Item_subselect *);

	virtual bool send_data(class Query_result_subquery *, class THD *, const class mem_root_deque<Item*>  &);

	virtual bool send_eof(class Query_result_subquery *, class THD *);

	virtual void ~Query_result_subquery(class Query_result_subquery *, int);

	/* vtable has 2 entries: {
	   [11] = send_data((null)), 
	   [13] = send_eof((null)), 
	} */
	/* size: 40, cachelines: 1, members: 2 */
	/* paddings: 1, sum paddings: 32 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 40 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
struct MaterializePathParameters {
	struct QueryBlock {
		class AccessPath *         subquery_path;        /*     0     8 */
		int                        select_number;        /*     8     4 */

		/* XXX 4 bytes hole, try to pack */

		class JOIN *               join;                 /*    16     8 */
		bool                       disable_deduplication_by_hash_field; /*    24     1 */
		bool                       copy_items;           /*    25     1 */

		/* XXX 6 bytes hole, try to pack */

		class Temp_table_param *   temp_table_param;     /*    32     8 */
		bool                       is_recursive_reference; /*    40     1 */

		/* size: 48, cachelines: 1, members: 7 */
		/* sum members: 31, holes: 2, sum holes: 10 */
		/* padding: 7 */
		/* last cacheline: 48 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Mem_root_array<MaterializePathParameters::QueryBlock> query_blocks; /*     0    32 */
	class Mem_root_array<const AccessPath*> * invalidators; /*    32     8 */
	class TABLE *              table;                /*    40     8 */
	class Common_table_expr *  cte;                  /*    48     8 */
	class Query_expression *   unit;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        ref_slice;            /*    64     4 */
	bool                       rematerialize;        /*    68     1 */

	/* XXX 3 bytes hole, try to pack */

	ha_rows                    limit_rows;           /*    72     8 */
	bool                       reject_multiple_rows; /*    80     1 */

	/* size: 88, cachelines: 2, members: 9 */
	/* sum members: 78, holes: 1, sum holes: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
class Mem_root_array_YY<MaterializePathParameters::QueryBlock> {
	static const bool                 has_trivial_destructor = 1; /*     0     0 */
public:

	void init(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, class MEM_ROOT *);

	void init_empty_const(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *);

	class QueryBlock & at(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, size_t);

	const class QueryBlock  & at(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *, size_t);

	class QueryBlock & operator[](class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, size_t);

	const class QueryBlock  & operator[](const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *, size_t);

	class QueryBlock & back(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *);

	const class QueryBlock  & back(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	class QueryBlock * begin(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *);

	const class QueryBlock  * begin(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	class QueryBlock * end(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *);

	const class QueryBlock  * end(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	typedef const class QueryBlock  * const_iterator;

	const_iterator cbegin(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	const_iterator cend(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	void clear(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *);

	void chop(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, size_t);

	bool reserve(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, size_t);

	bool push_back(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, const class QueryBlock  &);

	bool push_back(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, );

	bool push_front(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, const class QueryBlock  &);

	bool push_front(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, );

	void pop_back(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *);

	void resize(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, size_t, const value_type  &);

	typedef struct QueryBlock value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void resize(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, size_t);

	typedef class QueryBlock * iterator;

	iterator erase(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, const_iterator, const_iterator);

	iterator erase(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, const_iterator);

	iterator erase(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, size_t);

	iterator insert(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, const_iterator, const class QueryBlock  &);

	size_t erase_value(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, const value_type  &);

	iterator erase(class Mem_root_array_YY<MaterializePathParameters::QueryBlock> *, iterator);

	size_t capacity(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	size_t element_size(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	bool empty(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

	size_t size(const class Mem_root_array_YY<MaterializePathParameters::QueryBlock>  *);

protected:

	class MEM_ROOT *           m_root;               /*     0     8 */
	class QueryBlock *         m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4, static members: 1 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<MaterializePathParameters::QueryBlock> : public Mem_root_array_YY<MaterializePathParameters::QueryBlock> {
public:

	/* class Mem_root_array_YY<MaterializePathParameters::QueryBlock> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *);

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, class MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, );

	class Mem_root_array<MaterializePathParameters::QueryBlock> & operator=(class Mem_root_array<MaterializePathParameters::QueryBlock> *, );

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, class MEM_ROOT *, size_t);

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, class MEM_ROOT *, size_t, const value_type  &);

	typedef struct QueryBlock value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, class MEM_ROOT *, const_iterator, const_iterator);

	typedef const_iterator const_iterator;

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, class MEM_ROOT *, const class Mem_root_array<MaterializePathParameters::QueryBlock>  &);

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, class initializer_list<MaterializePathParameters::QueryBlock>);

	void ~Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, int);

	void Mem_root_array(class Mem_root_array<MaterializePathParameters::QueryBlock> *, const class Mem_root_array<MaterializePathParameters::QueryBlock>  &);

	class Mem_root_array<MaterializePathParameters::QueryBlock> & operator=(class Mem_root_array<MaterializePathParameters::QueryBlock> *, const class Mem_root_array<MaterializePathParameters::QueryBlock>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
struct SYMBOL {
	const char  *              name;                 /*     0     8 */
	const unsigned int         length;               /*     8     4 */
	const unsigned int         tok;                  /*    12     4 */
	int                        group;                /*    16     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct LEX_SYMBOL {
	const class SYMBOL  *      symbol;               /*     0     8 */
	char *                     str;                  /*     8     8 */
	unsigned int               length;               /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
union Lexer_yystype {
	LEX_STRING                 lex_str;            /*     0    16 */
	struct LEX_SYMBOL          keyword;            /*     0    24 */
	const class CHARSET_INFO  * charset;           /*     0     8 */
	class PT_hint_list *       optimizer_hints;    /*     0     8 */
	LEX_CSTRING                hint_string;        /*     0    16 */
};
class List<Item_equal> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Item_equal> *);

	void List(class List<Item_equal> *, const class List<Item_equal>  &);

	class List<Item_equal> & operator=(class List<Item_equal> *, const class List<Item_equal>  &);

	void List(class List<Item_equal> *, const class List<Item_equal>  &, class MEM_ROOT *);

	bool push_back(class List<Item_equal> *, class Item_equal *);

	bool push_back(class List<Item_equal> *, class Item_equal *, class MEM_ROOT *);

	bool push_front(class List<Item_equal> *, class Item_equal *);

	bool push_front(class List<Item_equal> *, class Item_equal *, class MEM_ROOT *);

	class Item_equal * head(class List<Item_equal> *);

	const class Item_equal  * head(const class List<Item_equal>  *);

	class Item_equal * * head_ref(class List<Item_equal> *);

	class Item_equal * pop(class List<Item_equal> *);

	void concat(class List<Item_equal> *, class List<Item_equal> *);

	void disjoin(class List<Item_equal> *, class List<Item_equal> *);

	void prepend(class List<Item_equal> *, class List<Item_equal> *);

	void delete_elements(class List<Item_equal> *);

	void destroy_elements(class List<Item_equal> *);

	class Item_equal * operator[](const class List<Item_equal>  *, uint);

	void replace(class List<Item_equal> *, uint, class Item_equal *);

	bool swap_elts(class List<Item_equal> *, uint, uint);

	typedef struct List_STL_Iterator<Item_equal> iterator;

	iterator begin(class List<Item_equal> *);

	iterator end(class List<Item_equal> *);

	typedef struct List_STL_Iterator<const Item_equal> const_iterator;

	const_iterator begin(const class List<Item_equal>  *);

	const_iterator end(const class List<Item_equal>  *);

	const_iterator cbegin(const class List<Item_equal>  *);

	const_iterator cend(const class List<Item_equal>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct TABLE_REF {
	bool                       key_err;              /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       key_parts;            /*     4     4 */
	uint                       key_length;           /*     8     4 */
	int                        key;                  /*    12     4 */
	uchar *                    key_buff;             /*    16     8 */
	uchar *                    key_buff2;            /*    24     8 */
	class store_key * *        key_copy;             /*    32     8 */
	class Item * *             items;                /*    40     8 */
	bool * *                   cond_guards;          /*    48     8 */
	key_part_map               null_rejecting;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	table_map                  depend_map;           /*    64     8 */
	uchar *                    null_ref_key;         /*    72     8 */
	ha_rows                    use_count;            /*    80     8 */
	bool                       disable_cache;        /*    88     1 */

	/* XXX 7 bytes hole, try to pack */

	ulonglong *                keypart_hash;         /*    96     8 */
	void TABLE_REF(class TABLE_REF *);

	bool impossible_null_ref(const class TABLE_REF  *);

	bool has_guarded_conds(const class TABLE_REF  *);


	/* size: 104, cachelines: 2, members: 15 */
	/* sum members: 94, holes: 2, sum holes: 10 */
	/* last cacheline: 40 bytes */
};
class store_key {
	enum store_key_result {
		STORE_KEY_OK    = 0,
		STORE_KEY_FATAL = 1,
		STORE_KEY_CONV  = 2,
	};

public:

	void store_key(class store_key *, const class store_key  &);

	int ()(void) * *           _vptr.store_key;      /*     0     8 */
	bool                       null_key;             /*     8     1 */

	/* XXX 7 bytes hole, try to pack */
	void store_key(class store_key *, class THD *, class Field *, uchar *, uchar *, uint);

	virtual void ~store_key(class store_key *, int);

	virtual const char  * name(const class store_key  *);

	enum store_key_result copy(class store_key *);

protected:


	class Field *              to_field;             /*    16     8 */
	virtual enum store_key_result copy_inner(class store_key *);

	/* vtable has 2 entries: {
	   [2] = name((null)), 
	   [3] = copy_inner((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
class QEP_shared {
public:

	void QEP_shared(class QEP_shared *);

	class JOIN * join(const class QEP_shared  *);

	void set_join(class QEP_shared *, class JOIN *);

	plan_idx idx(const class QEP_shared  *);

	void set_idx(class QEP_shared *, plan_idx);

	class TABLE * table(const class QEP_shared  *);

	void set_table(class QEP_shared *, class TABLE *);

	class POSITION * position(const class QEP_shared  *);

	void set_position(class QEP_shared *, class POSITION *);

	class Semijoin_mat_exec * sj_mat_exec(const class QEP_shared  *);

	void set_sj_mat_exec(class QEP_shared *, class Semijoin_mat_exec *);

	plan_idx first_sj_inner(class QEP_shared *);

	plan_idx last_sj_inner(class QEP_shared *);

	plan_idx first_inner(class QEP_shared *);

	void set_first_inner(class QEP_shared *, plan_idx);

	void set_last_inner(class QEP_shared *, plan_idx);

	void set_first_sj_inner(class QEP_shared *, plan_idx);

	void set_last_sj_inner(class QEP_shared *, plan_idx);

	void set_first_upper(class QEP_shared *, plan_idx);

	plan_idx last_inner(class QEP_shared *);

	plan_idx first_upper(class QEP_shared *);

	class TABLE_REF & ref(class QEP_shared *);

	uint index(const class QEP_shared  *);

	void set_index(class QEP_shared *, uint);

	enum join_type type(const class QEP_shared  *);

	void set_type(class QEP_shared *, enum join_type);

	class Item * condition(const class QEP_shared  *);

	void set_condition(class QEP_shared *, class Item *);

	bool condition_is_pushed_to_sort(const class QEP_shared  *);

	void mark_condition_as_pushed_to_sort(class QEP_shared *);

	Key_map & keys(class QEP_shared *);

	ha_rows records(const class QEP_shared  *);

	void set_records(class QEP_shared *, ha_rows);

	class QUICK_SELECT_I * quick(const class QEP_shared  *);

	void set_quick(class QEP_shared *, class QUICK_SELECT_I *);

	table_map prefix_tables(const class QEP_shared  *);

	table_map added_tables(const class QEP_shared  *);

	class Item_func_match * ft_func(const class QEP_shared  *);

	void set_ft_func(class QEP_shared *, class Item_func_match *);

	void set_prefix_tables(class QEP_shared *, table_map, table_map);

	void add_prefix_tables(class QEP_shared *, table_map);

	bool is_first_inner_for_outer_join(const class QEP_shared  *);

	bool is_inner_table_of_outer_join(const class QEP_shared  *);

	bool is_single_inner_of_semi_join(const class QEP_shared  *);

	bool is_single_inner_of_outer_join(const class QEP_shared  *);

	void set_skip_records_in_range(class QEP_shared *, bool);

	bool skip_records_in_range(const class QEP_shared  *);

	class JOIN *               m_join;               /*     0     8 */
	plan_idx                   m_idx;                /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	class TABLE *              m_table;              /*    16     8 */
	class POSITION *           m_position;           /*    24     8 */
	class Semijoin_mat_exec *  m_sj_mat_exec;        /*    32     8 */
	plan_idx                   m_first_sj_inner;     /*    40     1 */
	plan_idx                   m_last_sj_inner;      /*    41     1 */
	plan_idx                   m_first_inner;        /*    42     1 */
	plan_idx                   m_last_inner;         /*    43     1 */
	plan_idx                   m_first_upper;        /*    44     1 */

	/* XXX 3 bytes hole, try to pack */

	struct TABLE_REF           m_ref;                /*    48   104 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	uint                       m_index;              /*   152     4 */
	enum join_type             m_type;               /*   156     4 */
	class Item *               m_condition;          /*   160     8 */
	bool                       m_condition_is_pushed_to_sort; /*   168     1 */

	/* XXX 7 bytes hole, try to pack */

	Key_map                    m_keys;               /*   176     8 */
	ha_rows                    m_records;            /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	class QUICK_SELECT_I *     m_quick;              /*   192     8 */
	table_map                  prefix_tables_map;    /*   200     8 */
	table_map                  added_tables_map;     /*   208     8 */
	class Item_func_match *    m_ft_func;            /*   216     8 */
	bool                       m_skip_records_in_range; /*   224     1 */

	/* size: 232, cachelines: 4, members: 22 */
	/* sum members: 208, holes: 3, sum holes: 17 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
struct POSITION {
	double                     rows_fetched;         /*     0     8 */
	double                     read_cost;            /*     8     8 */
	float                      filter_effect;        /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	double                     prefix_rowcount;      /*    24     8 */
	double                     prefix_cost;          /*    32     8 */
	class JOIN_TAB *           table;                /*    40     8 */
	class Key_use *            key;                  /*    48     8 */
	table_map                  ref_depend_map;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       use_join_buffer;      /*    64     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       sj_strategy;          /*    68     4 */
	uint                       n_sj_tables;          /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	table_map                  dups_producing_tables; /*    80     8 */
	uint                       first_loosescan_table; /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	table_map                  loosescan_need_tables; /*    96     8 */
	uint                       loosescan_key;        /*   104     4 */
	uint                       loosescan_parts;      /*   108     4 */
	uint                       first_firstmatch_table; /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	nested_join_map            cur_embedding_map;    /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	table_map                  first_firstmatch_rtbl; /*   128     8 */
	table_map                  firstmatch_need_tables; /*   136     8 */
	uint                       first_dupsweedout_table; /*   144     4 */

	/* XXX 4 bytes hole, try to pack */

	table_map                  dupsweedout_tables;   /*   152     8 */
	uint                       sjm_scan_last_inner;  /*   160     4 */

	/* XXX 4 bytes hole, try to pack */

	table_map                  sjm_scan_need_tables; /*   168     8 */
	void no_semijoin(class POSITION *);

	void set_prefix_cost(class POSITION *, double, double);

	void set_prefix_join_cost(class POSITION *, uint, const class Cost_model_server  *);

	void set_suffix_lateral_deps(class POSITION *, table_map);

	table_map get_suffix_lateral_deps(const class POSITION  *);

private:

	table_map                  m_suffix_lateral_deps; /*   176     8 */

	/* size: 184, cachelines: 3, members: 25 */
	/* sum members: 157, holes: 7, sum holes: 27 */
	/* last cacheline: 56 bytes */
};
class QEP_shared_owner {
public:

	void QEP_shared_owner(class QEP_shared_owner *);

	void share_qs(class QEP_shared_owner *, class QEP_shared_owner *);

	void set_qs(class QEP_shared_owner *, class QEP_shared *);

	class JOIN * join(const class QEP_shared_owner  *);

	void set_join(class QEP_shared_owner *, class JOIN *);

	plan_idx idx(const class QEP_shared_owner  *);

	void set_idx(class QEP_shared_owner *, plan_idx);

	qep_tab_map idx_map(const class QEP_shared_owner  *);

	class TABLE * table(const class QEP_shared_owner  *);

	class POSITION * position(const class QEP_shared_owner  *);

	void set_position(class QEP_shared_owner *, class POSITION *);

	class Semijoin_mat_exec * sj_mat_exec(const class QEP_shared_owner  *);

	void set_sj_mat_exec(class QEP_shared_owner *, class Semijoin_mat_exec *);

	plan_idx first_sj_inner(const class QEP_shared_owner  *);

	plan_idx last_sj_inner(const class QEP_shared_owner  *);

	plan_idx first_inner(const class QEP_shared_owner  *);

	plan_idx last_inner(const class QEP_shared_owner  *);

	plan_idx first_upper(const class QEP_shared_owner  *);

	void set_first_inner(class QEP_shared_owner *, plan_idx);

	void set_last_inner(class QEP_shared_owner *, plan_idx);

	void set_first_sj_inner(class QEP_shared_owner *, plan_idx);

	void set_last_sj_inner(class QEP_shared_owner *, plan_idx);

	void set_first_upper(class QEP_shared_owner *, plan_idx);

	class TABLE_REF & ref(const class QEP_shared_owner  *);

	uint index(const class QEP_shared_owner  *);

	void set_index(class QEP_shared_owner *, uint);

	enum join_type type(const class QEP_shared_owner  *);

	void set_type(class QEP_shared_owner *, enum join_type);

	class Item * condition(const class QEP_shared_owner  *);

	void set_condition(class QEP_shared_owner *, class Item *);

	bool condition_is_pushed_to_sort(const class QEP_shared_owner  *);

	void mark_condition_as_pushed_to_sort(class QEP_shared_owner *);

	Key_map & keys(const class QEP_shared_owner  *);

	ha_rows records(const class QEP_shared_owner  *);

	void set_records(class QEP_shared_owner *, ha_rows);

	class QUICK_SELECT_I * quick(const class QEP_shared_owner  *);

	void set_quick(class QEP_shared_owner *, class QUICK_SELECT_I *);

	table_map prefix_tables(const class QEP_shared_owner  *);

	table_map added_tables(const class QEP_shared_owner  *);

	class Item_func_match * ft_func(const class QEP_shared_owner  *);

	void set_ft_func(class QEP_shared_owner *, class Item_func_match *);

	void set_prefix_tables(class QEP_shared_owner *, table_map, table_map);

	void add_prefix_tables(class QEP_shared_owner *, table_map);

	bool is_single_inner_of_semi_join(const class QEP_shared_owner  *);

	bool is_inner_table_of_outer_join(const class QEP_shared_owner  *);

	bool is_first_inner_for_outer_join(const class QEP_shared_owner  *);

	bool is_single_inner_for_outer_join(const class QEP_shared_owner  *);

	bool has_guarded_conds(const class QEP_shared_owner  *);

	bool and_with_condition(class QEP_shared_owner *, class Item *);

	void set_skip_records_in_range(class QEP_shared_owner *, bool);

	bool skip_records_in_range(const class QEP_shared_owner  *);

	void qs_cleanup(class QEP_shared_owner *);

protected:

	class QEP_shared *         m_qs;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Key_use {
public:

	void Key_use(class Key_use *);

	void Key_use(class Key_use *, class TABLE_LIST *, class Item *, table_map, uint, uint, uint, key_part_map, ha_rows, bool, bool *, uint);

	class TABLE_LIST *         table_ref;            /*     0     8 */
	class Item *               val;                  /*     8     8 */
	table_map                  used_tables;          /*    16     8 */
	uint                       key;                  /*    24     4 */
	uint                       keypart;              /*    28     4 */
	uint                       optimize;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	key_part_map               keypart_map;          /*    40     8 */
	ha_rows                    ref_table_rows;       /*    48     8 */
	bool                       null_rejecting;       /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	bool *                     cond_guard;           /*    64     8 */
	uint                       sj_pred_no;           /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	key_part_map               bound_keyparts;       /*    80     8 */
	double                     fanout;               /*    88     8 */
	double                     read_cost;            /*    96     8 */

	/* size: 104, cachelines: 2, members: 14 */
	/* sum members: 89, holes: 3, sum holes: 15 */
	/* last cacheline: 40 bytes */
};
class Create_field {
public:

	size_t max_display_width_in_codepoints(const class Create_field  *);

	size_t max_display_width_in_bytes(const class Create_field  *);

	size_t pack_length(const class Create_field  *, bool);

	size_t key_length(const class Create_field  *);

	bool explicit_display_width(const class Create_field  *);

	void set_max_display_width_from_create_field(class Create_field *, const class Create_field  &);

	enum enum_hidden_type      hidden;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              field_name;           /*     8     8 */
	const char  *              change;               /*    16     8 */
	const char  *              after;                /*    24     8 */
	LEX_CSTRING                comment;              /*    32    16 */
	class Item *               constant_default;     /*    48     8 */
	enum enum_field_types      sql_type;             /*    56     4 */
	uint                       decimals;             /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint                       flags;                /*    64     4 */
	uchar                      auto_flags;           /*    68     1 */

	/* XXX 3 bytes hole, try to pack */

	class TYPELIB *            interval;             /*    72     8 */
	class List<String>        interval_list;         /*    80    24 */
	const class CHARSET_INFO  * charset;             /*   104     8 */
	bool                       is_explicit_collation; /*   112     1 */

	/* XXX 3 bytes hole, try to pack */

	enum geometry_type         geom_type;            /*   116     4 */
	class Field *              field;                /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint                       offset;               /*   128     4 */
	bool                       is_nullable;          /*   132     1 */
	bool                       is_zerofill;          /*   133     1 */
	bool                       is_unsigned;          /*   134     1 */
	bool                       treat_bit_as_char;    /*   135     1 */
	uint                       pack_length_override; /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	LEX_CSTRING                zip_dict_name;        /*   144    16 */
	class Value_generator *    gcol_info;            /*   160     8 */
	bool                       stored_in_db;         /*   168     1 */

	/* XXX 7 bytes hole, try to pack */

	class Value_generator *    m_default_val_expr;   /*   176     8 */
	class Nullable<unsigned int> m_srid;             /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	bool                       is_array;             /*   192     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   zip_dict_id;          /*   200     8 */
	LEX_CSTRING                m_engine_attribute;   /*   208    16 */
	LEX_CSTRING                m_secondary_engine_attribute; /*   224    16 */
	void Create_field(class Create_field *);

	void Create_field(class Create_field *, class Field *, class Field *);

	class Create_field * clone(const class Create_field  *, class MEM_ROOT *);

	bool is_gcol(const class Create_field  *);

	bool is_virtual_gcol(const class Create_field  *);

	void init_for_tmp_table(class Create_field *, enum enum_field_types, uint32, uint32, bool, bool, uint, const char  *);

	bool init(class Create_field *, class THD *, const char  *, enum enum_field_types, const char  *, const char  *, uint, class Item *, class Item *, const LEX_CSTRING  *, const char  *, class List<String> *, const class CHARSET_INFO  *, bool, uint, const LEX_CSTRING  *, class Value_generator *, class Value_generator *, class Nullable<unsigned int>, enum enum_hidden_type, bool);

	enum ha_storage_media field_storage_type(const class Create_field  *);

	enum column_format_type column_format(const class Create_field  *);

	void set_column_format(class Create_field *, enum column_format_type);

	size_t                     m_max_display_width_in_codepoints; /*   240     8 */
	bool                       m_explicit_display_width; /*   248     1 */

	/* size: 256, cachelines: 4, members: 33 */
	/* sum members: 221, holes: 6, sum holes: 28 */
	/* padding: 7 */
};
class Table_ident {
public:

	LEX_CSTRING                db;                   /*     0    16 */
	LEX_CSTRING                table;                /*    16    16 */
	class Query_expression *   sel;                  /*    32     8 */
	class Table_function *     table_function;       /*    40     8 */
	void Table_ident(class Table_ident *, class Protocol *, const LEX_CSTRING  &, const LEX_CSTRING  &, bool);

	void Table_ident(class Table_ident *, const LEX_CSTRING  &, const LEX_CSTRING  &);

	void Table_ident(class Table_ident *, const LEX_CSTRING  &);

	void Table_ident(class Table_ident *, class Query_expression *);

	void Table_ident(class Table_ident *, LEX_CSTRING &, class Table_function *);

	bool is_table_function(const class Table_ident  *);

	bool is_derived_table(const class Table_ident  *);

	void change_db(class Table_ident *, const char  *);


	/* size: 48, cachelines: 1, members: 4 */
	/* last cacheline: 48 bytes */
};
class sp_name {
public:

	LEX_CSTRING                m_db;                 /*     0    16 */
	LEX_STRING                 m_name;               /*    16    16 */
	LEX_STRING                 m_qname;              /*    32    16 */
	bool                       m_explicit_name;      /*    48     1 */
	void sp_name(class sp_name *, const LEX_CSTRING  &, const LEX_STRING  &, bool);

	void sp_name(class sp_name *, const class Sroutine_hash_entry  *, char *);

	void init_qname(class sp_name *, class THD *);


	/* size: 56, cachelines: 1, members: 4 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
class sp_head {
public:

	enum enum_sp_type          m_type;               /*     0     4 */
	uint                       m_flags;              /*     4     4 */
	PSI_sp_share *             m_sp_share;           /*     8     8 */
	class Create_field        m_return_field_def;    /*    16   256 */

	/* XXX last struct has 7 bytes of padding */

	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	class sp_parser_data      m_parser_data;         /*   272   136 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	class st_sp_chistics *     m_chistics;           /*   408     8 */
	sql_mode_t                 m_sql_mode;           /*   416     8 */
	LEX_STRING                 m_qname;              /*   424    16 */
	bool                       m_explicit_name;      /*   440     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 7 boundary (448 bytes) --- */
	LEX_STRING                 m_db;                 /*   448    16 */
	LEX_STRING                 m_name;               /*   464    16 */
	LEX_STRING                 m_params;             /*   480    16 */
	LEX_CSTRING                m_body;               /*   496    16 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	LEX_CSTRING                m_body_utf8;          /*   512    16 */
	LEX_STRING                 m_defstr;             /*   528    16 */
	LEX_STRING                 m_definer_user;       /*   544    16 */
	LEX_STRING                 m_definer_host;       /*   560    16 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	longlong                   m_created;            /*   576     8 */
	longlong                   m_modified;           /*   584     8 */
	ulong                      m_recursion_level;    /*   592     8 */
	class sp_head *            m_next_cached_sp;     /*   600     8 */
	class sp_head *            m_first_instance;     /*   608     8 */
	class sp_head *            m_first_free_instance; /*   616     8 */
	class sp_head *            m_last_cached_sp;     /*   624     8 */
	class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > m_sroutines; /*   632    64 */
	/* --- cacheline 10 boundary (640 bytes) was 56 bytes ago --- */
	class Security_context    m_security_ctx;        /*   696  1040 */
	/* --- cacheline 27 boundary (1728 bytes) was 8 bytes ago --- */
	class SQL_I_List<SQL_I_List<Item_trigger_field> > m_list_of_trig_fields_item_lists; /*  1736    24 */
	class SQL_I_List<Item_trigger_field> m_cur_instr_trig_field_items; /*  1760    24 */
	struct st_trg_chistics     m_trg_chistics;       /*  1784    32 */
	/* --- cacheline 28 boundary (1792 bytes) was 24 bytes ago --- */
	class Table_trigger_dispatcher * m_trg_list;     /*  1816     8 */
	void destroy(class sp_head *);

	bool is_invoked(const class sp_head  *);

	int64 sp_cache_version(const class sp_head  *);

	void set_sp_cache_version(class sp_head *, int64);

	class Stored_program_creation_ctx * get_creation_ctx(class sp_head *);

	void set_creation_ctx(class sp_head *, class Stored_program_creation_ctx *);

	void set_body_start(class sp_head *, class THD *, const char  *);

	void set_body_end(class sp_head *, class THD *);

	bool setup_trigger_fields(class sp_head *, class THD *, class Table_trigger_field_support *, class GRANT_INFO *, bool);

	void mark_used_trigger_fields(class sp_head *, class TABLE *);

	bool has_updated_trigger_fields(const class sp_head  *, const class MY_BITMAP  *);

	bool execute_trigger(class sp_head *, class THD *, const LEX_CSTRING  &, const LEX_CSTRING  &, class GRANT_INFO *);

	bool execute_function(class sp_head *, class THD *, class Item * *, uint, class Field *);

	bool execute_procedure(class sp_head *, class THD *, class mem_root_deque<Item*> *);

	bool add_instr(class sp_head *, class THD *, class sp_instr *);

	bool modifies_data(const class sp_head  *);

	bool has_temp_table_ddl(const class sp_head  *);

	uint instructions(class sp_head *);

	class sp_instr * last_instruction(class sp_head *);

	bool reset_lex(class sp_head *, class THD *);

	bool restore_lex(class sp_head *, class THD *);

	char * name(const class sp_head  *, uint *);

	class Field * create_result_field(const class sp_head  *, class THD *, size_t, const char  *, class TABLE *);

	void returns_type(const class sp_head  *, class THD *, class String *);

	void set_info(class sp_head *, longlong, longlong, class st_sp_chistics *, sql_mode_t);

	void set_definer(class sp_head *, const char  *, size_t);

	void set_definer(class sp_head *, const LEX_CSTRING  &, const LEX_CSTRING  &);

	void optimize(class sp_head *);

	void add_mark_lead(class sp_head *, uint, class List<sp_instr> *);

	class sp_instr * get_instr(class sp_head *, uint);

	void add_used_tables_to_table_list(class sp_head *, class THD *, class TABLE_LIST * * *, enum enum_sql_command, class TABLE_LIST *);

	bool is_not_allowed_in_function(class sp_head *, const char  *);

	void propagate_attributes(class sp_head *, class Query_tables_list *);

	class sp_pcontext * get_root_parsing_context(const class sp_head  *);

	class MEM_ROOT * get_persistent_mem_root(const class sp_head  *);

	bool check_show_access(class sp_head *, class THD *, bool *);

	bool set_security_ctx(class sp_head *, class THD *, class Security_context * *);

	void sp_head(class sp_head *, , enum enum_sp_type);

	void ~sp_head(class sp_head *, int);

	struct MEM_ROOT            main_mem_root;        /*  1824    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 29 boundary (1856 bytes) was 48 bytes ago --- */
	class sp_pcontext *        m_root_parsing_ctx;   /*  1904     8 */
	class Mem_root_array<sp_instr*> m_instructions;  /*  1912    32 */
	/* --- cacheline 30 boundary (1920 bytes) was 24 bytes ago --- */
	class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> m_sptabs; /*  1944    96 */
	/* --- cacheline 31 boundary (1984 bytes) was 56 bytes ago --- */
	class vector<SP_TABLE*, std::allocator<SP_TABLE*> > m_sptabs_sorted; /*  2040    24 */
	/* --- cacheline 32 boundary (2048 bytes) was 16 bytes ago --- */
	int64                      m_sp_cache_version;   /*  2064     8 */
	class Stored_program_creation_ctx * m_creation_ctx; /*  2072     8 */
	uint32                     unsafe_flags;         /*  2080     4 */
	void init_sp_name(class sp_head *, class THD *, class sp_name *);

	bool execute(class sp_head *, class THD *, bool);

	void opt_mark(class sp_head *);

	bool merge_table_list(class sp_head *, class THD *, class TABLE_LIST *, class LEX *);

	void sp_head(class sp_head *, const class sp_head  &);

	void operator=(class sp_head *, class sp_head &);


	/* size: 2088, cachelines: 33, members: 38 */
	/* sum members: 2077, holes: 1, sum holes: 7 */
	/* padding: 4 */
	/* paddings: 2, sum paddings: 11 */
	/* last cacheline: 40 bytes */
};
class VisibleFieldsContainer<const mem_root_deque<Item*>, mem_root_deque<Item*>::Iterator<Item* const> > {
public:

	void VisibleFieldsContainer(class VisibleFieldsContainer<const mem_root_deque<Item*>, mem_root_deque<Item*>::Iterator<Item* const> > *, const class mem_root_deque<Item*>  &);

	class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > begin(class VisibleFieldsContainer<const mem_root_deque<Item*>, mem_root_deque<Item*>::Iterator<Item* const> > *);

	class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > end(class VisibleFieldsContainer<const mem_root_deque<Item*>, mem_root_deque<Item*>::Iterator<Item* const> > *);

	const class mem_root_deque<Item*>  & m_fields;   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > {
public:

	void VisibleFieldsAdapter(class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > *, class Iterator<Item* const>, class Iterator<Item* const>);

	class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > & operator++(class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > *);

	class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > operator++(class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> > *, int);

	void  & operator*(const class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> >  *);

	bool operator==(const class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> >  *, const class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> >  &);

	bool operator!=(const class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> >  *, const class VisibleFieldsAdapter<mem_root_deque<Item*>::Iterator<Item* const> >  &);

	class Iterator<Item* const> m_it;                /*     0    16 */
	class Iterator<Item* const> m_end;               /*    16    16 */

	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
class Prealloced_array<long unsigned int, 2> {
	struct External {
		long unsigned int *        m_array_ptr;          /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		long unsigned int          m_buff[2];            /*     0    16 */
	};

	static const bool                 Has_trivial_destructor = 1; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<long unsigned int, 2>  *);

	long unsigned int * buffer(class Prealloced_array<long unsigned int, 2> *);

	const long unsigned int  * buffer(const class Prealloced_array<long unsigned int, 2>  *);

	void set_size(class Prealloced_array<long unsigned int, 2> *, size_t);

	void adjust_size(class Prealloced_array<long unsigned int, 2> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<long unsigned int, 2> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<long unsigned int, 2> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<long unsigned int, 2> *, const class Prealloced_array<long unsigned int, 2>  &);

	void Prealloced_array(class Prealloced_array<long unsigned int, 2> *, );

	void Prealloced_array(class Prealloced_array<long unsigned int, 2> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const long unsigned int  * const_iterator;

	void Prealloced_array(class Prealloced_array<long unsigned int, 2> *, class initializer_list<long unsigned int>);

	class Prealloced_array<long unsigned int, 2> & operator=(class Prealloced_array<long unsigned int, 2> *, const class Prealloced_array<long unsigned int, 2>  &);

	class Prealloced_array<long unsigned int, 2> & operator=(class Prealloced_array<long unsigned int, 2> *, );

	void ~Prealloced_array(class Prealloced_array<long unsigned int, 2> *, int);

	size_t capacity(const class Prealloced_array<long unsigned int, 2>  *);

	size_t element_size(const class Prealloced_array<long unsigned int, 2>  *);

	bool empty(const class Prealloced_array<long unsigned int, 2>  *);

	size_t size(const class Prealloced_array<long unsigned int, 2>  *);

	long unsigned int & at(class Prealloced_array<long unsigned int, 2> *, size_t);

	const long unsigned int  & at(const class Prealloced_array<long unsigned int, 2>  *, size_t);

	long unsigned int & operator[](class Prealloced_array<long unsigned int, 2> *, size_t);

	const long unsigned int  & operator[](const class Prealloced_array<long unsigned int, 2>  *, size_t);

	long unsigned int & back(class Prealloced_array<long unsigned int, 2> *);

	const long unsigned int  & back(const class Prealloced_array<long unsigned int, 2>  *);

	long unsigned int & front(class Prealloced_array<long unsigned int, 2> *);

	const long unsigned int  & front(const class Prealloced_array<long unsigned int, 2>  *);

	typedef long unsigned int * iterator;

	iterator begin(class Prealloced_array<long unsigned int, 2> *);

	iterator end(class Prealloced_array<long unsigned int, 2> *);

	const_iterator begin(const class Prealloced_array<long unsigned int, 2>  *);

	const_iterator end(const class Prealloced_array<long unsigned int, 2>  *);

	const_iterator cbegin(const class Prealloced_array<long unsigned int, 2>  *);

	const_iterator cend(const class Prealloced_array<long unsigned int, 2>  *);

	bool assign_at(class Prealloced_array<long unsigned int, 2> *, size_t, const value_type  &);

	typedef long unsigned int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<long unsigned int, 2> *, size_t);

	bool push_back(class Prealloced_array<long unsigned int, 2> *, const long unsigned int  &);

	bool push_back(class Prealloced_array<long unsigned int, 2> *, );

	void pop_back(class Prealloced_array<long unsigned int, 2> *);

	iterator insert(class Prealloced_array<long unsigned int, 2> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<long unsigned int, 2> *, const_iterator, );

	class pair<long unsigned int*, bool> insert_unique(class Prealloced_array<long unsigned int, 2> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<long unsigned int, 2> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<long unsigned int, 2>  *, const value_type  &);

	iterator erase(class Prealloced_array<long unsigned int, 2> *, const_iterator);

	iterator erase(class Prealloced_array<long unsigned int, 2> *, size_t);

	void erase_at_end(class Prealloced_array<long unsigned int, 2> *, const_iterator);

	iterator erase(class Prealloced_array<long unsigned int, 2> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<long unsigned int, 2> *, class Prealloced_array<long unsigned int, 2> &);

	void shrink_to_fit(class Prealloced_array<long unsigned int, 2> *);

	void resize(class Prealloced_array<long unsigned int, 2> *, size_t, const long unsigned int  &);

	void clear(class Prealloced_array<long unsigned int, 2> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		long unsigned int  m_buff[2];            /*     8    16 */
	};                                               /*     8    24 */

	/* size: 32, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 32 bytes */
};
class List<Window> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Window> *);

	void List(class List<Window> *, const class List<Window>  &);

	class List<Window> & operator=(class List<Window> *, const class List<Window>  &);

	void List(class List<Window> *, const class List<Window>  &, class MEM_ROOT *);

	bool push_back(class List<Window> *, class Window *);

	bool push_back(class List<Window> *, class Window *, class MEM_ROOT *);

	bool push_front(class List<Window> *, class Window *);

	bool push_front(class List<Window> *, class Window *, class MEM_ROOT *);

	class Window * head(class List<Window> *);

	const class Window  * head(const class List<Window>  *);

	class Window * * head_ref(class List<Window> *);

	class Window * pop(class List<Window> *);

	void concat(class List<Window> *, class List<Window> *);

	void disjoin(class List<Window> *, class List<Window> *);

	void prepend(class List<Window> *, class List<Window> *);

	void delete_elements(class List<Window> *);

	void destroy_elements(class List<Window> *);

	class Window * operator[](const class List<Window>  *, uint);

	void replace(class List<Window> *, uint, class Window *);

	bool swap_elts(class List<Window> *, uint, uint);

	typedef struct List_STL_Iterator<Window> iterator;

	iterator begin(class List<Window> *);

	iterator end(class List<Window> *);

	typedef struct List_STL_Iterator<const Window> const_iterator;

	const_iterator begin(const class List<Window>  *);

	const_iterator end(const class List<Window>  *);

	const_iterator cbegin(const class List<Window>  *);

	const_iterator cend(const class List<Window>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class List<Item_func_match> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Item_func_match> *);

	void List(class List<Item_func_match> *, const class List<Item_func_match>  &);

	class List<Item_func_match> & operator=(class List<Item_func_match> *, const class List<Item_func_match>  &);

	void List(class List<Item_func_match> *, const class List<Item_func_match>  &, class MEM_ROOT *);

	bool push_back(class List<Item_func_match> *, class Item_func_match *);

	bool push_back(class List<Item_func_match> *, class Item_func_match *, class MEM_ROOT *);

	bool push_front(class List<Item_func_match> *, class Item_func_match *);

	bool push_front(class List<Item_func_match> *, class Item_func_match *, class MEM_ROOT *);

	class Item_func_match * head(class List<Item_func_match> *);

	const class Item_func_match  * head(const class List<Item_func_match>  *);

	class Item_func_match * * head_ref(class List<Item_func_match> *);

	class Item_func_match * pop(class List<Item_func_match> *);

	void concat(class List<Item_func_match> *, class List<Item_func_match> *);

	void disjoin(class List<Item_func_match> *, class List<Item_func_match> *);

	void prepend(class List<Item_func_match> *, class List<Item_func_match> *);

	void delete_elements(class List<Item_func_match> *);

	void destroy_elements(class List<Item_func_match> *);

	class Item_func_match * operator[](const class List<Item_func_match>  *, uint);

	void replace(class List<Item_func_match> *, uint, class Item_func_match *);

	bool swap_elts(class List<Item_func_match> *, uint, uint);

	typedef struct List_STL_Iterator<Item_func_match> iterator;

	iterator begin(class List<Item_func_match> *);

	iterator end(class List<Item_func_match> *);

	typedef struct List_STL_Iterator<const Item_func_match> const_iterator;

	const_iterator begin(const class List<Item_func_match>  *);

	const_iterator end(const class List<Item_func_match>  *);

	const_iterator cbegin(const class List<Item_func_match>  *);

	const_iterator cend(const class List<Item_func_match>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class SQL_I_List<ORDER> {
public:

	uint                       elements;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class ORDER *              first;                /*     8     8 */
	class ORDER * *            next;                 /*    16     8 */
	void SQL_I_List(class SQL_I_List<ORDER> *);

	void SQL_I_List(class SQL_I_List<ORDER> *, const class SQL_I_List<ORDER>  &);

	void SQL_I_List(class SQL_I_List<ORDER> *, );

	void clear(class SQL_I_List<ORDER> *);

	void link_in_list(class SQL_I_List<ORDER> *, class ORDER *, class ORDER * *);

	void save_and_clear(class SQL_I_List<ORDER> *, class SQL_I_List<ORDER> *);

	void push_front(class SQL_I_List<ORDER> *, class SQL_I_List<ORDER> *);

	void push_back(class SQL_I_List<ORDER> *, class SQL_I_List<ORDER> *);

	uint size(const class SQL_I_List<ORDER>  *);

	class SQL_I_List<ORDER> & operator=(class SQL_I_List<ORDER> *, class SQL_I_List<ORDER> &);

	class SQL_I_List<ORDER> & operator=(class SQL_I_List<ORDER> *, );


	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class Prealloced_array<Item_rollup_group_item*, 4> {
	struct External {
		class Item_rollup_group_item * * m_array_ptr;    /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Item_rollup_group_item * m_buff[4];        /*     0    32 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	class Item_rollup_group_item * * buffer(class Prealloced_array<Item_rollup_group_item*, 4> *);

	class Item_rollup_group_item * const * buffer(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	void set_size(class Prealloced_array<Item_rollup_group_item*, 4> *, size_t);

	void adjust_size(class Prealloced_array<Item_rollup_group_item*, 4> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Item_rollup_group_item*, 4> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Item_rollup_group_item*, 4> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Item_rollup_group_item*, 4> *, const class Prealloced_array<Item_rollup_group_item*, 4>  &);

	void Prealloced_array(class Prealloced_array<Item_rollup_group_item*, 4> *, );

	void Prealloced_array(class Prealloced_array<Item_rollup_group_item*, 4> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Item_rollup_group_item * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Item_rollup_group_item*, 4> *, class initializer_list<Item_rollup_group_item*>);

	class Prealloced_array<Item_rollup_group_item*, 4> & operator=(class Prealloced_array<Item_rollup_group_item*, 4> *, const class Prealloced_array<Item_rollup_group_item*, 4>  &);

	class Prealloced_array<Item_rollup_group_item*, 4> & operator=(class Prealloced_array<Item_rollup_group_item*, 4> *, );

	void ~Prealloced_array(class Prealloced_array<Item_rollup_group_item*, 4> *, int);

	size_t capacity(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	size_t element_size(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	bool empty(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	size_t size(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	class Item_rollup_group_item * & at(class Prealloced_array<Item_rollup_group_item*, 4> *, size_t);

	class Item_rollup_group_item * const & at(const class Prealloced_array<Item_rollup_group_item*, 4>  *, size_t);

	class Item_rollup_group_item * & operator[](class Prealloced_array<Item_rollup_group_item*, 4> *, size_t);

	class Item_rollup_group_item * const & operator[](const class Prealloced_array<Item_rollup_group_item*, 4>  *, size_t);

	class Item_rollup_group_item * & back(class Prealloced_array<Item_rollup_group_item*, 4> *);

	class Item_rollup_group_item * const & back(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	class Item_rollup_group_item * & front(class Prealloced_array<Item_rollup_group_item*, 4> *);

	class Item_rollup_group_item * const & front(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	typedef class Item_rollup_group_item * * iterator;

	iterator begin(class Prealloced_array<Item_rollup_group_item*, 4> *);

	iterator end(class Prealloced_array<Item_rollup_group_item*, 4> *);

	const_iterator begin(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	const_iterator end(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	const_iterator cbegin(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	const_iterator cend(const class Prealloced_array<Item_rollup_group_item*, 4>  *);

	bool assign_at(class Prealloced_array<Item_rollup_group_item*, 4> *, size_t, const value_type  &);

	typedef class Item_rollup_group_item * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Item_rollup_group_item*, 4> *, size_t);

	bool push_back(class Prealloced_array<Item_rollup_group_item*, 4> *, class Item_rollup_group_item * const &);

	bool push_back(class Prealloced_array<Item_rollup_group_item*, 4> *, );

	void pop_back(class Prealloced_array<Item_rollup_group_item*, 4> *);

	iterator insert(class Prealloced_array<Item_rollup_group_item*, 4> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Item_rollup_group_item*, 4> *, const_iterator, );

	class pair<Item_rollup_group_item**, bool> insert_unique(class Prealloced_array<Item_rollup_group_item*, 4> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Item_rollup_group_item*, 4> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Item_rollup_group_item*, 4>  *, const value_type  &);

	iterator erase(class Prealloced_array<Item_rollup_group_item*, 4> *, const_iterator);

	iterator erase(class Prealloced_array<Item_rollup_group_item*, 4> *, size_t);

	void erase_at_end(class Prealloced_array<Item_rollup_group_item*, 4> *, const_iterator);

	iterator erase(class Prealloced_array<Item_rollup_group_item*, 4> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Item_rollup_group_item*, 4> *, class Prealloced_array<Item_rollup_group_item*, 4> &);

	void shrink_to_fit(class Prealloced_array<Item_rollup_group_item*, 4> *);

	void resize(class Prealloced_array<Item_rollup_group_item*, 4> *, size_t, class Item_rollup_group_item * const &);

	void clear(class Prealloced_array<Item_rollup_group_item*, 4> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Item_rollup_group_item * m_buff[4]; /*     8    32 */
	};                                               /*     8    32 */

	/* size: 40, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 40 bytes */
};
class Prealloced_array<Item_rollup_sum_switcher*, 4> {
	struct External {
		class Item_rollup_sum_switcher * * m_array_ptr;  /*     0     8 */
		size_t                     m_alloced_size;       /*     8     8 */
		size_t                     m_alloced_capacity;   /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	union {
		struct External            m_ext;                /*     0    24 */
		class Item_rollup_sum_switcher * m_buff[4];      /*     0    32 */
	};

	static const bool                 Has_trivial_destructor; /*     0     0 */
	bool using_inline_buffer(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	class Item_rollup_sum_switcher * * buffer(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	class Item_rollup_sum_switcher * const * buffer(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	void set_size(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, size_t);

	void adjust_size(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, int);

public:

	static const size_t               initial_capacity; /*     0     0 */
	void Prealloced_array(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, PSI_memory_key, size_t);

	void Prealloced_array(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const class Prealloced_array<Item_rollup_sum_switcher*, 4>  &);

	void Prealloced_array(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, );

	void Prealloced_array(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Item_rollup_sum_switcher * const * const_iterator;

	void Prealloced_array(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, class initializer_list<Item_rollup_sum_switcher*>);

	class Prealloced_array<Item_rollup_sum_switcher*, 4> & operator=(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const class Prealloced_array<Item_rollup_sum_switcher*, 4>  &);

	class Prealloced_array<Item_rollup_sum_switcher*, 4> & operator=(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, );

	void ~Prealloced_array(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, int);

	size_t capacity(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	size_t element_size(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	bool empty(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	size_t size(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	class Item_rollup_sum_switcher * & at(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, size_t);

	class Item_rollup_sum_switcher * const & at(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *, size_t);

	class Item_rollup_sum_switcher * & operator[](class Prealloced_array<Item_rollup_sum_switcher*, 4> *, size_t);

	class Item_rollup_sum_switcher * const & operator[](const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *, size_t);

	class Item_rollup_sum_switcher * & back(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	class Item_rollup_sum_switcher * const & back(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	class Item_rollup_sum_switcher * & front(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	class Item_rollup_sum_switcher * const & front(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	typedef class Item_rollup_sum_switcher * * iterator;

	iterator begin(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	iterator end(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	const_iterator begin(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	const_iterator end(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	const_iterator cbegin(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	const_iterator cend(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *);

	bool assign_at(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, size_t, const value_type  &);

	typedef class Item_rollup_sum_switcher * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	bool reserve(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, size_t);

	bool push_back(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, class Item_rollup_sum_switcher * const &);

	bool push_back(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, );

	void pop_back(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	iterator insert(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const_iterator, const value_type  &);

	iterator insert(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const_iterator, );

	class pair<Item_rollup_sum_switcher**, bool> insert_unique(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Item_rollup_sum_switcher*, 4>  *, const value_type  &);

	iterator erase(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const_iterator);

	iterator erase(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, size_t);

	void erase_at_end(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const_iterator);

	iterator erase(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, const_iterator, const_iterator);

	void swap(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, class Prealloced_array<Item_rollup_sum_switcher*, 4> &);

	void shrink_to_fit(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	void resize(class Prealloced_array<Item_rollup_sum_switcher*, 4> *, size_t, class Item_rollup_sum_switcher * const &);

	void clear(class Prealloced_array<Item_rollup_sum_switcher*, 4> *);

	PSI_memory_key             m_psi_key;            /*     0     4 */
	int                        m_inline_size;        /*     4     4 */
	union {
		struct External    m_ext;                /*     8    24 */
		class Item_rollup_sum_switcher * m_buff[4]; /*     8    32 */
	};                                               /*     8    32 */

	/* size: 40, cachelines: 1, members: 3, static members: 2 */
	/* last cacheline: 40 bytes */
};
class Mem_root_array<Item_exists_subselect*> : public Mem_root_array_YY<Item_exists_subselect*> {
public:

	/* class Mem_root_array_YY<Item_exists_subselect*> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *);

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, class MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, );

	class Mem_root_array<Item_exists_subselect*> & operator=(class Mem_root_array<Item_exists_subselect*> *, );

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, class MEM_ROOT *, size_t);

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, class MEM_ROOT *, size_t, const value_type  &);

	typedef class Item_exists_subselect * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, class MEM_ROOT *, const_iterator, const_iterator);

	typedef const_iterator const_iterator;

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, class MEM_ROOT *, const class Mem_root_array<Item_exists_subselect*>  &);

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, class initializer_list<Item_exists_subselect*>);

	void ~Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, int);

	void Mem_root_array(class Mem_root_array<Item_exists_subselect*> *, const class Mem_root_array<Item_exists_subselect*>  &);

	class Mem_root_array<Item_exists_subselect*> & operator=(class Mem_root_array<Item_exists_subselect*> *, const class Mem_root_array<Item_exists_subselect*>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class mem_root_deque<mem_root_deque<Item*>*> {
public:

	void mem_root_deque(class mem_root_deque<mem_root_deque<Item*>*> *, class MEM_ROOT *);

	void mem_root_deque(class mem_root_deque<mem_root_deque<Item*>*> *, const class mem_root_deque<mem_root_deque<Item*>*>  &);

	class mem_root_deque<mem_root_deque<Item*>*> & operator=(class mem_root_deque<mem_root_deque<Item*>*> *, const class mem_root_deque<mem_root_deque<Item*>*>  &);

	void mem_root_deque(class mem_root_deque<mem_root_deque<Item*>*> *, );

	class mem_root_deque<mem_root_deque<Item*>*> & operator=(class mem_root_deque<mem_root_deque<Item*>*> *, );

	void ~mem_root_deque(class mem_root_deque<mem_root_deque<Item*>*> *, int);

	class mem_root_deque<Item*> * & operator[](const class mem_root_deque<mem_root_deque<Item*>*>  *, size_t);

	bool push_back(class mem_root_deque<mem_root_deque<Item*>*> *, class mem_root_deque<Item*> * const &);

	bool push_back(class mem_root_deque<mem_root_deque<Item*>*> *, );

	bool push_front(class mem_root_deque<mem_root_deque<Item*>*> *, class mem_root_deque<Item*> * const &);

	bool push_front(class mem_root_deque<mem_root_deque<Item*>*> *, );

	void pop_back(class mem_root_deque<mem_root_deque<Item*>*> *);

	void pop_front(class mem_root_deque<mem_root_deque<Item*>*> *);

	class mem_root_deque<Item*> * & front(class mem_root_deque<mem_root_deque<Item*>*> *);

	class mem_root_deque<Item*> * const & front(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	class mem_root_deque<Item*> * & back(class mem_root_deque<mem_root_deque<Item*>*> *);

	class mem_root_deque<Item*> * const & back(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	void clear(class mem_root_deque<mem_root_deque<Item*>*> *);

	typedef struct Iterator<mem_root_deque<Item*>*> iterator;

	class Iterator<mem_root_deque<Item*>*> {

		/* size: 0, cachelines: 0, members: 0 */
	};

	iterator begin(class mem_root_deque<mem_root_deque<Item*>*> *);

	iterator end(class mem_root_deque<mem_root_deque<Item*>*> *);

	typedef struct reverse_iterator<mem_root_deque<mem_root_deque<Item*>*>::Iterator<mem_root_deque<Item*>*> > reverse_iterator;

	reverse_iterator rbegin(class mem_root_deque<mem_root_deque<Item*>*> *);

	reverse_iterator rend(class mem_root_deque<mem_root_deque<Item*>*> *);

	typedef struct Iterator<mem_root_deque<Item*>* const> const_iterator;

	class Iterator<mem_root_deque<Item*>* const> {

		/* size: 0, cachelines: 0, members: 0 */
	};

	const_iterator cbegin(class mem_root_deque<mem_root_deque<Item*>*> *);

	const_iterator cend(class mem_root_deque<mem_root_deque<Item*>*> *);

	const_iterator begin(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	const_iterator end(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	typedef struct reverse_iterator<mem_root_deque<mem_root_deque<Item*>*>::Iterator<mem_root_deque<Item*>* const> > reverse_const_iterator;

	reverse_const_iterator crbegin(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	reverse_const_iterator crend(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	reverse_const_iterator rbegin(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	reverse_const_iterator rend(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	size_t size(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	bool empty(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	iterator erase(class mem_root_deque<mem_root_deque<Item*>*> *, const_iterator, const_iterator);

	iterator erase(class mem_root_deque<mem_root_deque<Item*>*> *, const_iterator);

	iterator insert(class mem_root_deque<mem_root_deque<Item*>*> *, const_iterator, class mem_root_deque<Item*> * const &);

	iterator insert(class mem_root_deque<mem_root_deque<Item*>*> *, const_iterator, );

	static const size_t               block_elements; /*     0     0 */
	struct Block {

		/* size: 0, cachelines: 0, members: 0 */
	};

	class Block *              m_blocks;             /*     0     8 */
	size_t                     m_begin_idx;          /*     8     8 */
	size_t                     m_end_idx;            /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */
	class MEM_ROOT *           m_root;               /*    32     8 */
	void invalidate_iterators(class mem_root_deque<mem_root_deque<Item*>*> *);

	bool add_initial_block(class mem_root_deque<mem_root_deque<Item*>*> *);

	bool add_block_back(class mem_root_deque<mem_root_deque<Item*>*> *);

	bool add_block_front(class mem_root_deque<mem_root_deque<Item*>*> *);

	size_t num_blocks(const class mem_root_deque<mem_root_deque<Item*>*>  *);

	class mem_root_deque<Item*> * & get(const class mem_root_deque<mem_root_deque<Item*>*>  *, size_t);


	/* size: 40, cachelines: 1, members: 5, static members: 1 */
	/* last cacheline: 40 bytes */
};
class Mem_root_array_YY<Item_exists_subselect*> {
	static const bool                 has_trivial_destructor; /*     0     0 */
public:

	void init(class Mem_root_array_YY<Item_exists_subselect*> *, class MEM_ROOT *);

	void init_empty_const(class Mem_root_array_YY<Item_exists_subselect*> *);

	class Item_exists_subselect * & at(class Mem_root_array_YY<Item_exists_subselect*> *, size_t);

	class Item_exists_subselect * const & at(const class Mem_root_array_YY<Item_exists_subselect*>  *, size_t);

	class Item_exists_subselect * & operator[](class Mem_root_array_YY<Item_exists_subselect*> *, size_t);

	class Item_exists_subselect * const & operator[](const class Mem_root_array_YY<Item_exists_subselect*>  *, size_t);

	class Item_exists_subselect * & back(class Mem_root_array_YY<Item_exists_subselect*> *);

	class Item_exists_subselect * const & back(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	class Item_exists_subselect * * begin(class Mem_root_array_YY<Item_exists_subselect*> *);

	class Item_exists_subselect * const * begin(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	class Item_exists_subselect * * end(class Mem_root_array_YY<Item_exists_subselect*> *);

	class Item_exists_subselect * const * end(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	typedef class Item_exists_subselect * const * const_iterator;

	const_iterator cbegin(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	const_iterator cend(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	void clear(class Mem_root_array_YY<Item_exists_subselect*> *);

	void chop(class Mem_root_array_YY<Item_exists_subselect*> *, size_t);

	bool reserve(class Mem_root_array_YY<Item_exists_subselect*> *, size_t);

	bool push_back(class Mem_root_array_YY<Item_exists_subselect*> *, class Item_exists_subselect * const &);

	bool push_back(class Mem_root_array_YY<Item_exists_subselect*> *, );

	bool push_front(class Mem_root_array_YY<Item_exists_subselect*> *, class Item_exists_subselect * const &);

	bool push_front(class Mem_root_array_YY<Item_exists_subselect*> *, );

	void pop_back(class Mem_root_array_YY<Item_exists_subselect*> *);

	void resize(class Mem_root_array_YY<Item_exists_subselect*> *, size_t, const value_type  &);

	typedef class Item_exists_subselect * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void resize(class Mem_root_array_YY<Item_exists_subselect*> *, size_t);

	typedef class Item_exists_subselect * * iterator;

	iterator erase(class Mem_root_array_YY<Item_exists_subselect*> *, const_iterator, const_iterator);

	iterator erase(class Mem_root_array_YY<Item_exists_subselect*> *, const_iterator);

	iterator erase(class Mem_root_array_YY<Item_exists_subselect*> *, size_t);

	iterator insert(class Mem_root_array_YY<Item_exists_subselect*> *, const_iterator, class Item_exists_subselect * const &);

	size_t erase_value(class Mem_root_array_YY<Item_exists_subselect*> *, const value_type  &);

	iterator erase(class Mem_root_array_YY<Item_exists_subselect*> *, iterator);

	size_t capacity(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	size_t element_size(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	bool empty(const class Mem_root_array_YY<Item_exists_subselect*>  *);

	size_t size(const class Mem_root_array_YY<Item_exists_subselect*>  *);

protected:

	class MEM_ROOT *           m_root;               /*     0     8 */
	class Item_exists_subselect * * m_array;         /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4, static members: 1 */
	/* last cacheline: 32 bytes */
};
struct st_sp_chistics {
	LEX_CSTRING                comment;              /*     0    16 */
	enum enum_sp_suid_behaviour suid;                /*    16     4 */
	bool                       detistic;             /*    20     1 */

	/* XXX 3 bytes hole, try to pack */

	enum enum_sp_data_access   daccess;              /*    24     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct st_trg_chistics {
	enum enum_trigger_action_time_type action_time;  /*     0     4 */
	enum enum_trigger_event_type event;              /*     4     4 */
	enum enum_trigger_order_type ordering_clause;    /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	LEX_CSTRING                anchor_trigger_name;  /*    16    16 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > : public unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*> > > {
public:

	/* class unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*> > > <ancestor>; */ /*     0    64 */
	void malloc_unordered_map(class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry, PSI_memory_key);

	void ~malloc_unordered_map(class malloc_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry, int);


	/* size: 64, cachelines: 1, members: 1 */

	/* BRAIN FART ALERT! 64 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 512 bits */
};
class SQL_I_List<Sroutine_hash_entry> {
public:

	uint                       elements;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class Sroutine_hash_entry * first;               /*     8     8 */
	class Sroutine_hash_entry * * next;              /*    16     8 */
	void SQL_I_List(class SQL_I_List<Sroutine_hash_entry> *);

	void SQL_I_List(class SQL_I_List<Sroutine_hash_entry> *, const class SQL_I_List<Sroutine_hash_entry>  &);

	void SQL_I_List(class SQL_I_List<Sroutine_hash_entry> *, );

	void clear(class SQL_I_List<Sroutine_hash_entry> *);

	void link_in_list(class SQL_I_List<Sroutine_hash_entry> *, class Sroutine_hash_entry *, class Sroutine_hash_entry * *);

	void save_and_clear(class SQL_I_List<Sroutine_hash_entry> *, class SQL_I_List<Sroutine_hash_entry> *);

	void push_front(class SQL_I_List<Sroutine_hash_entry> *, class SQL_I_List<Sroutine_hash_entry> *);

	void push_back(class SQL_I_List<Sroutine_hash_entry> *, class SQL_I_List<Sroutine_hash_entry> *);

	uint size(const class SQL_I_List<Sroutine_hash_entry>  *);

	class SQL_I_List<Sroutine_hash_entry> & operator=(class SQL_I_List<Sroutine_hash_entry> *, class SQL_I_List<Sroutine_hash_entry> &);

	class SQL_I_List<Sroutine_hash_entry> & operator=(class SQL_I_List<Sroutine_hash_entry> *, );


	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class Lex_input_stream {
public:

	void Lex_input_stream(class Lex_input_stream *, uint);

	bool init(class Lex_input_stream *, class THD *, const char  *, size_t);

	void reset(class Lex_input_stream *, const char  *, size_t);

	void set_echo(class Lex_input_stream *, bool);

	void save_in_comment_state(class Lex_input_stream *);

	void restore_in_comment_state(class Lex_input_stream *);

	void skip_binary(class Lex_input_stream *, int);

	unsigned char yyGet(class Lex_input_stream *);

	unsigned char yyGetLast(const class Lex_input_stream  *);

	unsigned char yyPeek(const class Lex_input_stream  *);

	unsigned char yyPeekn(const class Lex_input_stream  *, int);

	void yyUnget(class Lex_input_stream *);

	void yySkip(class Lex_input_stream *);

	void yySkipn(class Lex_input_stream *, int);

	char * yyUnput(class Lex_input_stream *, char);

	char * cpp_inject(class Lex_input_stream *, char);

	bool eof(const class Lex_input_stream  *);

	bool eof(const class Lex_input_stream  *, int);

	const char  * get_buf(const class Lex_input_stream  *);

	const char  * get_cpp_buf(const class Lex_input_stream  *);

	const char  * get_end_of_query(const class Lex_input_stream  *);

	void start_token(class Lex_input_stream *);

	void restart_token(class Lex_input_stream *);

	const char  * get_tok_start(const class Lex_input_stream  *);

	const char  * get_cpp_tok_start(const class Lex_input_stream  *);

	const char  * get_tok_end(const class Lex_input_stream  *);

	const char  * get_cpp_tok_end(const class Lex_input_stream  *);

	const char  * get_ptr(const class Lex_input_stream  *);

	const char  * get_cpp_ptr(const class Lex_input_stream  *);

	uint yyLength(const class Lex_input_stream  *);

	const char  * get_body_utf8_str(const class Lex_input_stream  *);

	uint get_body_utf8_length(const class Lex_input_stream  *);

	void body_utf8_start(class Lex_input_stream *, class THD *, const char  *);

	void body_utf8_append(class Lex_input_stream *, const char  *);

	void body_utf8_append(class Lex_input_stream *, const char  *, const char  *);

	void body_utf8_append_literal(class Lex_input_stream *, class THD *, const LEX_STRING  *, const class CHARSET_INFO  *, const char  *);

	uint get_lineno(const class Lex_input_stream  *, const char  *);

	class THD *                m_thd;                /*     0     8 */
	uint                       yylineno;             /*     8     4 */
	uint                       yytoklen;             /*    12     4 */
	union Lexer_yystype *      yylval;               /*    16     8 */
	int                        lookahead_token;      /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	union Lexer_yystype *      lookahead_yylval;     /*    32     8 */
	bool                       skip_digest;          /*    40     1 */

	/* XXX 7 bytes hole, try to pack */
	void add_digest_token(class Lex_input_stream *, uint, union Lexer_yystype *);

	void reduce_digest_token(class Lex_input_stream *, uint, uint);

	bool is_partial_parser(const class Lex_input_stream  *);

	void warn_on_deprecated_charset(const class Lex_input_stream  *, const class CHARSET_INFO  *, const char  *);

	void warn_on_deprecated_collation(const class Lex_input_stream  *, const class CHARSET_INFO  *);


	const class CHARSET_INFO  * query_charset;       /*    48     8 */
	char *                     m_ptr;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	const char  *              m_tok_start;          /*    64     8 */
	const char  *              m_tok_end;            /*    72     8 */
	const char  *              m_end_of_query;       /*    80     8 */
	const char  *              m_buf;                /*    88     8 */
	size_t                     m_buf_length;         /*    96     8 */
	bool                       m_echo;               /*   104     1 */
	bool                       m_echo_saved;         /*   105     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     m_cpp_buf;            /*   112     8 */
	char *                     m_cpp_ptr;            /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	const char  *              m_cpp_tok_start;      /*   128     8 */
	const char  *              m_cpp_tok_end;        /*   136     8 */
	char *                     m_body_utf8;          /*   144     8 */
	char *                     m_body_utf8_ptr;      /*   152     8 */
	const char  *              m_cpp_utf8_processed_ptr; /*   160     8 */
	enum my_lex_states         next_state;           /*   168     1 */

	/* XXX 7 bytes hole, try to pack */

	const char  *              found_semicolon;      /*   176     8 */
	uchar                      tok_bitmap;           /*   184     1 */
	bool                       ignore_space;         /*   185     1 */
	bool                       stmt_prepare_mode;    /*   186     1 */
	bool                       multi_statements;     /*   187     1 */
	enum enum_comment_state    in_comment;           /*   188     4 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	enum enum_comment_state    in_comment_saved;     /*   192     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_cpp_text_start;     /*   200     8 */
	const char  *              m_cpp_text_end;       /*   208     8 */
	const class CHARSET_INFO  * m_underscore_cs;     /*   216     8 */
	sql_digest_state *         m_digest;             /*   224     8 */
	const int                  grammar_selector_token; /*   232     4 */
	bool text_string_is_7bit(const class Lex_input_stream  *);


	/* size: 240, cachelines: 4, members: 36 */
	/* sum members: 208, holes: 5, sum holes: 28 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
class List<Item_param> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Item_param> *);

	void List(class List<Item_param> *, const class List<Item_param>  &);

	class List<Item_param> & operator=(class List<Item_param> *, const class List<Item_param>  &);

	void List(class List<Item_param> *, const class List<Item_param>  &, class MEM_ROOT *);

	bool push_back(class List<Item_param> *, class Item_param *);

	bool push_back(class List<Item_param> *, class Item_param *, class MEM_ROOT *);

	bool push_front(class List<Item_param> *, class Item_param *);

	bool push_front(class List<Item_param> *, class Item_param *, class MEM_ROOT *);

	class Item_param * head(class List<Item_param> *);

	const class Item_param  * head(const class List<Item_param>  *);

	class Item_param * * head_ref(class List<Item_param> *);

	class Item_param * pop(class List<Item_param> *);

	void concat(class List<Item_param> *, class List<Item_param> *);

	void disjoin(class List<Item_param> *, class List<Item_param> *);

	void prepend(class List<Item_param> *, class List<Item_param> *);

	void delete_elements(class List<Item_param> *);

	void destroy_elements(class List<Item_param> *);

	class Item_param * operator[](const class List<Item_param>  *, uint);

	void replace(class List<Item_param> *, uint, class Item_param *);

	bool swap_elts(class List<Item_param> *, uint, uint);

	typedef struct List_STL_Iterator<Item_param> iterator;

	iterator begin(class List<Item_param> *);

	iterator end(class List<Item_param> *);

	typedef struct List_STL_Iterator<const Item_param> const_iterator;

	const_iterator begin(const class List<Item_param>  *);

	const_iterator end(const class List<Item_param>  *);

	const_iterator cbegin(const class List<Item_param>  *);

	const_iterator cend(const class List<Item_param>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S, reference);

	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*> & reference;

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S, const_reference);

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutin, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutin, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutin, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutin, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*>, true> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*>, true> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, reference);

	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*>, true> & reference;

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, const_reference);

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	typedef struct _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, Sroutine_hash_entry*>, true> value_type;

	struct rebind<std::__detail::_Hash_node_base*> {
		typedef struct Malloc_allocator<std::__detail::_Hash_node_base*> other;


		/* size: 1, cachelines: 0, members: 0 */
		/* padding: 1 */
		/* last cacheline: 1 bytes */
	};


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Yacc_state {
public:

	void Yacc_state(class Yacc_state *);

	void reset(class Yacc_state *);

	void ~Yacc_state(class Yacc_state *, int);

	void reset_before_substatement(class Yacc_state *);

	uchar *                    yacc_yyss;            /*     0     8 */
	uchar *                    yacc_yyvs;            /*     8     8 */
	uchar *                    yacc_yyls;            /*    16     8 */
	enum thr_lock_type         m_lock_type;          /*    24     4 */
	enum enum_mdl_type         m_mdl_type;           /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct Parser_input {
	bool                       m_compute_digest;     /*     0     1 */
	void Parser_input(class Parser_input *);


	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
class Parser_state {
protected:

	void Parser_state(class Parser_state *, int);

public:

	void Parser_state(class Parser_state *);

	bool init(class Parser_state *, class THD *, const char  *, size_t);

	void reset(class Parser_state *, const char  *, size_t);

	void add_comment(class Parser_state *);

	bool has_comment(const class Parser_state  *);

	struct Parser_input        m_input;              /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	class Lex_input_stream    m_lip;                 /*     8   240 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 3 boundary (192 bytes) was 56 bytes ago --- */
	class Yacc_state          m_yacc;                /*   248    32 */
	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	PSI_digest_locker *        m_digest_psi;         /*   280     8 */
	bool                       m_comment;            /*   288     1 */

	/* size: 296, cachelines: 5, members: 5 */
	/* sum members: 282, holes: 1, sum holes: 7 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 40 bytes */
};
class sp_parser_data {
	struct Backpatch_info {
		class sp_label *           label;                /*     0     8 */
		class sp_branch_instr *    instr;                /*     8     8 */

		/* size: 16, cachelines: 1, members: 2 */
		/* last cacheline: 16 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

public:

	void sp_parser_data(class sp_parser_data *);

	void start_parsing_sp_body(class sp_parser_data *, class THD *, class sp_head *);

	void finish_parsing_sp_body(class sp_parser_data *, class THD *);

	bool is_parsing_sp_body(const class sp_parser_data  *);

	void process_new_sp_instr(class sp_parser_data *, class THD *, class sp_instr *);

	const char  * get_current_stmt_start_ptr(const class sp_parser_data  *);

	void set_current_stmt_start_ptr(class sp_parser_data *, const char  *);

	const char  * get_option_start_ptr(const class sp_parser_data  *);

	void set_option_start_ptr(class sp_parser_data *, const char  *);

	const char  * get_parameter_start_ptr(const class sp_parser_data  *);

	void set_parameter_start_ptr(class sp_parser_data *, const char  *);

	const char  * get_parameter_end_ptr(const class sp_parser_data  *);

	void set_parameter_end_ptr(class sp_parser_data *, const char  *);

	const char  * get_body_start_ptr(const class sp_parser_data  *);

	void set_body_start_ptr(class sp_parser_data *, const char  *);

	void push_lex(class sp_parser_data *, class LEX *);

	class LEX * pop_lex(class sp_parser_data *);

	bool add_backpatch_entry(class sp_parser_data *, class sp_branch_instr *, class sp_label *);

	void do_backpatch(class sp_parser_data *, class sp_label *, uint);

	bool new_cont_backpatch(class sp_parser_data *);

	bool add_cont_backpatch_entry(class sp_parser_data *, class sp_lex_branch_instr *);

	void do_cont_backpatch(class sp_parser_data *, uint);

	const char  *              m_current_stmt_start_ptr; /*     0     8 */
	const char  *              m_option_start_ptr;   /*     8     8 */
	class List<LEX>           m_lex_stack;           /*    16    24 */
	const char  *              m_param_start_ptr;    /*    40     8 */
	const char  *              m_param_end_ptr;      /*    48     8 */
	const char  *              m_body_start_ptr;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class List<sp_parser_data::Backpatch_info> m_backpatch; /*    64    24 */
	class List<sp_lex_branch_instr> m_cont_backpatch; /*    88    24 */
	uint                       m_cont_level;         /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	class MEM_ROOT *           m_saved_memroot;      /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	class Item *               m_saved_item_list;    /*   128     8 */

	/* size: 136, cachelines: 3, members: 11 */
	/* sum members: 132, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
class List<LEX> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<LEX> *);

	void List(class List<LEX> *, const class List<LEX>  &);

	class List<LEX> & operator=(class List<LEX> *, const class List<LEX>  &);

	void List(class List<LEX> *, const class List<LEX>  &, class MEM_ROOT *);

	bool push_back(class List<LEX> *, class LEX *);

	bool push_back(class List<LEX> *, class LEX *, class MEM_ROOT *);

	bool push_front(class List<LEX> *, class LEX *);

	bool push_front(class List<LEX> *, class LEX *, class MEM_ROOT *);

	class LEX * head(class List<LEX> *);

	const class LEX  * head(const class List<LEX>  *);

	class LEX * * head_ref(class List<LEX> *);

	class LEX * pop(class List<LEX> *);

	void concat(class List<LEX> *, class List<LEX> *);

	void disjoin(class List<LEX> *, class List<LEX> *);

	void prepend(class List<LEX> *, class List<LEX> *);

	void delete_elements(class List<LEX> *);

	void destroy_elements(class List<LEX> *);

	class LEX * operator[](const class List<LEX>  *, uint);

	void replace(class List<LEX> *, uint, class LEX *);

	bool swap_elts(class List<LEX> *, uint, uint);

	typedef struct List_STL_Iterator<LEX> iterator;

	iterator begin(class List<LEX> *);

	iterator end(class List<LEX> *);

	typedef struct List_STL_Iterator<const LEX> const_iterator;

	const_iterator begin(const class List<LEX>  *);

	const_iterator end(const class List<LEX>  *);

	const_iterator cbegin(const class List<LEX>  *);

	const_iterator cend(const class List<LEX>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class List<sp_parser_data::Backpatch_info> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<sp_parser_data::Backpatch_info> *);

	void List(class List<sp_parser_data::Backpatch_info> *, const class List<sp_parser_data::Backpatch_info>  &);

	class List<sp_parser_data::Backpatch_info> & operator=(class List<sp_parser_data::Backpatch_info> *, const class List<sp_parser_data::Backpatch_info>  &);

	void List(class List<sp_parser_data::Backpatch_info> *, const class List<sp_parser_data::Backpatch_info>  &, class MEM_ROOT *);

	bool push_back(class List<sp_parser_data::Backpatch_info> *, class Backpatch_info *);

	bool push_back(class List<sp_parser_data::Backpatch_info> *, class Backpatch_info *, class MEM_ROOT *);

	bool push_front(class List<sp_parser_data::Backpatch_info> *, class Backpatch_info *);

	bool push_front(class List<sp_parser_data::Backpatch_info> *, class Backpatch_info *, class MEM_ROOT *);

	class Backpatch_info * head(class List<sp_parser_data::Backpatch_info> *);

	const class Backpatch_info  * head(const class List<sp_parser_data::Backpatch_info>  *);

	class Backpatch_info * * head_ref(class List<sp_parser_data::Backpatch_info> *);

	class Backpatch_info * pop(class List<sp_parser_data::Backpatch_info> *);

	void concat(class List<sp_parser_data::Backpatch_info> *, class List<sp_parser_data::Backpatch_info> *);

	void disjoin(class List<sp_parser_data::Backpatch_info> *, class List<sp_parser_data::Backpatch_info> *);

	void prepend(class List<sp_parser_data::Backpatch_info> *, class List<sp_parser_data::Backpatch_info> *);

	void delete_elements(class List<sp_parser_data::Backpatch_info> *);

	void destroy_elements(class List<sp_parser_data::Backpatch_info> *);

	class Backpatch_info * operator[](const class List<sp_parser_data::Backpatch_info>  *, uint);

	void replace(class List<sp_parser_data::Backpatch_info> *, uint, class Backpatch_info *);

	bool swap_elts(class List<sp_parser_data::Backpatch_info> *, uint, uint);

	typedef struct List_STL_Iterator<sp_parser_data::Backpatch_info> iterator;

	iterator begin(class List<sp_parser_data::Backpatch_info> *);

	iterator end(class List<sp_parser_data::Backpatch_info> *);

	typedef struct List_STL_Iterator<const sp_parser_data::Backpatch_info> const_iterator;

	const_iterator begin(const class List<sp_parser_data::Backpatch_info>  *);

	const_iterator end(const class List<sp_parser_data::Backpatch_info>  *);

	const_iterator cbegin(const class List<sp_parser_data::Backpatch_info>  *);

	const_iterator cend(const class List<sp_parser_data::Backpatch_info>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class List<sp_lex_branch_instr> : public base_list {
public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<sp_lex_branch_instr> *);

	void List(class List<sp_lex_branch_instr> *, const class List<sp_lex_branch_instr>  &);

	class List<sp_lex_branch_instr> & operator=(class List<sp_lex_branch_instr> *, const class List<sp_lex_branch_instr>  &);

	void List(class List<sp_lex_branch_instr> *, const class List<sp_lex_branch_instr>  &, class MEM_ROOT *);

	bool push_back(class List<sp_lex_branch_instr> *, class sp_lex_branch_instr *);

	bool push_back(class List<sp_lex_branch_instr> *, class sp_lex_branch_instr *, class MEM_ROOT *);

	bool push_front(class List<sp_lex_branch_instr> *, class sp_lex_branch_instr *);

	bool push_front(class List<sp_lex_branch_instr> *, class sp_lex_branch_instr *, class MEM_ROOT *);

	class sp_lex_branch_instr * head(class List<sp_lex_branch_instr> *);

	const class sp_lex_branch_instr  * head(const class List<sp_lex_branch_instr>  *);

	class sp_lex_branch_instr * * head_ref(class List<sp_lex_branch_instr> *);

	class sp_lex_branch_instr * pop(class List<sp_lex_branch_instr> *);

	void concat(class List<sp_lex_branch_instr> *, class List<sp_lex_branch_instr> *);

	void disjoin(class List<sp_lex_branch_instr> *, class List<sp_lex_branch_instr> *);

	void prepend(class List<sp_lex_branch_instr> *, class List<sp_lex_branch_instr> *);

	void delete_elements(class List<sp_lex_branch_instr> *);

	void destroy_elements(class List<sp_lex_branch_instr> *);

	class sp_lex_branch_instr * operator[](const class List<sp_lex_branch_instr>  *, uint);

	void replace(class List<sp_lex_branch_instr> *, uint, class sp_lex_branch_instr *);

	bool swap_elts(class List<sp_lex_branch_instr> *, uint, uint);

	typedef struct List_STL_Iterator<sp_lex_branch_instr> iterator;

	iterator begin(class List<sp_lex_branch_instr> *);

	iterator end(class List<sp_lex_branch_instr> *);

	typedef struct List_STL_Iterator<const sp_lex_branch_instr> const_iterator;

	const_iterator begin(const class List<sp_lex_branch_instr>  *);

	const_iterator end(const class List<sp_lex_branch_instr>  *);

	const_iterator cbegin(const class List<sp_lex_branch_instr>  *);

	const_iterator cend(const class List<sp_lex_branch_instr>  *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class SQL_I_List<SQL_I_List<Item_trigger_field> > {
public:

	uint                       elements;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class SQL_I_List<Item_trigger_field> * first;    /*     8     8 */
	class SQL_I_List<Item_trigger_field> * * next;   /*    16     8 */
	void SQL_I_List(class SQL_I_List<SQL_I_List<Item_trigger_field> > *);

	void SQL_I_List(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, const class SQL_I_List<SQL_I_List<Item_trigger_field> >  &);

	void SQL_I_List(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, );

	void clear(class SQL_I_List<SQL_I_List<Item_trigger_field> > *);

	void link_in_list(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, class SQL_I_List<Item_trigger_field> *, class SQL_I_List<Item_trigger_field> * *);

	void save_and_clear(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, class SQL_I_List<SQL_I_List<Item_trigger_field> > *);

	void push_front(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, class SQL_I_List<SQL_I_List<Item_trigger_field> > *);

	void push_back(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, class SQL_I_List<SQL_I_List<Item_trigger_field> > *);

	uint size(const class SQL_I_List<SQL_I_List<Item_trigger_field> >  *);

	class SQL_I_List<SQL_I_List<Item_trigger_field> > & operator=(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, class SQL_I_List<SQL_I_List<Item_trigger_field> > &);

	class SQL_I_List<SQL_I_List<Item_trigger_field> > & operator=(class SQL_I_List<SQL_I_List<Item_trigger_field> > *, );


	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class SQL_I_List<Item_trigger_field> {
public:

	uint                       elements;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class Item_trigger_field * first;                /*     8     8 */
	class Item_trigger_field * * next;               /*    16     8 */
	void SQL_I_List(class SQL_I_List<Item_trigger_field> *);

	void SQL_I_List(class SQL_I_List<Item_trigger_field> *, const class SQL_I_List<Item_trigger_field>  &);

	void SQL_I_List(class SQL_I_List<Item_trigger_field> *, );

	void clear(class SQL_I_List<Item_trigger_field> *);

	void link_in_list(class SQL_I_List<Item_trigger_field> *, class Item_trigger_field *, class Item_trigger_field * *);

	void save_and_clear(class SQL_I_List<Item_trigger_field> *, class SQL_I_List<Item_trigger_field> *);

	void push_front(class SQL_I_List<Item_trigger_field> *, class SQL_I_List<Item_trigger_field> *);

	void push_back(class SQL_I_List<Item_trigger_field> *, class SQL_I_List<Item_trigger_field> *);

	uint size(const class SQL_I_List<Item_trigger_field>  *);

	class SQL_I_List<Item_trigger_field> & operator=(class SQL_I_List<Item_trigger_field> *, class SQL_I_List<Item_trigger_field> &);

	class SQL_I_List<Item_trigger_field> & operator=(class SQL_I_List<Item_trigger_field> *, );


	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class Mem_root_array_YY<sp_instr*> {
	static const bool                 has_trivial_destructor; /*     0     0 */
public:

	void init(class Mem_root_array_YY<sp_instr*> *, class MEM_ROOT *);

	void init_empty_const(class Mem_root_array_YY<sp_instr*> *);

	class sp_instr * & at(class Mem_root_array_YY<sp_instr*> *, size_t);

	class sp_instr * const & at(const class Mem_root_array_YY<sp_instr*>  *, size_t);

	class sp_instr * & operator[](class Mem_root_array_YY<sp_instr*> *, size_t);

	class sp_instr * const & operator[](const class Mem_root_array_YY<sp_instr*>  *, size_t);

	class sp_instr * & back(class Mem_root_array_YY<sp_instr*> *);

	class sp_instr * const & back(const class Mem_root_array_YY<sp_instr*>  *);

	class sp_instr * * begin(class Mem_root_array_YY<sp_instr*> *);

	class sp_instr * const * begin(const class Mem_root_array_YY<sp_instr*>  *);

	class sp_instr * * end(class Mem_root_array_YY<sp_instr*> *);

	class sp_instr * const * end(const class Mem_root_array_YY<sp_instr*>  *);

	typedef class sp_instr * const * const_iterator;

	const_iterator cbegin(const class Mem_root_array_YY<sp_instr*>  *);

	const_iterator cend(const class Mem_root_array_YY<sp_instr*>  *);

	void clear(class Mem_root_array_YY<sp_instr*> *);

	void chop(class Mem_root_array_YY<sp_instr*> *, size_t);

	bool reserve(class Mem_root_array_YY<sp_instr*> *, size_t);

	bool push_back(class Mem_root_array_YY<sp_instr*> *, class sp_instr * const &);

	bool push_back(class Mem_root_array_YY<sp_instr*> *, );

	bool push_front(class Mem_root_array_YY<sp_instr*> *, class sp_instr * const &);

	bool push_front(class Mem_root_array_YY<sp_instr*> *, );

	void pop_back(class Mem_root_array_YY<sp_instr*> *);

	void resize(class Mem_root_array_YY<sp_instr*> *, size_t, const value_type  &);

	typedef class sp_instr * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void resize(class Mem_root_array_YY<sp_instr*> *, size_t);

	typedef class sp_instr * * iterator;

	iterator erase(class Mem_root_array_YY<sp_instr*> *, const_iterator, const_iterator);

	iterator erase(class Mem_root_array_YY<sp_instr*> *, const_iterator);

	iterator erase(class Mem_root_array_YY<sp_instr*> *, size_t);

	iterator insert(class Mem_root_array_YY<sp_instr*> *, const_iterator, class sp_instr * const &);

	size_t erase_value(class Mem_root_array_YY<sp_instr*> *, const value_type  &);

	iterator erase(class Mem_root_array_YY<sp_instr*> *, iterator);

	size_t capacity(const class Mem_root_array_YY<sp_instr*>  *);

	size_t element_size(const class Mem_root_array_YY<sp_instr*>  *);

	bool empty(const class Mem_root_array_YY<sp_instr*>  *);

	size_t size(const class Mem_root_array_YY<sp_instr*>  *);

protected:

	class MEM_ROOT *           m_root;               /*     0     8 */
	class sp_instr * *         m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4, static members: 1 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<sp_instr*> : public Mem_root_array_YY<sp_instr*> {
public:

	/* class Mem_root_array_YY<sp_instr*> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<sp_instr*> *);

	void Mem_root_array(class Mem_root_array<sp_instr*> *, class MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<sp_instr*> *, );

	class Mem_root_array<sp_instr*> & operator=(class Mem_root_array<sp_instr*> *, );

	void Mem_root_array(class Mem_root_array<sp_instr*> *, class MEM_ROOT *, size_t);

	void Mem_root_array(class Mem_root_array<sp_instr*> *, class MEM_ROOT *, size_t, const value_type  &);

	typedef class sp_instr * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void Mem_root_array(class Mem_root_array<sp_instr*> *, class MEM_ROOT *, const_iterator, const_iterator);

	typedef const_iterator const_iterator;

	void Mem_root_array(class Mem_root_array<sp_instr*> *, class MEM_ROOT *, const class Mem_root_array<sp_instr*>  &);

	void Mem_root_array(class Mem_root_array<sp_instr*> *, class initializer_list<sp_instr*>);

	void ~Mem_root_array(class Mem_root_array<sp_instr*> *, int);

	void Mem_root_array(class Mem_root_array<sp_instr*> *, const class Mem_root_array<sp_instr*>  &);

	class Mem_root_array<sp_instr*> & operator=(class Mem_root_array<sp_instr*> *, const class Mem_root_array<sp_instr*>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> * pointer;

public:

	pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S, reference);

	typedef class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> & reference;

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S, const_reference);

	typedef const class pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABL, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABL, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABL, pointer, size_type);

	void destroy(class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABL, pointer);

	size_type max_size(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S);

	PSI_memory_key psi_key(const class Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, S);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>, true> > {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>, true> * pointer;

public:

	pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, reference);

	typedef class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>, true> & reference;

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>, t  * const_pointer;

	const_pointer address(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,, const_reference);

	typedef const class _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>, t  & const_reference;

	void Malloc_allocator(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, PSI_memory_key);

	pointer allocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer, size_type);

	void destroy(class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::, pointer);

	size_type max_size(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	PSI_memory_key psi_key(const class Malloc_allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>,);

	typedef struct _Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*>, true> value_type;


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> : public unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> > > {
public:

	/* class unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*, Collation_hasher, Collation_key_equal, Malloc_allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> > > <ancestor>; */ /*     0    96 */
	void collation_unordered_map(class collation_unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, SP_TABLE*> *, const class CHARSET_INFO  *, PSI_memory_key);


	/* size: 96, cachelines: 2, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 96 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 768 bits */
};
struct rusage {
	union {
		long int                   ru_maxrss;            /*     0     8 */
		__syscall_slong_t          __ru_maxrss_word;     /*     0     8 */
	};

	union {
		long int                   ru_ixrss;             /*     0     8 */
		__syscall_slong_t          __ru_ixrss_word;      /*     0     8 */
	};

	union {
		long int                   ru_idrss;             /*     0     8 */
		__syscall_slong_t          __ru_idrss_word;      /*     0     8 */
	};

	union {
		long int                   ru_isrss;             /*     0     8 */
		__syscall_slong_t          __ru_isrss_word;      /*     0     8 */
	};

	union {
		long int                   ru_minflt;            /*     0     8 */
		__syscall_slong_t          __ru_minflt_word;     /*     0     8 */
	};

	union {
		long int                   ru_majflt;            /*     0     8 */
		__syscall_slong_t          __ru_majflt_word;     /*     0     8 */
	};

	union {
		long int                   ru_nswap;             /*     0     8 */
		__syscall_slong_t          __ru_nswap_word;      /*     0     8 */
	};

	union {
		long int                   ru_inblock;           /*     0     8 */
		__syscall_slong_t          __ru_inblock_word;    /*     0     8 */
	};

	union {
		long int                   ru_oublock;           /*     0     8 */
		__syscall_slong_t          __ru_oublock_word;    /*     0     8 */
	};

	union {
		long int                   ru_msgsnd;            /*     0     8 */
		__syscall_slong_t          __ru_msgsnd_word;     /*     0     8 */
	};

	union {
		long int                   ru_msgrcv;            /*     0     8 */
		__syscall_slong_t          __ru_msgrcv_word;     /*     0     8 */
	};

	union {
		long int                   ru_nsignals;          /*     0     8 */
		__syscall_slong_t          __ru_nsignals_word;   /*     0     8 */
	};

	union {
		long int                   ru_nvcsw;             /*     0     8 */
		__syscall_slong_t          __ru_nvcsw_word;      /*     0     8 */
	};

	union {
		long int                   ru_nivcsw;            /*     0     8 */
		__syscall_slong_t          __ru_nivcsw_word;     /*     0     8 */
	};

	struct timeval             ru_utime;             /*     0    16 */
	struct timeval             ru_stime;             /*    16    16 */
	union {
		long int           ru_maxrss;            /*    32     8 */
		__syscall_slong_t  __ru_maxrss_word;     /*    32     8 */
	};                                               /*    32     8 */
	union {
		long int           ru_ixrss;             /*    40     8 */
		__syscall_slong_t  __ru_ixrss_word;      /*    40     8 */
	};                                               /*    40     8 */
	union {
		long int           ru_idrss;             /*    48     8 */
		__syscall_slong_t  __ru_idrss_word;      /*    48     8 */
	};                                               /*    48     8 */
	union {
		long int           ru_isrss;             /*    56     8 */
		__syscall_slong_t  __ru_isrss_word;      /*    56     8 */
	};                                               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	union {
		long int           ru_minflt;            /*    64     8 */
		__syscall_slong_t  __ru_minflt_word;     /*    64     8 */
	};                                               /*    64     8 */
	union {
		long int           ru_majflt;            /*    72     8 */
		__syscall_slong_t  __ru_majflt_word;     /*    72     8 */
	};                                               /*    72     8 */
	union {
		long int           ru_nswap;             /*    80     8 */
		__syscall_slong_t  __ru_nswap_word;      /*    80     8 */
	};                                               /*    80     8 */
	union {
		long int           ru_inblock;           /*    88     8 */
		__syscall_slong_t  __ru_inblock_word;    /*    88     8 */
	};                                               /*    88     8 */
	union {
		long int           ru_oublock;           /*    96     8 */
		__syscall_slong_t  __ru_oublock_word;    /*    96     8 */
	};                                               /*    96     8 */
	union {
		long int           ru_msgsnd;            /*   104     8 */
		__syscall_slong_t  __ru_msgsnd_word;     /*   104     8 */
	};                                               /*   104     8 */
	union {
		long int           ru_msgrcv;            /*   112     8 */
		__syscall_slong_t  __ru_msgrcv_word;     /*   112     8 */
	};                                               /*   112     8 */
	union {
		long int           ru_nsignals;          /*   120     8 */
		__syscall_slong_t  __ru_nsignals_word;   /*   120     8 */
	};                                               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	union {
		long int           ru_nvcsw;             /*   128     8 */
		__syscall_slong_t  __ru_nvcsw_word;      /*   128     8 */
	};                                               /*   128     8 */
	union {
		long int           ru_nivcsw;            /*   136     8 */
		__syscall_slong_t  __ru_nivcsw_word;     /*   136     8 */
	};                                               /*   136     8 */

	/* size: 144, cachelines: 3, members: 16 */
	/* last cacheline: 16 bytes */
};
class PROF_MEASUREMENT {
	class QUERY_PROFILE *      profile;              /*     0     8 */
	char *                     allocated_status_memory; /*     8     8 */
	void set_label(class PROF_MEASUREMENT *, const char  *, const char  *, const char  *, unsigned int);

	void clean_up(class PROF_MEASUREMENT *);

public:

	const char  *              status;               /*    16     8 */
	struct rusage              rusage;               /*    24   144 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	const char  *              function;             /*   168     8 */
	const char  *              file;                 /*   176     8 */
	unsigned int               line;                 /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	ulong                      m_seq;                /*   192     8 */
	double                     time_usecs;           /*   200     8 */
	double                     cpu_time_usecs;       /*   208     8 */
	void PROF_MEASUREMENT(class PROF_MEASUREMENT *, class QUERY_PROFILE *, const char  *);

	void PROF_MEASUREMENT(class PROF_MEASUREMENT *, class QUERY_PROFILE *, const char  *, const char  *, const char  *, unsigned int);

	void ~PROF_MEASUREMENT(class PROF_MEASUREMENT *, int);

	void collect(class PROF_MEASUREMENT *);


	/* size: 216, cachelines: 4, members: 10 */
	/* sum members: 212, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class QUERY_PROFILE {
	class PROFILING *          profiling;            /*     0     8 */
	query_id_t                 profiling_query_id;   /*     8     8 */
	LEX_STRING                 m_query_source;       /*    16    16 */
	double                     m_start_time_usecs;   /*    32     8 */
	double                     m_end_time_usecs;     /*    40     8 */
	ulong                      m_seq_counter;        /*    48     8 */
	class Queue<PROF_MEASUREMENT> entries;           /*    56    24 */
	void QUERY_PROFILE(class QUERY_PROFILE *, class PROFILING *, const char  *);

	void ~QUERY_PROFILE(class QUERY_PROFILE *, int);

	void set_query_source(class QUERY_PROFILE *, const char  *, size_t);

	void new_status(class QUERY_PROFILE *, const char  *, const char  *, const char  *, unsigned int);

public:

	class PROFILING * get_profiling(const class QUERY_PROFILE  *);


	/* size: 80, cachelines: 2, members: 7 */
	/* last cacheline: 16 bytes */
};
class Queue<PROF_MEASUREMENT> {
	struct queue_item {

		/* size: 0, cachelines: 0, members: 0 */
	};

	class queue_item *         first;                /*     0     8 */
	class queue_item *         last;                 /*     8     8 */
public:

	void Queue(class Queue<PROF_MEASUREMENT> *);

	void empty(class Queue<PROF_MEASUREMENT> *);

	ulong                      elements;             /*    16     8 */
	void push_back(class Queue<PROF_MEASUREMENT> *, class PROF_MEASUREMENT *);

	class PROF_MEASUREMENT * pop(class Queue<PROF_MEASUREMENT> *);

	bool is_empty(class Queue<PROF_MEASUREMENT> *);

	void * new_iterator(class Queue<PROF_MEASUREMENT> *);

	void * iterator_next(class Queue<PROF_MEASUREMENT> *, void *);

	class PROF_MEASUREMENT * iterator_value(class Queue<PROF_MEASUREMENT> *, void *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Queue<QUERY_PROFILE> {
	struct queue_item {

		/* size: 0, cachelines: 0, members: 0 */
	};

	class queue_item *         first;                /*     0     8 */
	class queue_item *         last;                 /*     8     8 */
public:

	void Queue(class Queue<QUERY_PROFILE> *);

	void empty(class Queue<QUERY_PROFILE> *);

	ulong                      elements;             /*    16     8 */
	void push_back(class Queue<QUERY_PROFILE> *, class QUERY_PROFILE *);

	class QUERY_PROFILE * pop(class Queue<QUERY_PROFILE> *);

	bool is_empty(class Queue<QUERY_PROFILE> *);

	void * new_iterator(class Queue<QUERY_PROFILE> *);

	void * iterator_next(class Queue<QUERY_PROFILE> *, void *);

	class QUERY_PROFILE * iterator_value(class Queue<QUERY_PROFILE> *, void *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Table_cache {
	struct mysql_mutex_t       m_lock;               /*     0    48 */
	class unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<Table_cache_element, std::default_delete<Table_cache_element> >, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::unique_ptr<Table_cache_element, std::default_delete<Table_cache_element> > > > > m_cache; /*    48    56 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	class TABLE *              m_unused_tables;      /*   104     8 */
	uint                       m_table_count;        /*   112     4 */

	/* Bitfield combined with previous fields */

	static PSI_mutex_key              m_lock_key;    /*     0     0 */
	static PSI_mutex_info             m_mutex_keys[0]; /*     0     0 */
	void check_unused(class Table_cache *);

	void link_unused_table(class Table_cache *, class TABLE *);

	void unlink_unused_table(class Table_cache *, class TABLE *);

	void free_unused_tables_if_necessary(class Table_cache *, class THD *);

public:

	bool init(class Table_cache *);

	void destroy(class Table_cache *);

	void init_psi_keys(void);

	void lock(class Table_cache *);

	void unlock(class Table_cache *);

	void assert_owner(class Table_cache *);

	class TABLE * get_table(class Table_cache *, class THD *, const char  *, size_t, class TABLE_SHARE * *);

	void release_table(class Table_cache *, class THD *, class TABLE *);

	bool add_used_table(class Table_cache *, class THD *, class TABLE *);

	void remove_table(class Table_cache *, class TABLE *);

	uint cached_tables(const class Table_cache  *);

	void free_all_unused_tables(class Table_cache *);


	/* size: 120, cachelines: 2, members: 4, static members: 2 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
class Table_cache_manager {
public:

	static const int                  MAX_TABLE_CACHES = 64; /*     0     0 */
	static const int                  DEFAULT_MAX_TABLE_CACHES = 16; /*     0     0 */
	bool init(class Table_cache_manager *);

	void destroy(class Table_cache_manager *);

	class Table_cache * get_cache(class Table_cache_manager *, class THD *);

	uint cache_index(const class Table_cache_manager  *, class Table_cache *);

	uint cached_tables(class Table_cache_manager *);

	void lock_all_and_tdc(class Table_cache_manager *);

	void unlock_all_and_tdc(class Table_cache_manager *);

	void assert_owner(class Table_cache_manager *, class THD *);

	void assert_owner_all(class Table_cache_manager *);

	void assert_owner_all_and_tdc(class Table_cache_manager *);

	void free_table(class Table_cache_manager *, class THD *, enum enum_tdc_remove_table_type, class TABLE_SHARE *);

	void free_all_unused_tables(class Table_cache_manager *);

	class Table_cache         m_table_cache[64];     /*     0  7680 */

	/* size: 7680, cachelines: 120, members: 1, static members: 2 */
};
class I_P_List_no_push_back<TABLE> {
protected:

	void I_P_List_no_push_back(class I_P_List_no_push_back<TABLE> *, class TABLE * *);

	void set_last(class I_P_List_no_push_back<TABLE> *, class TABLE * *);

	void swap(class I_P_List_no_push_back<TABLE> *, class I_P_List_no_push_back<TABLE> &);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_back<TABLE> > : public I_P_List_null_counter, public I_P_List_no_push_back<TABLE> {
public:

	/* class I_P_List_null_counter <ancestor>; */    /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	/* class I_P_List_no_push_back<TABLE> <ancestor>; */ /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class TABLE *              m_first;              /*     0     8 */
	void I_P_List(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_);

	void clear(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_);

	bool is_empty(const class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no);

	void push_front(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_, class TABLE *);

	void push_back(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_, class TABLE *);

	void insert_after(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_, class TABLE *, class TABLE *);

	void remove(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_, class TABLE *);

	class TABLE * front(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_);

	const class TABLE  * front(const class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no);

	class TABLE * pop_front(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_);

	void swap(class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_, class I_P_List<TABLE, I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev>, I_P_List_null_counter, I_P_List_no_push_);


	/* size: 8, cachelines: 1, members: 3 */
	/* paddings: 2, sum paddings: 2 */
	/* last cacheline: 8 bytes */
};
struct I_P_List_adapter<TABLE, &TABLE::cache_next, &TABLE::cache_prev> {
	class TABLE * * next_ptr(class TABLE *);

	const class TABLE  * const * next_ptr(const class TABLE  *);

	class TABLE * * * prev_ptr(class TABLE *);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
struct LF_DYNARRAY {
	struct atomic<void*>       level[4];             /*     0    32 */
	uint                       size_of_element;      /*    32     4 */

	/* size: 40, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct LF_PINBOX {
	struct LF_DYNARRAY         pinarray;             /*     0    40 */

	/* XXX last struct has 4 bytes of padding */

	lf_pinbox_free_func *      free_func;            /*    40     8 */
	void *                     free_func_arg;        /*    48     8 */
	uint                       free_ptr_offset;      /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	struct atomic<long unsigned int> pinstack_top_ver __attribute__((__aligned__(8))); /*    64     8 */
	struct atomic<long unsigned int> pins_in_array __attribute__((__aligned__(8))); /*    72     8 */

	/* size: 80, cachelines: 2, members: 6 */
	/* sum members: 76, holes: 1, sum holes: 4 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 2, forced holes: 1, sum forced holes: 4 */
	/* last cacheline: 16 bytes */
} __attribute__((__aligned__(8)));
struct LF_ALLOCATOR {
	struct LF_PINBOX           pinbox __attribute__((__aligned__(8))); /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	struct atomic<unsigned char*> top;               /*    80     8 */
	uint                       element_size;         /*    88     4 */
	struct atomic<unsigned int> mallocs __attribute__((__aligned__(4))); /*    92     4 */
	lf_allocator_func *        constructor;          /*    96     8 */
	lf_allocator_func *        destructor;           /*   104     8 */

	/* size: 112, cachelines: 2, members: 6 */
	/* forced alignments: 2 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
struct LF_HASH {
	struct LF_DYNARRAY         array;                /*     0    40 */

	/* XXX last struct has 4 bytes of padding */

	struct LF_ALLOCATOR        alloc __attribute__((__aligned__(8))); /*    40   112 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	hash_get_key_function      get_key;              /*   152     8 */
	class CHARSET_INFO *       charset;              /*   160     8 */
	lf_hash_func *             hash_function;        /*   168     8 */
	uint                       key_offset;           /*   176     4 */
	uint                       key_length;           /*   180     4 */
	uint                       element_size;         /*   184     4 */
	uint                       flags;                /*   188     4 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	struct atomic<int>         size __attribute__((__aligned__(4))); /*   192     4 */
	struct atomic<int>         count __attribute__((__aligned__(4))); /*   196     4 */
	lf_hash_init_func *        initialize;           /*   200     8 */

	/* size: 208, cachelines: 4, members: 12 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 3 */
	/* last cacheline: 16 bytes */
} __attribute__((__aligned__(8)));
struct PSI_data_lock_service_v1 {
	register_data_lock_v1_t    register_data_lock;   /*     0     8 */
	unregister_data_lock_v1_t  unregister_data_lock; /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PSI_file_service_v2 {
	register_file_v1_t         register_file;        /*     0     8 */
	create_file_v1_t           create_file;          /*     8     8 */
	get_thread_file_name_locker_v1_t get_thread_file_name_locker; /*    16     8 */
	get_thread_file_stream_locker_v1_t get_thread_file_stream_locker; /*    24     8 */
	get_thread_file_descriptor_locker_v1_t get_thread_file_descriptor_locker; /*    32     8 */
	start_file_open_wait_v1_t  start_file_open_wait; /*    40     8 */
	end_file_open_wait_v1_t    end_file_open_wait;   /*    48     8 */
	end_file_open_wait_and_bind_to_descriptor_v1_t end_file_open_wait_and_bind_to_descriptor; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	end_temp_file_open_wait_and_bind_to_descriptor_v1_t end_temp_file_open_wait_and_bind_to_descriptor; /*    64     8 */
	start_file_wait_v1_t       start_file_wait;      /*    72     8 */
	end_file_wait_v1_t         end_file_wait;        /*    80     8 */
	start_file_close_wait_v1_t start_file_close_wait; /*    88     8 */
	end_file_close_wait_v1_t   end_file_close_wait;  /*    96     8 */
	start_file_rename_wait_v1_t start_file_rename_wait; /*   104     8 */
	end_file_rename_wait_v1_t  end_file_rename_wait; /*   112     8 */

	/* size: 120, cachelines: 2, members: 15 */
	/* last cacheline: 56 bytes */
};
struct PSI_idle_service_v1 {
	start_idle_wait_v1_t       start_idle_wait;      /*     0     8 */
	end_idle_wait_v1_t         end_idle_wait;        /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PSI_mdl_service_v2 {
	create_metadata_lock_v1_t  create_metadata_lock; /*     0     8 */
	set_metadata_lock_status_v1_t set_metadata_lock_status; /*     8     8 */
	set_metadata_lock_duration_v2_t set_metadata_lock_duration; /*    16     8 */
	destroy_metadata_lock_v1_t destroy_metadata_lock; /*    24     8 */
	start_metadata_wait_v1_t   start_metadata_wait;  /*    32     8 */
	end_metadata_wait_v1_t     end_metadata_wait;    /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct PSI_system_service_v1 {
	unload_plugin_v1_t         unload_plugin;        /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class TLS_channel_property {
public:

	char                       channel_name[65];     /*     0    65 */
	/* --- cacheline 1 boundary (64 bytes) was 1 bytes ago --- */
	char                       property_name[65];    /*    65    65 */
	/* --- cacheline 2 boundary (128 bytes) was 2 bytes ago --- */
	char                       property_value[513];  /*   130   513 */

	/* size: 643, cachelines: 11, members: 3 */
	/* last cacheline: 3 bytes */
};
struct TLS_channel_property_iterator {
	init_tls_property_iterator_t init_tls_property_iterator; /*     0     8 */
	deinit_tls_property_iterator_t deinit_tls_property_iterator; /*     8     8 */
	get_tls_property_t         get_tls_property;     /*    16     8 */
	next_tls_property_t        next_tls_property;    /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct PSI_tls_channel_service_v1 {
	register_tls_channel_v1_t  register_tls_channel; /*     0     8 */
	unregister_tls_channel_v1_t unregister_tls_channel; /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PSI_transaction_service_v1 {
	get_thread_transaction_locker_v1_t get_thread_transaction_locker; /*     0     8 */
	start_transaction_v1_t     start_transaction;    /*     8     8 */
	set_transaction_xid_v1_t   set_transaction_xid;  /*    16     8 */
	set_transaction_xa_state_v1_t set_transaction_xa_state; /*    24     8 */
	set_transaction_gtid_v1_t  set_transaction_gtid; /*    32     8 */
	set_transaction_trxid_v1_t set_transaction_trxid; /*    40     8 */
	inc_transaction_savepoints_v1_t inc_transaction_savepoints; /*    48     8 */
	inc_transaction_rollback_to_savepoint_v1_t inc_transaction_rollback_to_savepoint; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	inc_transaction_release_savepoint_v1_t inc_transaction_release_savepoint; /*    64     8 */
	end_transaction_v1_t       end_transaction;      /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* last cacheline: 16 bytes */
};
struct PFS_sizing_hints {
	ulong                      m_table_definition_cache; /*     0     8 */
	long int                   m_table_open_cache;   /*     8     8 */
	long int                   m_max_connections;    /*    16     8 */
	long int                   m_open_files_limit;   /*    24     8 */
	long int                   m_max_prepared_stmt_count; /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct PFS_global_param {
	bool                       m_enabled;            /*     0     1 */
	bool                       m_consumer_events_stages_current_enabled; /*     1     1 */
	bool                       m_consumer_events_stages_history_enabled; /*     2     1 */
	bool                       m_consumer_events_stages_history_long_enabled; /*     3     1 */
	bool                       m_consumer_events_statements_current_enabled; /*     4     1 */
	bool                       m_consumer_events_statements_history_enabled; /*     5     1 */
	bool                       m_consumer_events_statements_history_long_enabled; /*     6     1 */
	bool                       m_consumer_events_transactions_current_enabled; /*     7     1 */
	bool                       m_consumer_events_transactions_history_enabled; /*     8     1 */
	bool                       m_consumer_events_transactions_history_long_enabled; /*     9     1 */
	bool                       m_consumer_events_waits_current_enabled; /*    10     1 */
	bool                       m_consumer_events_waits_history_enabled; /*    11     1 */
	bool                       m_consumer_events_waits_history_long_enabled; /*    12     1 */
	bool                       m_consumer_global_instrumentation_enabled; /*    13     1 */
	bool                       m_consumer_thread_instrumentation_enabled; /*    14     1 */
	bool                       m_consumer_statement_digest_enabled; /*    15     1 */
	bool                       m_processlist_enabled; /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     m_pfs_instrument;     /*    24     8 */
	ulong                      m_mutex_class_sizing; /*    32     8 */
	ulong                      m_rwlock_class_sizing; /*    40     8 */
	ulong                      m_cond_class_sizing;  /*    48     8 */
	ulong                      m_thread_class_sizing; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	long int                   m_table_share_sizing; /*    64     8 */
	long int                   m_table_lock_stat_sizing; /*    72     8 */
	long int                   m_index_stat_sizing;  /*    80     8 */
	ulong                      m_file_class_sizing;  /*    88     8 */
	long int                   m_mutex_sizing;       /*    96     8 */
	long int                   m_rwlock_sizing;      /*   104     8 */
	long int                   m_cond_sizing;        /*   112     8 */
	long int                   m_thread_sizing;      /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	long int                   m_table_sizing;       /*   128     8 */
	long int                   m_file_sizing;        /*   136     8 */
	long int                   m_file_handle_sizing; /*   144     8 */
	long int                   m_socket_sizing;      /*   152     8 */
	ulong                      m_socket_class_sizing; /*   160     8 */
	long int                   m_events_waits_history_sizing; /*   168     8 */
	long int                   m_events_waits_history_long_sizing; /*   176     8 */
	long int                   m_setup_actor_sizing; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	long int                   m_setup_object_sizing; /*   192     8 */
	long int                   m_host_sizing;        /*   200     8 */
	long int                   m_user_sizing;        /*   208     8 */
	long int                   m_account_sizing;     /*   216     8 */
	ulong                      m_stage_class_sizing; /*   224     8 */
	long int                   m_events_stages_history_sizing; /*   232     8 */
	long int                   m_events_stages_history_long_sizing; /*   240     8 */
	ulong                      m_statement_class_sizing; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	long int                   m_events_statements_history_sizing; /*   256     8 */
	long int                   m_events_statements_history_long_sizing; /*   264     8 */
	long int                   m_digest_sizing;      /*   272     8 */
	long int                   m_program_sizing;     /*   280     8 */
	long int                   m_prepared_stmt_sizing; /*   288     8 */
	long int                   m_events_transactions_history_sizing; /*   296     8 */
	long int                   m_events_transactions_history_long_sizing; /*   304     8 */
	long int                   m_session_connect_attrs_sizing; /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	ulong                      m_statement_stack_sizing; /*   320     8 */
	ulong                      m_memory_class_sizing; /*   328     8 */
	long int                   m_metadata_lock_sizing; /*   336     8 */
	long int                   m_max_digest_length;  /*   344     8 */
	ulong                      m_max_sql_text_length; /*   352     8 */
	ulong                      m_max_digest_sample_age; /*   360     8 */
	ulong                      m_error_sizing;       /*   368     8 */
	struct PFS_sizing_hints    m_hints;              /*   376    40 */

	/* size: 416, cachelines: 7, members: 62 */
	/* sum members: 409, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct PFS_single_stat {
	ulonglong                  m_count;              /*     0     8 */
	ulonglong                  m_sum;                /*     8     8 */
	ulonglong                  m_min;                /*    16     8 */
	ulonglong                  m_max;                /*    24     8 */
	void PFS_single_stat(class PFS_single_stat *);

	void reset(class PFS_single_stat *);

	bool has_timed_stats(const class PFS_single_stat  *);

	void aggregate(class PFS_single_stat *, const class PFS_single_stat  *);

	void aggregate_no_check(class PFS_single_stat *, const class PFS_single_stat  *);

	void aggregate_counted(class PFS_single_stat *);

	void aggregate_counted(class PFS_single_stat *, ulonglong);

	void aggregate_value(class PFS_single_stat *, ulonglong);

	void aggregate_many_value(class PFS_single_stat *, ulonglong, ulonglong);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct PFS_byte_stat : PFS_single_stat {
	/* struct PFS_single_stat     <ancestor>; */     /*     0    32 */
	ulonglong                  m_bytes;              /*    32     8 */
	void aggregate(class PFS_byte_stat *, const class PFS_byte_stat  *);

	void aggregate_no_check(class PFS_byte_stat *, const class PFS_byte_stat  *);

	void aggregate(class PFS_byte_stat *, ulonglong, ulonglong);

	void aggregate_waits(class PFS_byte_stat *, const class PFS_byte_stat  *);

	void aggregate_counted(class PFS_byte_stat *);

	void aggregate_counted(class PFS_byte_stat *, ulonglong);

	void PFS_byte_stat(class PFS_byte_stat *);

	void reset(class PFS_byte_stat *);


	/* size: 40, cachelines: 1, members: 2 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 40 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
struct PFS_mutex_stat {
	struct PFS_single_stat     m_wait_stat;          /*     0    32 */
	void aggregate(class PFS_mutex_stat *, const class PFS_mutex_stat  *);

	void reset(class PFS_mutex_stat *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */
};
struct PFS_rwlock_stat {
	struct PFS_single_stat     m_wait_stat;          /*     0    32 */
	void aggregate(class PFS_rwlock_stat *, const class PFS_rwlock_stat  *);

	void reset(class PFS_rwlock_stat *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */
};
struct PFS_cond_stat {
	struct PFS_single_stat     m_wait_stat;          /*     0    32 */
	void aggregate(class PFS_cond_stat *, const class PFS_cond_stat  *);

	void reset(class PFS_cond_stat *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */
};
struct PFS_file_io_stat {
	struct PFS_byte_stat       m_read;               /*     0    40 */
	struct PFS_byte_stat       m_write;              /*    40    40 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	struct PFS_byte_stat       m_misc;               /*    80    40 */
	void reset(class PFS_file_io_stat *);

	void aggregate(class PFS_file_io_stat *, const class PFS_file_io_stat  *);

	void sum(class PFS_file_io_stat *, class PFS_byte_stat *);

	void sum_waits(class PFS_file_io_stat *, class PFS_single_stat *);


	/* size: 120, cachelines: 2, members: 3 */
	/* last cacheline: 56 bytes */
};
struct PFS_file_stat {
	ulong                      m_open_count;         /*     0     8 */
	struct PFS_file_io_stat    m_io_stat;            /*     8   120 */
	void aggregate(class PFS_file_stat *, const class PFS_file_stat  *);

	void reset(class PFS_file_stat *);


	/* size: 128, cachelines: 2, members: 2 */
};
struct PFS_transaction_stat {
	struct PFS_single_stat     m_read_write_stat;    /*     0    32 */
	struct PFS_single_stat     m_read_only_stat;     /*    32    32 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  m_savepoint_count;    /*    64     8 */
	ulonglong                  m_rollback_to_savepoint_count; /*    72     8 */
	ulonglong                  m_release_savepoint_count; /*    80     8 */
	void PFS_transaction_stat(class PFS_transaction_stat *);

	ulonglong count(class PFS_transaction_stat *);

	void reset(class PFS_transaction_stat *);

	void aggregate(class PFS_transaction_stat *, const class PFS_transaction_stat  *);


	/* size: 88, cachelines: 2, members: 5 */
	/* last cacheline: 24 bytes */
};
struct PFS_error_single_stat {
	ulonglong                  m_count;              /*     0     8 */
	ulonglong                  m_handled_count;      /*     8     8 */
	ulonglong                  m_first_seen;         /*    16     8 */
	ulonglong                  m_last_seen;          /*    24     8 */
	void PFS_error_single_stat(class PFS_error_single_stat *);

	ulonglong count(class PFS_error_single_stat *);

	void reset(class PFS_error_single_stat *);

	void aggregate_count(class PFS_error_single_stat *, int);

	void aggregate(class PFS_error_single_stat *, const class PFS_error_single_stat  *);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct PFS_error_stat {
	size_t                     m_max_errors;         /*     0     8 */
	class PFS_error_single_stat * m_stat;            /*     8     8 */
	void PFS_error_stat(class PFS_error_stat *);

	const class PFS_error_single_stat  * get_stat(const class PFS_error_stat  *, uint);

	ulonglong count(class PFS_error_stat *);

	ulonglong count(class PFS_error_stat *, uint);

	void init(class PFS_error_stat *, class PFS_builtin_memory_class *, size_t);

	void cleanup(class PFS_error_stat *, class PFS_builtin_memory_class *);

	void reset(class PFS_error_stat *);

	void aggregate_count(class PFS_error_stat *, int, int);

	void aggregate(class PFS_error_stat *, const class PFS_error_single_stat  *, uint);

	void aggregate(class PFS_error_stat *, const class PFS_error_stat  *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PFS_table_io_stat {
	bool                       m_has_data;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	struct PFS_single_stat     m_fetch;              /*     8    32 */
	struct PFS_single_stat     m_insert;             /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	struct PFS_single_stat     m_update;             /*    72    32 */
	struct PFS_single_stat     m_delete;             /*   104    32 */
	void PFS_table_io_stat(class PFS_table_io_stat *);

	void reset(class PFS_table_io_stat *);

	void aggregate(class PFS_table_io_stat *, const class PFS_table_io_stat  *);

	void sum(class PFS_table_io_stat *, class PFS_single_stat *);


	/* size: 136, cachelines: 3, members: 5 */
	/* sum members: 129, holes: 1, sum holes: 7 */
	/* last cacheline: 8 bytes */
};
struct PFS_table_lock_stat {
	struct PFS_single_stat     m_stat[10];           /*     0   320 */
	void reset(class PFS_table_lock_stat *);

	void aggregate(class PFS_table_lock_stat *, const class PFS_table_lock_stat  *);

	void sum(class PFS_table_lock_stat *, class PFS_single_stat *);


	/* size: 320, cachelines: 5, members: 1 */
};
class PFS_instr_name {
public:

	static const uint                 max_length = 127; /*     0     0 */
	char                       m_private_name[128];  /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint                       m_private_name_length; /*   128     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_private_old_name;   /*   136     8 */
	uint                       m_private_old_name_length; /*   144     4 */
	enum enum_compatibility_version m_private_version; /*   148     4 */
	const char  * str(const class PFS_instr_name  *);

	uint length(const class PFS_instr_name  *);

	void set(class PFS_instr_name *, enum PFS_class_type, const char  *, uint);


	/* size: 152, cachelines: 3, members: 5, static members: 1 */
	/* sum members: 148, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct PFS_instr_class {
	enum PFS_class_type        m_type;               /*     0     4 */
	bool                       m_enabled;            /*     4     1 */
	bool                       m_timed;              /*     5     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       m_flags;              /*     8     4 */
	int                        m_volatility;         /*    12     4 */
	uint                       m_event_name_index;   /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	class PFS_instr_name      m_name;                /*    24   152 */
	/* --- cacheline 2 boundary (128 bytes) was 48 bytes ago --- */
	char *                     m_documentation;      /*   176     8 */
	bool is_singleton(const class PFS_instr_class  *);

	bool is_mutable(const class PFS_instr_class  *);

	bool is_progress(const class PFS_instr_class  *);

	bool is_shared_exclusive(const class PFS_instr_class  *);

	bool is_priority(const class PFS_instr_class  *);

	bool is_transferable(const class PFS_instr_class  *);

	bool is_user(const class PFS_instr_class  *);

	bool is_system_thread(const class PFS_instr_class  *);

	bool is_global(const class PFS_instr_class  *);

	void enforce_valid_flags(class PFS_instr_class *, uint);

	void set_enabled(class PFS_instr_class *, bool);

	void set_timed(class PFS_instr_class *, bool);

	bool is_deferred(const class PFS_instr_class  *);

	bool can_be_timed(const class PFS_instr_class  *);


	/* size: 184, cachelines: 3, members: 8 */
	/* sum members: 178, holes: 2, sum holes: 6 */
	/* last cacheline: 56 bytes */
};
struct PFS_mutex_class : PFS_instr_class {
	/* struct PFS_instr_class     <ancestor>; */     /*     0   184 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	struct PFS_mutex_stat      m_mutex_stat;         /*   184    32 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	class PFS_mutex *          m_singleton;          /*   216     8 */

	/* size: 256, cachelines: 4, members: 3 */
	/* padding: 32 */

	/* BRAIN FART ALERT! 256 bytes != 40 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1472 bits */
} __attribute__((__aligned__(64)));
struct PFS_rwlock_class : PFS_instr_class {
	/* struct PFS_instr_class     <ancestor>; */     /*     0   184 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	struct PFS_rwlock_stat     m_rwlock_stat;        /*   184    32 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	class PFS_rwlock *         m_singleton;          /*   216     8 */

	/* size: 256, cachelines: 4, members: 3 */
	/* padding: 32 */

	/* BRAIN FART ALERT! 256 bytes != 40 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1472 bits */
} __attribute__((__aligned__(64)));
struct PFS_cond_class : PFS_instr_class {
	/* struct PFS_instr_class     <ancestor>; */     /*     0   184 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	struct PFS_cond_stat       m_cond_stat;          /*   184    32 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	class PFS_cond *           m_singleton;          /*   216     8 */

	/* size: 256, cachelines: 4, members: 3 */
	/* padding: 32 */

	/* BRAIN FART ALERT! 256 bytes != 40 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1472 bits */
} __attribute__((__aligned__(64)));
struct PFS_error_class : PFS_instr_class {
	/* struct PFS_instr_class     <ancestor>; */     /*     0   184 */

	/* size: 192, cachelines: 3, members: 1 */
	/* padding: 8 */

	/* BRAIN FART ALERT! 192 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1472 bits */
} __attribute__((__aligned__(64)));
struct PFS_file_class : PFS_instr_class {
	/* struct PFS_instr_class     <ancestor>; */     /*     0   184 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	struct PFS_file_stat       m_file_stat;          /*   184   128 */
	/* --- cacheline 4 boundary (256 bytes) was 56 bytes ago --- */
	class PFS_file *           m_singleton;          /*   312     8 */

	/* size: 320, cachelines: 5, members: 3 */

	/* BRAIN FART ALERT! 320 bytes != 136 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1472 bits */
} __attribute__((__aligned__(64)));
struct PFS_transaction_class : PFS_instr_class {
	/* struct PFS_instr_class     <ancestor>; */     /*     0   184 */

	/* size: 192, cachelines: 3, members: 1 */
	/* padding: 8 */

	/* BRAIN FART ALERT! 192 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1472 bits */
} __attribute__((__aligned__(64)));
class List_iterator<Security_context> : public base_list_iterator {
public:

	/* class base_list_iterator  <ancestor>; */      /*     0    32 */
	void List_iterator(class List_iterator<Security_context> *, class List<Security_context> &);

	void List_iterator(class List_iterator<Security_context> *);

	void init(class List_iterator<Security_context> *, class List<Security_context> &);

	class Security_context * operator++(class List_iterator<Security_context> *, int);

	class Security_context * replace(class List_iterator<Security_context> *, class Security_context *);

	class Security_context * replace(class List_iterator<Security_context> *, class List<Security_context> &);

	void rewind(class List_iterator<Security_context> *);

	void remove(class List_iterator<Security_context> *);

	void after(class List_iterator<Security_context> *, class Security_context *);

	bool after(class List_iterator<Security_context> *, class Security_context *, class MEM_ROOT *);

	class Security_context * * ref(class List_iterator<Security_context> *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class base_ilist_iterator<Item_change_record> {
	class base_ilist<Item_change_record> * list;     /*     0     8 */
	class Item_change_record * * el;                 /*     8     8 */
	class Item_change_record * current;              /*    16     8 */
public:

	void base_ilist_iterator(class base_ilist_iterator<Item_change_record> *, class base_ilist<Item_change_record> &);

	class Item_change_record * next(class base_ilist_iterator<Item_change_record> *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class I_List_iterator<Item_change_record> : public base_ilist_iterator<Item_change_record> {
public:

	/* class base_ilist_iterator<Item_change_record> <ancestor>; */ /*     0    24 */
	void I_List_iterator(class I_List_iterator<Item_change_record> *, class I_List<Item_change_record> &);

	class Item_change_record * operator++(class I_List_iterator<Item_change_record> *, int);


	/* size: 24, cachelines: 1, members: 1 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class KeyringsLocker {
public:

	class KeyringsLocker & get_instance(void);

	void ~KeyringsLocker(class KeyringsLocker *, int);

	int lock_keyrings(class KeyringsLocker *, class THD *);

	int unlock_keyrings(class KeyringsLocker *, class THD *);

	typedef struct vector<st_plugin_int*, std::allocator<st_plugin_int*> > LockedKeyringsPlugins;

	LockedKeyringsPlugins      locked_keyring_plugins; /*     0    24 */
	void KeyringsLocker(class KeyringsLocker *);

	struct mysql_mutex_t       mutex;                /*    24    48 */

	/* size: 72, cachelines: 2, members: 2 */
	/* last cacheline: 8 bytes */
};
class Malloc_allocator<void*> {
	PSI_memory_key             m_key;                /*     0     4 */
	typedef void * * pointer;

public:

	pointer address(const class Malloc_allocator<void*>  *, reference);

	typedef void * & reference;

	typedef void * const * const_pointer;

	const_pointer address(const class Malloc_allocator<void*>  *, const_reference);

	typedef void * const & const_reference;

	void Malloc_allocator(class Malloc_allocator<void*> *, PSI_memory_key);

	pointer allocate(class Malloc_allocator<void*> *, size_type, const_pointer);

	typedef size_t size_type;

	void deallocate(class Malloc_allocator<void*> *, pointer, size_type);

	void destroy(class Malloc_allocator<void*> *, pointer);

	size_type max_size(const class Malloc_allocator<void*>  *);

	PSI_memory_key psi_key(const class Malloc_allocator<void*>  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Internal_error_handler {
public:

	void Internal_error_handler(class Internal_error_handler *, const class Internal_error_handler  &);

	int ()(void) * *           _vptr.Internal_error_handler; /*     0     8 */
protected:

	void Internal_error_handler(class Internal_error_handler *);

	class Internal_error_handler * prev_internal_handler(const class Internal_error_handler  *);

	virtual void ~Internal_error_handler(class Internal_error_handler *, int);

public:

	virtual bool handle_condition(class Internal_error_handler *, class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	class Internal_error_handler * m_prev_internal_handler; /*     8     8 */
	/* vtable has 1 entries: {
	   [2] = handle_condition((null)), 
	} */
	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Sql_cmd {
public:

	int ()(void) * *           _vptr.Sql_cmd;        /*     0     8 */
	void Sql_cmd(class Sql_cmd *, const class Sql_cmd  &);

	void operator=(class Sql_cmd *, class Sql_cmd &);

	virtual enum enum_sql_command sql_command_code(const class Sql_cmd  *);

	bool needs_explicit_preparation(const class Sql_cmd  *);

	bool is_regular(const class Sql_cmd  *);

	bool is_prepared(const class Sql_cmd  *);

	virtual bool prepare(class Sql_cmd *, class THD *);

	virtual bool execute(class Sql_cmd *, class THD *);

	virtual void cleanup(class Sql_cmd *, class THD *);

	void set_owner(class Sql_cmd *, class Prepared_statement *);

	class Prepared_statement * owner(const class Sql_cmd  *);

	void set_as_part_of_sp(class Sql_cmd *);

	bool is_part_of_sp(const class Sql_cmd  *);

	virtual bool is_dml(const class Sql_cmd  *);

	virtual bool is_single_table_plan(const class Sql_cmd  *);

	virtual bool accept(class Sql_cmd *, class THD *, class Select_lex_visitor *);

	virtual const class MYSQL_LEX_CSTRING  * eligible_secondary_storage_engine(const class Sql_cmd  *);

	void disable_secondary_storage_engine(class Sql_cmd *);

	bool secondary_storage_engine_disabled(const class Sql_cmd  *);

	void use_secondary_storage_engine(class Sql_cmd *, const class handlerton  *);

	bool using_secondary_storage_engine(const class Sql_cmd  *);

	const class handlerton  * secondary_engine(const class Sql_cmd  *);

	void set_optional_transform_prepared(class Sql_cmd *, bool);

	bool is_optional_transform_prepared(class Sql_cmd *);

protected:

	void Sql_cmd(class Sql_cmd *);

	virtual void ~Sql_cmd(class Sql_cmd *, int);

	void set_prepared(class Sql_cmd *);

	class Prepared_statement * m_owner;              /*     8     8 */
	bool                       m_part_of_sp;         /*    16     1 */
	bool                       m_prepared;           /*    17     1 */
	bool                       m_secondary_engine_enabled; /*    18     1 */
	bool                       m_prepared_with_optional_transform; /*    19     1 */

	/* XXX 4 bytes hole, try to pack */

	const class handlerton  *  m_secondary_engine;   /*    24     8 */
	/* vtable has 8 entries: {
	   [0] = sql_command_code((null)), 
	   [1] = prepare((null)), 
	   [2] = execute((null)), 
	   [3] = cleanup((null)), 
	   [4] = is_dml((null)), 
	   [5] = is_single_table_plan((null)), 
	   [6] = accept((null)), 
	   [7] = eligible_secondary_storage_engine((null)), 
	} */
	/* size: 32, cachelines: 1, members: 7 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
class Item_basic_constant : public Item {
public:

	/* class Item                <ancestor>; */      /*     0     0 */

	/* XXX 144 bytes hole, try to pack */
	void Item_basic_constant(class Item_basic_constant *, );

	void Item_basic_constant(class Item_basic_constant *, const class Item_basic_constant  &);


	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	table_map                  used_table_map;       /*   144     8 */
	void Item_basic_constant(class Item_basic_constant *);

	void Item_basic_constant(class Item_basic_constant *, const POS  &);

	void set_used_tables(class Item_basic_constant *, table_map);

	virtual table_map used_tables(const class Item_basic_constant  *);

	virtual bool check_function_as_value_generator(class Item_basic_constant *, uchar *);

	virtual void cleanup(class Item_basic_constant *);

	virtual bool basic_const_item(const class Item_basic_constant  *);

	void set_str_value(class Item_basic_constant *, class String *);

	virtual void ~Item_basic_constant(class Item_basic_constant *, int);

	/* vtable has 4 entries: {
	   [44] = used_tables((null)), 
	   [118] = check_function_as_value_generator((null)), 
	   [5] = cleanup((null)), 
	   [46] = basic_const_item((null)), 
	} */
	/* size: 152, cachelines: 3, members: 2 */
	/* sum members: 8, holes: 1, sum holes: 144 */
	/* last cacheline: 24 bytes */
};
class Item_func_match_predicate : public Item_bool_func {
public:

	/* class Item_bool_func      <ancestor>; */      /*     0   216 */

	/* XXX last struct has 7 bytes of padding */
	void Item_func_match_predicate(class Item_func_match_predicate *, class Item *);

	virtual longlong val_int(class Item_func_match_predicate *);

	virtual enum Functype functype(const class Item_func_match_predicate  *);

	virtual const char  * func_name(const class Item_func_match_predicate  *);

	virtual void print(const class Item_func_match_predicate  *, const class THD  *, class String *, enum enum_query_type);

	virtual float get_filtering_effect(class Item_func_match_predicate *, class THD *, table_map, table_map, const class MY_BITMAP  *, double);

	virtual void ~Item_func_match_predicate(class Item_func_match_predicate *, int);

	/* vtable has 5 entries: {
	   [30] = val_int((null)), 
	   [164] = functype((null)), 
	   [161] = func_name((null)), 
	   [52] = print((null)), 
	   [38] = get_filtering_effect((null)), 
	} */
	/* size: 216, cachelines: 4, members: 1 */
	/* paddings: 1, sum paddings: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 216 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1728 bits */
};
class Item_bool_func : public Item_int_func {
public:

	/* class Item_int_func       <ancestor>; */      /*     0     0 */

	/* XXX 208 bytes hole, try to pack */
	void Item_bool_func(class Item_bool_func *, );

	void Item_bool_func(class Item_bool_func *, const class Item_bool_func  &);

protected:

	void Item_bool_func(class Item_bool_func *);

	void Item_bool_func(class Item_bool_func *, const POS  &);

	void Item_bool_func(class Item_bool_func *, class Item *);

	void Item_bool_func(class Item_bool_func *, const POS  &, class Item *);

	void Item_bool_func(class Item_bool_func *, class Item *, class Item *, class Item *);

	void Item_bool_func(class Item_bool_func *, class Item *, class Item *);

	void Item_bool_func(class Item_bool_func *, const POS  &, class Item *, class Item *);

	void Item_bool_func(class Item_bool_func *, const POS  &, class Item *, class Item *, class Item *);

	void Item_bool_func(class Item_bool_func *, class THD *, class Item_bool_func *);

public:

	virtual bool is_bool_func(const class Item_bool_func  *);

	virtual bool resolve_type(class Item_bool_func *, class THD *);

	virtual uint decimal_precision(const class Item_bool_func  *);

	virtual bool created_by_in2exists(const class Item_bool_func  *);

	void set_created_by_in2exists(class Item_bool_func *);


	static const char  *              bool_transform_names[10]; /*     0     0 */
	static const const enum Bool_test bool_transform[10][8]; /*     0     0 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	bool                       m_created_by_in2exists; /*   208     1 */
	virtual void ~Item_bool_func(class Item_bool_func *, int);

	/* vtable has 4 entries: {
	   [63] = is_bool_func((null)), 
	   [160] = resolve_type((null)), 
	   [49] = decimal_precision((null)), 
	   [150] = created_by_in2exists((null)), 
	} */
	/* size: 216, cachelines: 4, members: 2, static members: 2 */
	/* sum members: 1, holes: 1, sum holes: 208 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
class Item_func_false : public Item_func_bool_const {
public:

	/* class Item_func_bool_const <ancestor>; */     /*     0   216 */
	void Item_func_false(class Item_func_false *);

	void Item_func_false(class Item_func_false *, const POS  &);

	virtual const char  * func_name(const class Item_func_false  *);

	virtual bool val_bool(class Item_func_false *);

	virtual longlong val_int(class Item_func_false *);

	virtual void print(const class Item_func_false  *, const class THD  *, class String *, enum enum_query_type);

	virtual void ~Item_func_false(class Item_func_false *, int);

	/* vtable has 4 entries: {
	   [161] = func_name((null)), 
	   [36] = val_bool((null)), 
	   [30] = val_int((null)), 
	   [52] = print((null)), 
	} */
	/* size: 216, cachelines: 4, members: 1 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 216 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1728 bits */
};
class Item_func_bool_const : public Item_bool_func {
public:

	/* class Item_bool_func      <ancestor>; */      /*     0   216 */

	/* XXX last struct has 7 bytes of padding */
	void Item_func_bool_const(class Item_func_bool_const *, );

	void Item_func_bool_const(class Item_func_bool_const *, const class Item_func_bool_const  &);

	void Item_func_bool_const(class Item_func_bool_const *);

	void Item_func_bool_const(class Item_func_bool_const *, const POS  &);

	virtual bool fix_fields(class Item_func_bool_const *, class THD *, class Item * *);

	virtual bool basic_const_item(const class Item_func_bool_const  *);

	virtual void cleanup(class Item_func_bool_const *);

	virtual void ~Item_func_bool_const(class Item_func_bool_const *, int);

	/* vtable has 3 entries: {
	   [9] = fix_fields((null)), 
	   [46] = basic_const_item((null)), 
	   [5] = cleanup((null)), 
	} */
	/* size: 216, cachelines: 4, members: 1 */
	/* paddings: 1, sum paddings: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 216 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1728 bits */
};
class Item_func_true : public Item_func_bool_const {
public:

	/* class Item_func_bool_const <ancestor>; */     /*     0   216 */
	void Item_func_true(class Item_func_true *);

	void Item_func_true(class Item_func_true *, const POS  &);

	virtual const char  * func_name(const class Item_func_true  *);

	virtual bool val_bool(class Item_func_true *);

	virtual longlong val_int(class Item_func_true *);

	virtual void print(const class Item_func_true  *, const class THD  *, class String *, enum enum_query_type);

	virtual enum Functype functype(const class Item_func_true  *);

	virtual void ~Item_func_true(class Item_func_true *, int);

	/* vtable has 5 entries: {
	   [161] = func_name((null)), 
	   [36] = val_bool((null)), 
	   [30] = val_int((null)), 
	   [52] = print((null)), 
	   [164] = functype((null)), 
	} */
	/* size: 216, cachelines: 4, members: 1 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 216 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1728 bits */
};
class Item_var_func : public Item_func {
public:

	/* class Item_func           <ancestor>; */      /*     0     0 */
	void Item_var_func(class Item_var_func *, );

	void Item_var_func(class Item_var_func *, const class Item_var_func  &);

	void Item_var_func(class Item_var_func *);

	void Item_var_func(class Item_var_func *, const POS  &);

	void Item_var_func(class Item_var_func *, class THD *, class Item_var_func *);

	void Item_var_func(class Item_var_func *, class Item *);

	void Item_var_func(class Item_var_func *, const POS  &, class Item *);

	virtual bool get_date(class Item_var_func *, MYSQL_TIME *, my_time_flags_t);

	virtual bool get_time(class Item_var_func *, MYSQL_TIME *);

	virtual bool check_function_as_value_generator(class Item_var_func *, uchar *);

	virtual void ~Item_var_func(class Item_var_func *, int);

	/* vtable has 3 entries: {
	   [55] = get_date((null)), 
	   [56] = get_time((null)), 
	   [118] = check_function_as_value_generator((null)), 
	} */
	/* size: 208, cachelines: 4, members: 1 */
	/* padding: 208 */
	/* last cacheline: 16 bytes */
};
class Item_func_shift_right : public Item_func_shift {
public:

	/* class Item_func_shift     <ancestor>; */      /*     0   248 */

	/* XXX last struct has 248 bytes of padding */
	void Item_func_shift_right(class Item_func_shift_right *, const POS  &, class Item *, class Item *);

	virtual const char  * func_name(const class Item_func_shift_right  *);

	virtual longlong int_op(class Item_func_shift_right *);

	virtual class String * str_op(class Item_func_shift_right *, class String *);

	virtual void ~Item_func_shift_right(class Item_func_shift_right *, int);

	/* vtable has 3 entries: {
	   [161] = func_name((null)), 
	   [178] = int_op((null)), 
	   [179] = str_op((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* paddings: 1, sum paddings: 248 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 248 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1984 bits */
};
class Item_func_shift : public Item_func_bit {
public:

	/* class Item_func_bit       <ancestor>; */      /*     0     0 */
	void Item_func_shift(class Item_func_shift *, );

	void Item_func_shift(class Item_func_shift *, const class Item_func_shift  &);

protected:

	virtual bool binary_result_requires_binary_second_arg(const class Item_func_shift  *);

public:

	void Item_func_shift(class Item_func_shift *, const POS  &, class Item *, class Item *);

	virtual void ~Item_func_shift(class Item_func_shift *, int);

	/* vtable has 1 entries: {
	   [177] = binary_result_requires_binary_second_arg((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* padding: 248 */
	/* last cacheline: 56 bytes */
};
class Item_func_shift_left : public Item_func_shift {
public:

	/* class Item_func_shift     <ancestor>; */      /*     0   248 */

	/* XXX last struct has 248 bytes of padding */
	void Item_func_shift_left(class Item_func_shift_left *, const POS  &, class Item *, class Item *);

	virtual const char  * func_name(const class Item_func_shift_left  *);

	virtual longlong int_op(class Item_func_shift_left *);

	virtual class String * str_op(class Item_func_shift_left *, class String *);

	virtual void ~Item_func_shift_left(class Item_func_shift_left *, int);

	/* vtable has 3 entries: {
	   [161] = func_name((null)), 
	   [178] = int_op((null)), 
	   [179] = str_op((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* paddings: 1, sum paddings: 248 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 248 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1984 bits */
};
class Item_func_bit_xor : public Item_func_bit_two_param {
public:

	/* class Item_func_bit_two_param <ancestor>; */  /*     0   248 */

	/* XXX last struct has 248 bytes of padding */
	void Item_func_bit_xor(class Item_func_bit_xor *, const POS  &, class Item *, class Item *);

	virtual const char  * func_name(const class Item_func_bit_xor  *);

	virtual longlong int_op(class Item_func_bit_xor *);

	virtual class String * str_op(class Item_func_bit_xor *, class String *);

	virtual void ~Item_func_bit_xor(class Item_func_bit_xor *, int);

	/* vtable has 3 entries: {
	   [161] = func_name((null)), 
	   [178] = int_op((null)), 
	   [179] = str_op((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* paddings: 1, sum paddings: 248 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 248 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1984 bits */
};
class Item_func_bit_two_param : public Item_func_bit {
public:

	/* class Item_func_bit       <ancestor>; */      /*     0     0 */
	void Item_func_bit_two_param(class Item_func_bit_two_param *, );

	void Item_func_bit_two_param(class Item_func_bit_two_param *, const class Item_func_bit_two_param  &);

protected:

	virtual bool binary_result_requires_binary_second_arg(const class Item_func_bit_two_param  *);

public:

	void Item_func_bit_two_param(class Item_func_bit_two_param *, const POS  &, class Item *, class Item *);

	virtual void ~Item_func_bit_two_param(class Item_func_bit_two_param *, int);

	/* vtable has 1 entries: {
	   [177] = binary_result_requires_binary_second_arg((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* padding: 248 */
	/* last cacheline: 56 bytes */
};
class Item_func_bit_and : public Item_func_bit_two_param {
public:

	/* class Item_func_bit_two_param <ancestor>; */  /*     0   248 */

	/* XXX last struct has 248 bytes of padding */
	void Item_func_bit_and(class Item_func_bit_and *, const POS  &, class Item *, class Item *);

	virtual const char  * func_name(const class Item_func_bit_and  *);

	virtual longlong int_op(class Item_func_bit_and *);

	virtual class String * str_op(class Item_func_bit_and *, class String *);

	virtual void ~Item_func_bit_and(class Item_func_bit_and *, int);

	/* vtable has 3 entries: {
	   [161] = func_name((null)), 
	   [178] = int_op((null)), 
	   [179] = str_op((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* paddings: 1, sum paddings: 248 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 248 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1984 bits */
};
class Item_func_bit_or : public Item_func_bit_two_param {
public:

	/* class Item_func_bit_two_param <ancestor>; */  /*     0   248 */

	/* XXX last struct has 248 bytes of padding */
	void Item_func_bit_or(class Item_func_bit_or *, const POS  &, class Item *, class Item *);

	virtual const char  * func_name(const class Item_func_bit_or  *);

	virtual longlong int_op(class Item_func_bit_or *);

	virtual class String * str_op(class Item_func_bit_or *, class String *);

	virtual void ~Item_func_bit_or(class Item_func_bit_or *, int);

	/* vtable has 3 entries: {
	   [161] = func_name((null)), 
	   [178] = int_op((null)), 
	   [179] = str_op((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* paddings: 1, sum paddings: 248 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 248 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1984 bits */
};
class Item_func_instr : public Item_func_locate {
public:

	/* class Item_func_locate    <ancestor>; */      /*     0     0 */
	void Item_func_instr(class Item_func_instr *, const POS  &, class Item *, class Item *);

	virtual const char  * func_name(const class Item_func_instr  *);

	virtual void ~Item_func_instr(class Item_func_instr *, int);

	/* vtable has 1 entries: {
	   [161] = func_name((null)), 
	} */
	/* size: 272, cachelines: 5, members: 1 */
	/* padding: 272 */
	/* last cacheline: 16 bytes */
};
class Item_func_bit_length : public Item_func_length {
public:

	/* class Item_func_length    <ancestor>; */      /*     0     0 */
	void Item_func_bit_length(class Item_func_bit_length *, const POS  &, class Item *);

	virtual longlong val_int(class Item_func_bit_length *);

	virtual const char  * func_name(const class Item_func_bit_length  *);

	virtual void ~Item_func_bit_length(class Item_func_bit_length *, int);

	/* vtable has 2 entries: {
	   [30] = val_int((null)), 
	   [161] = func_name((null)), 
	} */
	/* size: 240, cachelines: 4, members: 1 */
	/* padding: 240 */
	/* last cacheline: 48 bytes */
};
class Item_func_max : public Item_func_min_max {
public:

	/* class Item_func_min_max   <ancestor>; */      /*     0     0 */
	void Item_func_max(class Item_func_max *, const POS  &, class PT_item_list *);

	virtual const char  * func_name(const class Item_func_max  *);

	virtual enum Functype functype(const class Item_func_max  *);

	virtual void ~Item_func_max(class Item_func_max *, int);

	/* vtable has 2 entries: {
	   [161] = func_name((null)), 
	   [164] = functype((null)), 
	} */
	/* size: 256, cachelines: 4, members: 1 */
	/* padding: 256 */
};
class Item_func_min : public Item_func_min_max {
public:

	/* class Item_func_min_max   <ancestor>; */      /*     0     0 */
	void Item_func_min(class Item_func_min *, const POS  &, class PT_item_list *);

	virtual const char  * func_name(const class Item_func_min  *);

	virtual enum Functype functype(const class Item_func_min  *);

	virtual void ~Item_func_min(class Item_func_min *, int);

	/* vtable has 2 entries: {
	   [161] = func_name((null)), 
	   [164] = functype((null)), 
	} */
	/* size: 256, cachelines: 4, members: 1 */
	/* padding: 256 */
};
class Item_func_radians : public Item_func_units {
public:

	/* class Item_func_units     <ancestor>; */      /*     0     0 */
	void Item_func_radians(class Item_func_radians *, const POS  &, class Item *);

	virtual const char  * func_name(const class Item_func_radians  *);

	virtual enum Functype functype(const class Item_func_radians  *);

	virtual void ~Item_func_radians(class Item_func_radians *, int);

	/* vtable has 2 entries: {
	   [161] = func_name((null)), 
	   [164] = functype((null)), 
	} */
	/* size: 224, cachelines: 4, members: 1 */
	/* padding: 224 */
	/* last cacheline: 32 bytes */
};
class Item_func_degrees : public Item_func_units {
public:

	/* class Item_func_units     <ancestor>; */      /*     0     0 */
	void Item_func_degrees(class Item_func_degrees *, const POS  &, class Item *);

	virtual const char  * func_name(const class Item_func_degrees  *);

	virtual enum Functype functype(const class Item_func_degrees  *);

	virtual void ~Item_func_degrees(class Item_func_degrees *, int);

	/* vtable has 2 entries: {
	   [161] = func_name((null)), 
	   [164] = functype((null)), 
	} */
	/* size: 224, cachelines: 4, members: 1 */
	/* padding: 224 */
	/* last cacheline: 32 bytes */
};
class Item_metadata_copy : public Item {
public:

	/* class Item                <ancestor>; */      /*     0     0 */

	/* XXX 140 bytes hole, try to pack */
	void Item_metadata_copy(class Item_metadata_copy *, class Item *);

	virtual enum Type type(const class Item_metadata_copy  *);

	virtual enum Item_result result_type(const class Item_metadata_copy  *);

	virtual table_map used_tables(const class Item_metadata_copy  *);

	virtual class String * val_str(class Item_metadata_copy *, class String *);

	virtual class my_decimal * val_decimal(class Item_metadata_copy *, class my_decimal *);

	virtual double val_real(class Item_metadata_copy *);

	virtual longlong val_int(class Item_metadata_copy *);

	virtual bool get_date(class Item_metadata_copy *, MYSQL_TIME *, my_time_flags_t);

	virtual bool get_time(class Item_metadata_copy *, MYSQL_TIME *);

	virtual bool val_json(class Item_metadata_copy *, class Json_wrapper *);


	/* --- cacheline 2 boundary (128 bytes) was 12 bytes ago --- */
	enum Item_result           cached_result_type;   /*   140     4 */
	virtual void ~Item_metadata_copy(class Item_metadata_copy *, int);

	/* vtable has 10 entries: {
	   [26] = type((null)), 
	   [18] = result_type((null)), 
	   [44] = used_tables((null)), 
	   [33] = val_str((null)), 
	   [35] = val_decimal((null)), 
	   [29] = val_real((null)), 
	   [30] = val_int((null)), 
	   [55] = get_date((null)), 
	   [56] = get_time((null)), 
	   [37] = val_json((null)), 
	} */
	/* size: 144, cachelines: 3, members: 2 */
	/* sum members: 4, holes: 1, sum holes: 140 */
	/* last cacheline: 16 bytes */
};
class Item_bin_string : public Item_hex_string {
public:

	/* class Item_hex_string     <ancestor>; */      /*     0     0 */
	void Item_bin_string(class Item_bin_string *, const char  *, size_t);

	void Item_bin_string(class Item_bin_string *, const POS  &, const LEX_STRING  &);

	LEX_CSTRING make_bin_str(const char  *, size_t);

	void bin_string_init(class Item_bin_string *, const char  *, size_t);

	virtual void ~Item_bin_string(class Item_bin_string *, int);


	/* size: 152, cachelines: 3, members: 1 */
	/* padding: 152 */
	/* last cacheline: 24 bytes */
};
class Item_return_int : public Item_int {
public:

	/* class Item_int            <ancestor>; */      /*     0     0 */
	void Item_return_int(class Item_return_int *, );

	void Item_return_int(class Item_return_int *, const class Item_return_int  &);

	void Item_return_int(class Item_return_int *, const char  *, uint, enum enum_field_types, longlong);

	virtual void ~Item_return_int(class Item_return_int *, int);


	/* size: 160, cachelines: 3, members: 1 */
	/* padding: 160 */
	/* last cacheline: 32 bytes */
};
class Item_blob : public Item_partition_func_safe_string {
public:

	/* class Item_partition_func_safe_string <ancestor>; */ /*     0   160 */

	/* XXX last struct has 160 bytes of padding */
	void Item_blob(class Item_blob *, const char  *, size_t);

	virtual enum Type type(const class Item_blob  *);

	virtual bool check_function_as_value_generator(class Item_blob *, uchar *);

	virtual void ~Item_blob(class Item_blob *, int);

	/* vtable has 2 entries: {
	   [26] = type((null)), 
	   [118] = check_function_as_value_generator((null)), 
	} */
	/* size: 160, cachelines: 3, members: 1 */
	/* paddings: 1, sum paddings: 160 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 160 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1280 bits */
};
class Item_partition_func_safe_string : public Item_string {
public:

	/* class Item_string         <ancestor>; */      /*     0     0 */
	void Item_partition_func_safe_string(class Item_partition_func_safe_string *, );

	void Item_partition_func_safe_string(class Item_partition_func_safe_string *, const class Item_partition_func_safe_string  &);

	void Item_partition_func_safe_string(class Item_partition_func_safe_string *, class Name_string, size_t, const class CHARSET_INFO  *);

	virtual void ~Item_partition_func_safe_string(class Item_partition_func_safe_string *, int);


	/* size: 160, cachelines: 3, members: 1 */
	/* padding: 160 */
	/* last cacheline: 32 bytes */
};
class Item_int_0 : public Item_int {
public:

	/* class Item_int            <ancestor>; */      /*     0     0 */
	void Item_int_0(class Item_int_0 *);

	void Item_int_0(class Item_int_0 *, const POS  &);

	virtual void ~Item_int_0(class Item_int_0 *, int);


	/* size: 160, cachelines: 3, members: 1 */
	/* padding: 160 */
	/* last cacheline: 32 bytes */
};
class Settable_routine_parameter {
public:

	void Settable_routine_parameter(class Settable_routine_parameter *, const class Settable_routine_parameter  &);

	int ()(void) * *           _vptr.Settable_routine_parameter; /*     0     8 */
	void Settable_routine_parameter(class Settable_routine_parameter *);

	virtual void ~Settable_routine_parameter(class Settable_routine_parameter *, int);

	virtual void set_required_privilege(class Settable_routine_parameter *, ulong);

	virtual bool set_value(class Settable_routine_parameter *, class THD *, class sp_rcontext *, class Item * *);

	virtual void set_out_param_info(class Settable_routine_parameter *, class Send_field *);

	virtual const class Send_field  * get_out_param_info(const class Settable_routine_parameter  *);

	/* vtable has 4 entries: {
	   [2] = set_required_privilege((null)), 
	   [3] = set_value((null)), 
	   [4] = set_out_param_info((null)), 
	   [5] = get_out_param_info((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Object_creation_ctx {
public:

	void Object_creation_ctx(class Object_creation_ctx *, const class Object_creation_ctx  &);

	int ()(void) * *           _vptr.Object_creation_ctx; /*     0     8 */
	class Object_creation_ctx * set_n_backup(class Object_creation_ctx *, class THD *);

	void restore_env(class Object_creation_ctx *, class THD *, class Object_creation_ctx *);

protected:

	void Object_creation_ctx(class Object_creation_ctx *);

	virtual class Object_creation_ctx * create_backup_ctx(const class Object_creation_ctx  *, class THD *);

	virtual void delete_backup_ctx(class Object_creation_ctx *);

	virtual void change_env(const class Object_creation_ctx  *, class THD *);

public:

	virtual void ~Object_creation_ctx(class Object_creation_ctx *, int);

	/* vtable has 3 entries: {
	   [0] = create_backup_ctx((null)), 
	   [1] = delete_backup_ctx((null)), 
	   [2] = change_env((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class No_such_table_error_handler : public Internal_error_handler {
public:

	/* class Internal_error_handler <ancestor>; */   /*     0    16 */
	void No_such_table_error_handler(class No_such_table_error_handler *);

	virtual bool handle_condition(class No_such_table_error_handler *, class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	bool safely_trapped_errors(const class No_such_table_error_handler  *);

	int                        m_handled_errors;     /*    16     4 */
	int                        m_unhandled_errors;   /*    20     4 */
	virtual void ~No_such_table_error_handler(class No_such_table_error_handler *, int);

	/* vtable has 1 entries: {
	   [2] = handle_condition((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class Set_var_error_handler : public Internal_error_handler {
public:

	/* class Internal_error_handler <ancestor>; */   /*     0    16 */
	void Set_var_error_handler(class Set_var_error_handler *, bool);

	virtual bool handle_condition(class Set_var_error_handler *, class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	void reset_state(class Set_var_error_handler *);

	bool                       ignore_warn;          /*    16     1 */
	bool                       ignore_subsequent_messages; /*    17     1 */
	virtual void ~Set_var_error_handler(class Set_var_error_handler *, int);

	/* vtable has 1 entries: {
	   [2] = handle_condition((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 6 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 2 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class Rpl_transaction_ctx {
public:

	void Rpl_transaction_ctx(class Rpl_transaction_ctx *, const class Rpl_transaction_ctx  &);

	int ()(void) * *           _vptr.Rpl_transaction_ctx; /*     0     8 */
	void Rpl_transaction_ctx(class Rpl_transaction_ctx *);

	virtual void ~Rpl_transaction_ctx(class Rpl_transaction_ctx *, int);

	int set_rpl_transaction_ctx(class Rpl_transaction_ctx *, class Transaction_termination_ctx);

	bool is_transaction_rollback(class Rpl_transaction_ctx *);

	bool is_generated_gtid(class Rpl_transaction_ctx *);

	int get_sidno(class Rpl_transaction_ctx *);

	rpl_gno get_gno(class Rpl_transaction_ctx *);

	void cleanup(class Rpl_transaction_ctx *);

	struct Transaction_termination_ctx m_transaction_ctx; /*     8    32 */

	/* size: 40, cachelines: 1, members: 2 */
	/* last cacheline: 40 bytes */
};
class Rpl_transaction_write_set_ctx {
public:

	void Rpl_transaction_write_set_ctx(class Rpl_transaction_write_set_ctx *, const class Rpl_transaction_write_set_ctx  &);

	int ()(void) * *           _vptr.Rpl_transaction_write_set_ctx; /*     0     8 */
	void Rpl_transaction_write_set_ctx(class Rpl_transaction_write_set_ctx *);

	virtual void ~Rpl_transaction_write_set_ctx(class Rpl_transaction_write_set_ctx *, int);

	bool add_write_set(class Rpl_transaction_write_set_ctx *, uint64);

	class vector<long unsigned int, std::allocator<long unsigned int> > * get_write_set(class Rpl_transaction_write_set_ctx *);

	void reset_state(class Rpl_transaction_write_set_ctx *);

	void set_has_missing_keys(class Rpl_transaction_write_set_ctx *);

	bool get_has_missing_keys(class Rpl_transaction_write_set_ctx *);

	void set_has_related_foreign_keys(class Rpl_transaction_write_set_ctx *);

	bool get_has_related_foreign_keys(class Rpl_transaction_write_set_ctx *);

	bool was_write_set_limit_reached(class Rpl_transaction_write_set_ctx *);

	size_t write_set_memory_size(class Rpl_transaction_write_set_ctx *);

	void add_savepoint(class Rpl_transaction_write_set_ctx *, char *);

	void del_savepoint(class Rpl_transaction_write_set_ctx *, char *);

	void rollback_to_savepoint(class Rpl_transaction_write_set_ctx *, char *);

	void reset_savepoint_list(class Rpl_transaction_write_set_ctx *);

	void restore_savepoint_list(class Rpl_transaction_write_set_ctx *);

	void set_global_write_set_memory_size_limit(uint64);

	void update_global_write_set_memory_size_limit(uint64);

	void set_global_require_full_write_set(bool);

	void set_local_ignore_write_set_memory_limit(class Rpl_transaction_write_set_ctx *, bool);

	void set_local_allow_drop_write_set(class Rpl_transaction_write_set_ctx *, bool);

	void clear_write_set(class Rpl_transaction_write_set_ctx *);

	class vector<long unsigned int, std::allocator<long unsigned int> > write_set; /*     8    24 */
	bool                       m_has_missing_keys;   /*    32     1 */
	bool                       m_has_related_foreign_keys; /*    33     1 */

	/* XXX 6 bytes hole, try to pack */

	class map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > savepoint; /*    40    48 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	class list<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > >, std::allocator<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > > > savepoint_list; /*    88    24 */

	/* Bitfield combined with previous fields */

	static struct atomic<bool>        m_global_component_requires_write_sets; /*     0     0 */
	static struct atomic<long unsigned int> m_global_write_set_memory_size_limit; /*     0     0 */
	bool                       m_ignore_write_set_memory_limit; /*   112     1 */
	bool                       m_local_allow_drop_write_set; /*   113     1 */
	bool                       m_local_has_reached_write_set_limit; /*   114     1 */

	/* size: 120, cachelines: 2, members: 9, static members: 2 */
	/* sum members: 109, holes: 1, sum holes: 6 */
	/* padding: 5 */
	/* last cacheline: 56 bytes */
};
