struct typedef __va_list_tag __va_list_tag {
	unsigned int               gp_offset;            /*     0     4 */
	unsigned int               fp_offset;            /*     4     4 */
	void *                     overflow_arg_area;    /*     8     8 */
	void *                     reg_save_area;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct _G_fpos64_t {
	__off64_t                  __pos;                /*     0     8 */
	__mbstate_t                __state;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct _IO_FILE {
	int                        _flags;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     _IO_read_ptr;         /*     8     8 */
	char *                     _IO_read_end;         /*    16     8 */
	char *                     _IO_read_base;        /*    24     8 */
	char *                     _IO_write_base;       /*    32     8 */
	char *                     _IO_write_ptr;        /*    40     8 */
	char *                     _IO_write_end;        /*    48     8 */
	char *                     _IO_buf_base;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     _IO_buf_end;          /*    64     8 */
	char *                     _IO_save_base;        /*    72     8 */
	char *                     _IO_backup_base;      /*    80     8 */
	char *                     _IO_save_end;         /*    88     8 */
	class _IO_marker *         _markers;             /*    96     8 */
	class _IO_FILE *           _chain;               /*   104     8 */
	int                        _fileno;              /*   112     4 */
	int                        _flags2;              /*   116     4 */
	__off_t                    _old_offset;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	short unsigned int         _cur_column;          /*   128     2 */
	signed char                _vtable_offset;       /*   130     1 */
	char                       _shortbuf[1];         /*   131     1 */

	/* XXX 4 bytes hole, try to pack */

	_IO_lock_t *               _lock;                /*   136     8 */
	__off64_t                  _offset;              /*   144     8 */
	class _IO_codecvt *        _codecvt;             /*   152     8 */
	class _IO_wide_data *      _wide_data;           /*   160     8 */
	class _IO_FILE *           _freeres_list;        /*   168     8 */
	void *                     _freeres_buf;         /*   176     8 */
	size_t                     __pad5;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        _mode;                /*   192     4 */
	char                       _unused2[20];         /*   196    20 */

	/* size: 216, cachelines: 4, members: 29 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct timeval {
	__time_t                   tv_sec;               /*     0     8 */
	__suseconds_t              tv_usec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct timespec {
	__time_t                   tv_sec;               /*     0     8 */
	__syscall_slong_t          tv_nsec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct __pthread_internal_list {
	class __pthread_internal_list * __prev;          /*     0     8 */
	class __pthread_internal_list * __next;          /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct __pthread_mutex_s {
	int                        __lock;               /*     0     4 */
	unsigned int               __count;              /*     4     4 */
	int                        __owner;              /*     8     4 */
	unsigned int               __nusers;             /*    12     4 */
	int                        __kind;               /*    16     4 */
	short int                  __spins;              /*    20     2 */
	short int                  __elision;            /*    22     2 */
	__pthread_list_t           __list;               /*    24    16 */

	/* size: 40, cachelines: 1, members: 8 */
	/* last cacheline: 40 bytes */
};
struct __pthread_rwlock_arch_t {
	unsigned int               __readers;            /*     0     4 */
	unsigned int               __writers;            /*     4     4 */
	unsigned int               __wrphase_futex;      /*     8     4 */
	unsigned int               __writers_futex;      /*    12     4 */
	unsigned int               __pad3;               /*    16     4 */
	unsigned int               __pad4;               /*    20     4 */
	int                        __cur_writer;         /*    24     4 */
	int                        __shared;             /*    28     4 */
	signed char                __rwelision;          /*    32     1 */
	unsigned char              __pad1[7];            /*    33     7 */
	long unsigned int          __pad2;               /*    40     8 */
	unsigned int               __flags;              /*    48     4 */

	/* size: 56, cachelines: 1, members: 12 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct __pthread_cond_s {
	union {
		long long unsigned int     __wseq;               /*     0     8 */
		struct {
			unsigned int       __low;                /*     0     4 */
			unsigned int       __high;               /*     4     4 */
		} __wseq32;                                      /*     0     8 */
	};

	union {
		long long unsigned int     __g1_start;           /*     0     8 */
		struct {
			unsigned int       __low;                /*     0     4 */
			unsigned int       __high;               /*     4     4 */
		} __g1_start32;                                  /*     0     8 */
	};

	union {
		long long unsigned int __wseq;           /*     0     8 */
		struct {
			unsigned int __low;              /*     0     4 */
			unsigned int __high;             /*     4     4 */
		} __wseq32;                              /*     0     8 */
	};                                               /*     0     8 */
	union {
		long long unsigned int __g1_start;       /*     8     8 */
		struct {
			unsigned int __low;              /*     8     4 */
			unsigned int __high;             /*    12     4 */
		} __g1_start32;                          /*     8     8 */
	};                                               /*     8     8 */
	unsigned int               __g_refs[2];          /*    16     8 */
	unsigned int               __g_size[2];          /*    24     8 */
	unsigned int               __g1_orig_size;       /*    32     4 */
	unsigned int               __wrefs;              /*    36     4 */
	unsigned int               __g_signals[2];       /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
union pthread_attr_t {
	char                       __size[56];         /*     0    56 */
	long int                   __align;            /*     0     8 */
};
struct stat {
	__dev_t                    st_dev;               /*     0     8 */
	__ino_t                    st_ino;               /*     8     8 */
	__nlink_t                  st_nlink;             /*    16     8 */
	__mode_t                   st_mode;              /*    24     4 */
	__uid_t                    st_uid;               /*    28     4 */
	__gid_t                    st_gid;               /*    32     4 */
	int                        __pad0;               /*    36     4 */
	__dev_t                    st_rdev;              /*    40     8 */
	__off_t                    st_size;              /*    48     8 */
	__blksize_t                st_blksize;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	__blkcnt_t                 st_blocks;            /*    64     8 */
	struct timespec            st_atim;              /*    72    16 */
	struct timespec            st_mtim;              /*    88    16 */
	struct timespec            st_ctim;              /*   104    16 */
	__syscall_slong_t          __glibc_reserved[3];  /*   120    24 */

	/* size: 144, cachelines: 3, members: 15 */
	/* last cacheline: 16 bytes */
};
struct tm {
	int                        tm_sec;               /*     0     4 */
	int                        tm_min;               /*     4     4 */
	int                        tm_hour;              /*     8     4 */
	int                        tm_mday;              /*    12     4 */
	int                        tm_mon;               /*    16     4 */
	int                        tm_year;              /*    20     4 */
	int                        tm_wday;              /*    24     4 */
	int                        tm_yday;              /*    28     4 */
	int                        tm_isdst;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   tm_gmtoff;            /*    40     8 */
	const char  *              tm_zone;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct sockaddr {
	sa_family_t                sa_family;            /*     0     2 */
	char                       sa_data[14];          /*     2    14 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct sockaddr_storage {
	sa_family_t                ss_family;            /*     0     2 */
	char                       __ss_padding[118];    /*     2   118 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	long unsigned int          __ss_align;           /*   120     8 */

	/* size: 128, cachelines: 2, members: 3 */
};
struct in6_addr {
	union {
		uint8_t                    __u6_addr8[16];       /*     0    16 */
		uint16_t                   __u6_addr16[8];       /*     0    16 */
		uint32_t                   __u6_addr32[4];       /*     0    16 */
	};

	union {
		uint8_t            __u6_addr8[16];       /*     0    16 */
		uint16_t           __u6_addr16[8];       /*     0    16 */
		uint32_t           __u6_addr32[4];       /*     0    16 */
	} __in6_u;                                       /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct my_alignment_imp<8> {

	/* size: 8, cachelines: 1, members: 0 */
	/* padding: 8 */
	/* last cacheline: 8 bytes */
} __attribute__((__aligned__(8)));
struct st_mysql_lex_string {
	char *                     str;                  /*     0     8 */
	size_t                     length;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_mysql_const_lex_string {
	const char  *              str;                  /*     0     8 */
	size_t                     length;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_vio {
	MYSQL_SOCKET               mysql_socket;         /*     0    16 */
	my_bool                    localhost;            /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	struct sockaddr_storage    local;                /*    24   128 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	struct sockaddr_storage    remote;               /*   152   128 */
	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	size_t                     addrLen;              /*   280     8 */
	enum enum_vio_type         type;                 /*   288     4 */
	my_bool                    inactive;             /*   292     1 */
	my_bool                    force_skip_proxy;     /*   293     1 */
	char                       desc[30];             /*   294    30 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	char *                     read_buffer;          /*   328     8 */
	char *                     read_pos;             /*   336     8 */
	char *                     read_end;             /*   344     8 */
	int                        read_timeout;         /*   352     4 */
	int                        write_timeout;        /*   356     4 */
	void                       (*viodelete)(Vio *);  /*   360     8 */
	int                        (*vioerrno)(Vio *);   /*   368     8 */
	size_t                     (*read)(Vio *, uchar *, size_t); /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	size_t                     (*write)(Vio *, const uchar  *, size_t); /*   384     8 */
	int                        (*timeout)(Vio *, uint, my_bool); /*   392     8 */
	int                        (*viokeepalive)(Vio *, my_bool); /*   400     8 */
	int                        (*fastsend)(Vio *);   /*   408     8 */
	my_bool                    (*peer_addr)(Vio *, char *, uint16 *, size_t); /*   416     8 */
	void                       (*in_addr)(Vio *, class sockaddr_storage *); /*   424     8 */
	my_bool                    (*should_retry)(Vio *); /*   432     8 */
	my_bool                    (*was_timeout)(Vio *); /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	int                        (*vioshutdown)(Vio *, int); /*   448     8 */
	int                        (*viocancel)(Vio *, int); /*   456     8 */
	my_bool                    (*is_connected)(Vio *); /*   464     8 */
	my_bool                    (*has_data)(Vio *);   /*   472     8 */
	int                        (*io_wait)(Vio *, enum enum_vio_io_event, int); /*   480     8 */
	my_bool                    (*connect)(Vio *, class sockaddr *, socklen_t, int); /*   488     8 */
	void *                     ssl_arg;              /*   496     8 */

	/* size: 504, cachelines: 8, members: 32 */
	/* sum members: 493, holes: 2, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct st_net {
	Vio *                      vio;                  /*     0     8 */
	unsigned char *            buff;                 /*     8     8 */
	unsigned char *            buff_end;             /*    16     8 */
	unsigned char *            write_pos;            /*    24     8 */
	unsigned char *            read_pos;             /*    32     8 */
	my_socket                  fd;                   /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int          remain_in_buf;        /*    48     8 */
	long unsigned int          length;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	long unsigned int          buf_length;           /*    64     8 */
	long unsigned int          where_b;              /*    72     8 */
	long unsigned int          max_packet;           /*    80     8 */
	long unsigned int          max_packet_size;      /*    88     8 */
	unsigned int               pkt_nr;               /*    96     4 */
	unsigned int               compress_pkt_nr;      /*   100     4 */
	unsigned int               write_timeout;        /*   104     4 */
	unsigned int               read_timeout;         /*   108     4 */
	unsigned int               retry_count;          /*   112     4 */
	int                        fcntl;                /*   116     4 */
	unsigned int *             return_status;        /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	unsigned char              reading_or_writing;   /*   128     1 */
	char                       save_char;            /*   129     1 */
	my_bool                    unused1;              /*   130     1 */
	my_bool                    unused2;              /*   131     1 */
	my_bool                    compress;             /*   132     1 */
	my_bool                    unused3;              /*   133     1 */

	/* XXX 2 bytes hole, try to pack */

	unsigned char *            unused;               /*   136     8 */
	unsigned int               last_errno;           /*   144     4 */
	unsigned char              error;                /*   148     1 */
	my_bool                    unused4;              /*   149     1 */
	my_bool                    unused5;              /*   150     1 */
	char                       last_error[512];      /*   151   512 */
	/* --- cacheline 10 boundary (640 bytes) was 23 bytes ago --- */
	char                       sqlstate[6];          /*   663     6 */

	/* XXX 3 bytes hole, try to pack */

	void *                     extension;            /*   672     8 */

	/* size: 680, cachelines: 11, members: 33 */
	/* sum members: 671, holes: 3, sum holes: 9 */
	/* last cacheline: 40 bytes */
};
struct rand_struct {
	long unsigned int          seed1;                /*     0     8 */
	long unsigned int          seed2;                /*     8     8 */
	long unsigned int          max_value;            /*    16     8 */
	double                     max_value_dbl;        /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct st_udf_args {
	unsigned int               arg_count;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	enum Item_result *         arg_type;             /*     8     8 */
	char * *                   args;                 /*    16     8 */
	long unsigned int *        lengths;              /*    24     8 */
	char *                     maybe_null;           /*    32     8 */
	char * *                   attributes;           /*    40     8 */
	long unsigned int *        attribute_lengths;    /*    48     8 */
	void *                     extension;            /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct st_udf_init {
	my_bool                    maybe_null;           /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               decimals;             /*     4     4 */
	long unsigned int          max_length;           /*     8     8 */
	char *                     ptr;                  /*    16     8 */
	my_bool                    const_item;           /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	void *                     extension;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 30, holes: 2, sum holes: 10 */
	/* last cacheline: 40 bytes */
};
struct st_net_server {
	before_header_callback_fn  m_before_header;      /*     0     8 */
	after_header_callback_fn   m_after_header;       /*     8     8 */
	void *                     m_user_data;          /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct unicase_info_char_st {
	uint32                     toupper;              /*     0     4 */
	uint32                     tolower;              /*     4     4 */
	uint32                     sort;                 /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct unicase_info_st {
	ulong                      maxchar;              /*     0     8 */
	const MY_UNICASE_CHARACTER  * * page;            /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct my_contraction_t {
	ulong                      ch[6];                /*     0    48 */
	uint16                     weight[8];            /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	my_bool                    with_context;         /*    64     1 */

	/* size: 72, cachelines: 2, members: 3 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
struct my_contraction_list_t {
	size_t                     nitems;               /*     0     8 */
	MY_CONTRACTION *           item;                 /*     8     8 */
	char *                     flags;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct my_uca_level_info_st {
	ulong                      maxchar;              /*     0     8 */
	uchar *                    lengths;              /*     8     8 */
	uint16 * *                 weights;              /*    16     8 */
	MY_CONTRACTIONS            contractions;         /*    24    24 */

	/* size: 48, cachelines: 1, members: 4 */
	/* last cacheline: 48 bytes */
};
struct uca_info_st {
	MY_UCA_WEIGHT_LEVEL        level[1];             /*     0    48 */
	ulong                      first_non_ignorable;  /*    48     8 */
	ulong                      last_non_ignorable;   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulong                      first_primary_ignorable; /*    64     8 */
	ulong                      last_primary_ignorable; /*    72     8 */
	ulong                      first_secondary_ignorable; /*    80     8 */
	ulong                      last_secondary_ignorable; /*    88     8 */
	ulong                      first_tertiary_ignorable; /*    96     8 */
	ulong                      last_tertiary_ignorable; /*   104     8 */
	ulong                      first_trailing;       /*   112     8 */
	ulong                      last_trailing;        /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ulong                      first_variable;       /*   128     8 */
	ulong                      last_variable;        /*   136     8 */

	/* size: 144, cachelines: 3, members: 13 */
	/* last cacheline: 16 bytes */
};
struct uni_ctype_st {
	uchar                      pctype;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	uchar *                    ctype;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct my_uni_idx_st {
	uint16                     from;                 /*     0     2 */
	uint16                     to;                   /*     2     2 */

	/* XXX 4 bytes hole, try to pack */

	const uchar  *             tab;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct my_charset_loader_st {
	char                       error[128];           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void *                     (*once_alloc)(size_t); /*   128     8 */
	void *                     (*mem_malloc)(size_t); /*   136     8 */
	void *                     (*mem_realloc)(void *, size_t); /*   144     8 */
	void                       (*mem_free)(void *);  /*   152     8 */
	void                       (*reporter)(enum loglevel, const char  *, ...); /*   160     8 */
	int                        (*add_collation)(class charset_info_st *); /*   168     8 */

	/* size: 176, cachelines: 3, members: 7 */
	/* last cacheline: 48 bytes */
};
struct charset_info_st {
	uint                       number;               /*     0     4 */
	uint                       primary_number;       /*     4     4 */
	uint                       binary_number;        /*     8     4 */
	uint                       state;                /*    12     4 */
	const char  *              csname;               /*    16     8 */
	const char  *              name;                 /*    24     8 */
	const char  *              comment;              /*    32     8 */
	const char  *              tailoring;            /*    40     8 */
	const uchar  *             ctype;                /*    48     8 */
	const uchar  *             to_lower;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	const uchar  *             to_upper;             /*    64     8 */
	const uchar  *             sort_order;           /*    72     8 */
	MY_UCA_INFO *              uca;                  /*    80     8 */
	const uint16  *            tab_to_uni;           /*    88     8 */
	const MY_UNI_IDX  *        tab_from_uni;         /*    96     8 */
	const MY_UNICASE_INFO  *   caseinfo;             /*   104     8 */
	const class lex_state_maps_st  * state_maps;     /*   112     8 */
	const uchar  *             ident_map;            /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint                       strxfrm_multiply;     /*   128     4 */
	uchar                      caseup_multiply;      /*   132     1 */
	uchar                      casedn_multiply;      /*   133     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       mbminlen;             /*   136     4 */
	uint                       mbmaxlen;             /*   140     4 */
	uint                       mbmaxlenlen;          /*   144     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      min_sort_char;        /*   152     8 */
	ulong                      max_sort_char;        /*   160     8 */
	uchar                      pad_char;             /*   168     1 */
	my_bool                    escape_with_backslash_is_dangerous; /*   169     1 */
	uchar                      levels_for_compare;   /*   170     1 */
	uchar                      levels_for_order;     /*   171     1 */

	/* XXX 4 bytes hole, try to pack */

	MY_CHARSET_HANDLER *       cset;                 /*   176     8 */
	MY_COLLATION_HANDLER *     coll;                 /*   184     8 */

	/* size: 192, cachelines: 3, members: 32 */
	/* sum members: 182, holes: 3, sum holes: 10 */
};
struct my_collation_handler_st {
	my_bool                    (*init)(class charset_info_st *, MY_CHARSET_LOADER *); /*     0     8 */
	int                        (*strnncoll)(const class charset_info_st  *, const uchar  *, size_t, const uchar  *, size_t, my_bool); /*     8     8 */
	int                        (*strnncollsp)(const class charset_info_st  *, const uchar  *, size_t, const uchar  *, size_t, my_bool); /*    16     8 */
	size_t                     (*strnxfrm)(const class charset_info_st  *, uchar *, size_t, uint, const uchar  *, size_t, uint); /*    24     8 */
	size_t                     (*strnxfrmlen)(const class charset_info_st  *, size_t); /*    32     8 */
	my_bool                    (*like_range)(const class charset_info_st  *, const char  *, size_t, pchar, pchar, pchar, size_t, char *, char *, size_t *, size_t *); /*    40     8 */
	int                        (*wildcmp)(const class charset_info_st  *, const char  *, const char  *, const char  *, const char  *, int, int, int); /*    48     8 */
	int                        (*strcasecmp)(const class charset_info_st  *, const char  *, const char  *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint                       (*instr)(const class charset_info_st  *, const char  *, size_t, const char  *, size_t, my_match_t *, uint); /*    64     8 */
	void                       (*hash_sort)(const class charset_info_st  *, const uchar  *, size_t, ulong *, ulong *); /*    72     8 */
	my_bool                    (*propagate)(const class charset_info_st  *, const uchar  *, size_t); /*    80     8 */

	/* size: 88, cachelines: 2, members: 11 */
	/* last cacheline: 24 bytes */
};
struct my_charset_handler_st {
	my_bool                    (*init)(class charset_info_st *, MY_CHARSET_LOADER *); /*     0     8 */
	uint                       (*ismbchar)(const class charset_info_st  *, const char  *, const char  *); /*     8     8 */
	uint                       (*mbcharlen)(const class charset_info_st  *, uint); /*    16     8 */
	size_t                     (*numchars)(const class charset_info_st  *, const char  *, const char  *); /*    24     8 */
	size_t                     (*charpos)(const class charset_info_st  *, const char  *, const char  *, size_t); /*    32     8 */
	size_t                     (*well_formed_len)(const class charset_info_st  *, const char  *, const char  *, size_t, int *); /*    40     8 */
	size_t                     (*lengthsp)(const class charset_info_st  *, const char  *, size_t); /*    48     8 */
	size_t                     (*numcells)(const class charset_info_st  *, const char  *, const char  *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	my_charset_conv_mb_wc      mb_wc;                /*    64     8 */
	my_charset_conv_wc_mb      wc_mb;                /*    72     8 */
	int                        (*ctype)(const class charset_info_st  *, int *, const uchar  *, const uchar  *); /*    80     8 */
	size_t                     (*caseup_str)(const class charset_info_st  *, char *); /*    88     8 */
	size_t                     (*casedn_str)(const class charset_info_st  *, char *); /*    96     8 */
	my_charset_conv_case       caseup;               /*   104     8 */
	my_charset_conv_case       casedn;               /*   112     8 */
	size_t                     (*snprintf)(const class charset_info_st  *, char *, size_t, const char  *, ...); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	size_t                     (*long10_to_str)(const class charset_info_st  *, char *, size_t, int, long int); /*   128     8 */
	size_t                     (*longlong10_to_str)(const class charset_info_st  *, char *, size_t, int, longlong); /*   136     8 */
	void                       (*fill)(const class charset_info_st  *, char *, size_t, int); /*   144     8 */
	long int                   (*strntol)(const class charset_info_st  *, const char  *, size_t, int, char * *, int *); /*   152     8 */
	ulong                      (*strntoul)(const class charset_info_st  *, const char  *, size_t, int, char * *, int *); /*   160     8 */
	longlong                   (*strntoll)(const class charset_info_st  *, const char  *, size_t, int, char * *, int *); /*   168     8 */
	ulonglong                  (*strntoull)(const class charset_info_st  *, const char  *, size_t, int, char * *, int *); /*   176     8 */
	double                     (*strntod)(const class charset_info_st  *, char *, size_t, char * *, int *); /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	longlong                   (*strtoll10)(const class charset_info_st  *, const char  *, char * *, int *); /*   192     8 */
	ulonglong                  (*strntoull10rnd)(const class charset_info_st  *, const char  *, size_t, int, char * *, int *); /*   200     8 */
	size_t                     (*scan)(const class charset_info_st  *, const char  *, const char  *, int); /*   208     8 */

	/* size: 216, cachelines: 4, members: 27 */
	/* last cacheline: 24 bytes */
};
struct lex_state_maps_st {
	enum my_lex_states         main_map[256];        /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	enum hint_lex_char_classes hint_map[256];        /*   256   256 */

	/* size: 512, cachelines: 8, members: 2 */
};
struct st_my_thread_handle {
	my_thread_t                thread;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_memory_info_v1 {
	PSI_memory_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct MDL_key {
	enum enum_mdl_namespace {
		GLOBAL          = 0,
		TABLESPACE      = 1,
		SCHEMA          = 2,
		TABLE           = 3,
		FUNCTION        = 4,
		PROCEDURE       = 5,
		TRIGGER         = 6,
		EVENT           = 7,
		COMMIT          = 8,
		USER_LEVEL_LOCK = 9,
		LOCKING_SERVICE = 10,
		BACKUP          = 11,
		BINLOG          = 12,
		NAMESPACE_END   = 13,
	};

	void init_psi_keys(void);

	const uchar  * ptr(const class MDL_key  *);

	uint length(const class MDL_key  *);

	const char  * db_name(const class MDL_key  *);

	uint db_name_length(const class MDL_key  *);

	const char  * name(const class MDL_key  *);

	uint name_length(const class MDL_key  *);

	enum enum_mdl_namespace mdl_namespace(const class MDL_key  *);

	void mdl_key_init(class MDL_key *, enum enum_mdl_namespace, const char  *, const char  *);

	void mdl_key_init(class MDL_key *, const class MDL_key  *);

	void reset(class MDL_key *);

	bool is_equal(const class MDL_key  *, const class MDL_key  *);

	int cmp(const class MDL_key  *, const class MDL_key  *);

	void MDL_key(class MDL_key *, const class MDL_key  *);

	void MDL_key(class MDL_key *, enum enum_mdl_namespace, const char  *, const char  *);

	void MDL_key(class MDL_key *);

	const PSI_stage_info  * get_wait_state_name(const class MDL_key  *);

private:

	uint16                     m_length;             /*     0     2 */
	uint16                     m_db_name_length;     /*     2     2 */
	char                       m_ptr[387];           /*     4   387 */

	/* Bitfield combined with previous fields */

	static PSI_stage_info             m_namespace_to_wait_state_name[13]; /*     0     0 */
	void MDL_key(class MDL_key *, const class MDL_key  &);

	class MDL_key & operator=(class MDL_key *, const class MDL_key  &);


	/* size: 392, cachelines: 7, members: 3, static members: 1 */
	/* padding: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_stage_progress {
	ulonglong                  m_work_completed;     /*     0     8 */
	ulonglong                  m_work_estimated;     /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PSI_table_locker_state {
	uint                       m_flags;              /*     0     4 */
	enum PSI_table_io_operation m_io_operation;      /*     4     4 */
	class PSI_table *          m_table;              /*     8     8 */
	class PSI_table_share *    m_table_share;        /*    16     8 */
	class PSI_thread *         m_thread;             /*    24     8 */
	ulonglong                  m_timer_start;        /*    32     8 */
	ulonglong                  (*m_timer)(void);     /*    40     8 */
	void *                     m_wait;               /*    48     8 */
	uint                       m_index;              /*    56     4 */

	/* size: 64, cachelines: 1, members: 9 */
	/* padding: 4 */
};
struct PSI_bootstrap {
	void *                     (*get_interface)(int); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PSI_mutex_info_v1 {
	PSI_mutex_key *            m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_rwlock_info_v1 {
	PSI_rwlock_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_cond_info_v1 {
	PSI_cond_key *             m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_thread_info_v1 {
	PSI_thread_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_file_info_v1 {
	PSI_file_key *             m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_stage_info_v1 {
	PSI_stage_key              m_key;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 16, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_statement_info_v1 {
	PSI_statement_key          m_key;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 16, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_socket_info_v1 {
	PSI_socket_key *           m_key;                /*     0     8 */
	const char  *              m_name;               /*     8     8 */
	int                        m_flags;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PSI_idle_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_thread *         m_thread;             /*     8     8 */
	ulonglong                  m_timer_start;        /*    16     8 */
	ulonglong                  (*m_timer)(void);     /*    24     8 */
	void *                     m_wait;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct PSI_mutex_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */
	enum PSI_mutex_operation   m_operation;          /*     4     4 */
	class PSI_mutex *          m_mutex;              /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	ulonglong                  m_timer_start;        /*    24     8 */
	ulonglong                  (*m_timer)(void);     /*    32     8 */
	void *                     m_wait;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct PSI_rwlock_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */
	enum PSI_rwlock_operation  m_operation;          /*     4     4 */
	class PSI_rwlock *         m_rwlock;             /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	ulonglong                  m_timer_start;        /*    24     8 */
	ulonglong                  (*m_timer)(void);     /*    32     8 */
	void *                     m_wait;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct PSI_cond_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */
	enum PSI_cond_operation    m_operation;          /*     4     4 */
	class PSI_cond *           m_cond;               /*     8     8 */
	class PSI_mutex *          m_mutex;              /*    16     8 */
	class PSI_thread *         m_thread;             /*    24     8 */
	ulonglong                  m_timer_start;        /*    32     8 */
	ulonglong                  (*m_timer)(void);     /*    40     8 */
	void *                     m_wait;               /*    48     8 */

	/* size: 56, cachelines: 1, members: 8 */
	/* last cacheline: 56 bytes */
};
struct PSI_file_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */
	enum PSI_file_operation    m_operation;          /*     4     4 */
	class PSI_file *           m_file;               /*     8     8 */
	const char  *              m_name;               /*    16     8 */
	void *                     m_class;              /*    24     8 */
	class PSI_thread *         m_thread;             /*    32     8 */
	size_t                     m_number_of_bytes;    /*    40     8 */
	ulonglong                  m_timer_start;        /*    48     8 */
	ulonglong                  (*m_timer)(void);     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void *                     m_wait;               /*    64     8 */

	/* size: 72, cachelines: 2, members: 10 */
	/* last cacheline: 8 bytes */
};
struct PSI_metadata_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_metadata_lock *  m_metadata_lock;      /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	ulonglong                  m_timer_start;        /*    24     8 */
	ulonglong                  (*m_timer)(void);     /*    32     8 */
	void *                     m_wait;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct PSI_statement_locker_state_v1 {
	my_bool                    m_discarded;          /*     0     1 */
	my_bool                    m_in_prepare;         /*     1     1 */
	uchar                      m_no_index_used;      /*     2     1 */
	uchar                      m_no_good_index_used; /*     3     1 */
	uint                       m_flags;              /*     4     4 */
	void *                     m_class;              /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	ulonglong                  m_timer_start;        /*    24     8 */
	ulonglong                  (*m_timer)(void);     /*    32     8 */
	void *                     m_statement;          /*    40     8 */
	ulonglong                  m_lock_time;          /*    48     8 */
	ulonglong                  m_rows_sent;          /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  m_rows_examined;      /*    64     8 */
	ulong                      m_created_tmp_disk_tables; /*    72     8 */
	ulong                      m_created_tmp_tables; /*    80     8 */
	ulong                      m_select_full_join;   /*    88     8 */
	ulong                      m_select_full_range_join; /*    96     8 */
	ulong                      m_select_range;       /*   104     8 */
	ulong                      m_select_range_check; /*   112     8 */
	ulong                      m_select_scan;        /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ulong                      m_sort_merge_passes;  /*   128     8 */
	ulong                      m_sort_range;         /*   136     8 */
	ulong                      m_sort_rows;          /*   144     8 */
	ulong                      m_sort_scan;          /*   152     8 */
	const class sql_digest_storage  * m_digest;      /*   160     8 */
	char                       m_schema_name[192];   /*   168   192 */
	/* --- cacheline 5 boundary (320 bytes) was 40 bytes ago --- */
	uint                       m_schema_name_length; /*   360     4 */
	uint                       m_cs_number;          /*   364     4 */
	PSI_sp_share *             m_parent_sp_share;    /*   368     8 */
	PSI_prepared_stmt *        m_parent_prepared_stmt; /*   376     8 */

	/* size: 384, cachelines: 6, members: 30 */
};
struct sql_digest_storage {
	bool                       m_full;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	size_t                     m_byte_count;         /*     8     8 */
	unsigned char              m_md5[16];            /*    16    16 */
	uint                       m_charset_number;     /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	unsigned char *            m_token_array;        /*    40     8 */
	size_t                     m_token_array_length; /*    48     8 */
	void sql_digest_storage(class sql_digest_storage *);

	void reset(class sql_digest_storage *, unsigned char *, size_t);

	void reset(class sql_digest_storage *);

	bool is_empty(class sql_digest_storage *);

	void copy(class sql_digest_storage *, const class sql_digest_storage  *);


	/* size: 56, cachelines: 1, members: 6 */
	/* sum members: 45, holes: 2, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct PSI_transaction_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     m_class;              /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	ulonglong                  m_timer_start;        /*    24     8 */
	ulonglong                  (*m_timer)(void);     /*    32     8 */
	void *                     m_transaction;        /*    40     8 */
	my_bool                    m_read_only;          /*    48     1 */
	my_bool                    m_autocommit;         /*    49     1 */

	/* XXX 6 bytes hole, try to pack */

	ulong                      m_statement_count;    /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulong                      m_savepoint_count;    /*    64     8 */
	ulong                      m_rollback_to_savepoint_count; /*    72     8 */
	ulong                      m_release_savepoint_count; /*    80     8 */

	/* size: 88, cachelines: 2, members: 12 */
	/* sum members: 78, holes: 2, sum holes: 10 */
	/* last cacheline: 24 bytes */
};
struct PSI_socket_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_socket *         m_socket;             /*     8     8 */
	class PSI_thread *         m_thread;             /*    16     8 */
	size_t                     m_number_of_bytes;    /*    24     8 */
	ulonglong                  m_timer_start;        /*    32     8 */
	ulonglong                  (*m_timer)(void);     /*    40     8 */
	enum PSI_socket_operation  m_operation;          /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_src_file;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        m_src_line;           /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     m_wait;               /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* sum members: 68, holes: 3, sum holes: 12 */
	/* last cacheline: 16 bytes */
};
struct PSI_sp_locker_state_v1 {
	uint                       m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_thread *         m_thread;             /*     8     8 */
	ulonglong                  m_timer_start;        /*    16     8 */
	ulonglong                  (*m_timer)(void);     /*    24     8 */
	PSI_sp_share *             m_sp_share;           /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct TABLE_SHARE {
	void TABLE_SHARE(class TABLE_SHARE *);

	TABLE_CATEGORY             table_category;       /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	HASH                       name_hash;            /*     8   112 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	MEM_ROOT                   mem_root;             /*   120    88 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	TYPELIB                    keynames;             /*   208    32 */
	TYPELIB                    fieldnames;           /*   240    32 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	TYPELIB *                  intervals;            /*   272     8 */
	mysql_mutex_t              LOCK_ha_data;         /*   280    48 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	class TABLE_SHARE *        next;                 /*   328     8 */
	class TABLE_SHARE * *      prev;                 /*   336     8 */
	class Table_cache_element * * cache_element;     /*   344     8 */
	class Field * *            field;                /*   352     8 */
	class Field * *            found_next_number_field; /*   360     8 */
	KEY *                      key_info;             /*   368     8 */
	uint *                     blob_field;           /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uchar *                    default_values;       /*   384     8 */
	LEX_STRING                 comment;              /*   392    16 */
	LEX_STRING                 compress;             /*   408    16 */
	LEX_STRING                 encrypt_type;         /*   424    16 */
	uint32_t                   encryption_key_id;    /*   440     4 */
	bool                       was_encryption_key_id_set; /*   444     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 7 boundary (448 bytes) --- */
	const CHARSET_INFO  *      table_charset;        /*   448     8 */
	MY_BITMAP                  all_set;              /*   456    32 */
	LEX_STRING                 table_cache_key;      /*   488    16 */
	LEX_STRING                 db;                   /*   504    16 */
	/* --- cacheline 8 boundary (512 bytes) was 8 bytes ago --- */
	LEX_STRING                 table_name;           /*   520    16 */
	LEX_STRING                 path;                 /*   536    16 */
	LEX_STRING                 normalized_path;      /*   552    16 */
	LEX_STRING                 connect_string;       /*   568    16 */
	/* --- cacheline 9 boundary (576 bytes) was 8 bytes ago --- */
	key_map                    keys_in_use;          /*   584     8 */
	key_map                    keys_for_keyread;     /*   592     8 */
	ha_rows                    min_rows;             /*   600     8 */
	ha_rows                    max_rows;             /*   608     8 */
	ulong                      avg_row_length;       /*   616     8 */
	ulong                      version;              /*   624     8 */
	ulong                      mysql_version;        /*   632     8 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	ulong                      reclength;            /*   640     8 */
	ulong                      stored_rec_length;    /*   648     8 */
	plugin_ref                 db_plugin;            /*   656     8 */
	class handlerton * db_type(const class TABLE_SHARE  *);

	enum row_type              row_type;             /*   664     4 */
	enum tmp_table_type        tmp_table;            /*   668     4 */
	uint                       ref_count;            /*   672     4 */
	uint                       key_block_size;       /*   676     4 */
	uint                       stats_sample_pages;   /*   680     4 */
	enum enum_stats_auto_recalc stats_auto_recalc;   /*   684     4 */
	uint                       null_bytes;           /*   688     4 */
	uint                       last_null_bit_pos;    /*   692     4 */
	uint                       fields;               /*   696     4 */
	uint                       stored_fields;        /*   700     4 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	uint                       rec_buff_length;      /*   704     4 */
	uint                       keys;                 /*   708     4 */
	uint                       key_parts;            /*   712     4 */
	uint                       max_key_length;       /*   716     4 */
	uint                       max_unique_length;    /*   720     4 */
	uint                       total_key_length;     /*   724     4 */
	uint                       uniques;              /*   728     4 */
	uint                       null_fields;          /*   732     4 */
	uint                       blob_fields;          /*   736     4 */
	uint                       varchar_fields;       /*   740     4 */
	uint                       db_create_options;    /*   744     4 */
	uint                       db_options_in_use;    /*   748     4 */
	uint                       db_record_offset;     /*   752     4 */
	uint                       rowid_field_offset;   /*   756     4 */
	uint                       primary_key;          /*   760     4 */
	uint                       next_number_index;    /*   764     4 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	uint                       next_number_key_offset; /*   768     4 */
	uint                       next_number_keypart;  /*   772     4 */
	uint                       error;                /*   776     4 */
	uint                       open_errno;           /*   780     4 */
	uint                       errarg;               /*   784     4 */
	uint                       column_bitmap_size;   /*   788     4 */
	uchar                      frm_version;          /*   792     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       vfields;              /*   796     4 */
	bool                       null_field_first;     /*   800     1 */
	bool                       system;               /*   801     1 */
	bool                       crypted;              /*   802     1 */
	bool                       db_low_byte_first;    /*   803     1 */
	bool                       crashed;              /*   804     1 */
	bool                       is_view;              /*   805     1 */
	bool                       m_open_in_progress;   /*   806     1 */

	/* XXX 1 byte hole, try to pack */

	class Table_id            table_map_id;          /*   808     8 */
	int                        cached_row_logging_check; /*   816     4 */
	enum ha_storage_media      default_storage_media; /*   820     4 */
	char *                     tablespace;           /*   824     8 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	bool                       auto_partitioned;     /*   832     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     partition_info_str;   /*   840     8 */
	uint                       partition_info_str_len; /*   848     4 */
	uint                       partition_info_buffer_size; /*   852     4 */
	class handlerton *         default_part_db_type; /*   856     8 */
	const TABLE_FIELD_DEF  *   table_field_def_cache; /*   864     8 */
	class Handler_share *      ha_share;             /*   872     8 */
	PSI_table_share *          m_psi;                /*   880     8 */
	Wait_for_flush_list        m_flush_tickets;      /*   888     8 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	const class File_parser  * view_def;             /*   896     8 */
	bool                       rfr_lookup_warning;   /*   904     1 */
	void set_table_cache_key(class TABLE_SHARE *, char *, size_t);

	void set_table_cache_key(class TABLE_SHARE *, char *, const char  *, size_t);

	bool honor_global_locks(class TABLE_SHARE *);

	ulonglong get_table_def_version(class TABLE_SHARE *);

	bool has_old_version(const class TABLE_SHARE  *);

	enum enum_table_ref_type get_table_ref_type(const class TABLE_SHARE  *);

	ulonglong get_table_ref_version(const class TABLE_SHARE  *);

	bool visit_subgraph(class TABLE_SHARE *, class Wait_for_flush *, class MDL_wait_for_graph_visitor *);

	bool wait_for_old_version(class TABLE_SHARE *, class THD *, class timespec *, uint);

	void destroy(class TABLE_SHARE *);

	bool has_compressed_columns(const class TABLE_SHARE  *);


	/* size: 912, cachelines: 15, members: 94 */
	/* sum members: 887, holes: 5, sum holes: 18 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
class THD : public MDL_context_owner, public Query_arena, public Open_tables_state {
	class Query_plan {
		const class THD *          thd;                  /*     0     8 */
		enum enum_sql_command      sql_command;          /*     8     4 */

		/* XXX 4 bytes hole, try to pack */

		class LEX *                lex;                  /*    16     8 */
		const class Modification_plan  * modification_plan; /*    24     8 */
		bool                       is_ps;                /*    32     1 */
		void Query_plan(class Query_plan *, const class Query_plan  &);

		class Query_plan & operator=(class Query_plan *, const class Query_plan  &);

	public:

		void assert_plan_is_locked_if_other(const class Query_plan  *);

		void Query_plan(class Query_plan *, class THD *);

		void set_query_plan(class Query_plan *, enum enum_sql_command, class LEX *, bool);

		enum enum_sql_command get_command(const class Query_plan  *);

		class LEX * get_lex(const class Query_plan  *);

		const class Modification_plan  * get_modification_plan(const class Query_plan  *);

		bool is_ps_query(const class Query_plan  *);

		void set_modification_plan(class Query_plan *, class Modification_plan *);


		/* size: 40, cachelines: 1, members: 5 */
		/* sum members: 29, holes: 1, sum holes: 4 */
		/* padding: 7 */
		/* last cacheline: 40 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	enum binlog_filter_state {
		BINLOG_FILTER_UNKNOWN = 0,
		BINLOG_FILTER_CLEAR   = 1,
		BINLOG_FILTER_SET     = 2,
	};

	struct Transaction_state {
		void backup(class Transaction_state *, class THD *);

		void restore(class Transaction_state *, class THD *);

		enum enum_sql_command      m_sql_command;        /*     0     4 */

		/* XXX 4 bytes hole, try to pack */

		class Query_tables_list   m_query_tables_list;   /*     8   200 */

		/* XXX last struct has 3 bytes of padding */

		/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
		class Open_tables_backup  m_open_tables_state __attribute__((__aligned__(8))); /*   208   128 */
		/* --- cacheline 5 boundary (320 bytes) was 16 bytes ago --- */
		sql_mode_t                 m_sql_mode;           /*   336     8 */
		enum enum_tx_isolation     m_tx_isolation;       /*   344     4 */

		/* XXX 4 bytes hole, try to pack */

		struct Ha_data             m_ha_data[15];        /*   352  1080 */
		/* --- cacheline 22 boundary (1408 bytes) was 24 bytes ago --- */
		class Transaction_ctx *    m_trx;                /*  1432     8 */
		my_bool                    m_tx_read_only;       /*  1440     1 */

		/* XXX 7 bytes hole, try to pack */

		ulonglong                  m_thd_option_bits;    /*  1448     8 */
		PSI_transaction_locker *   m_transaction_psi;    /*  1456     8 */
		uint                       m_server_status;      /*  1464     4 */
		void ~Transaction_state(class Transaction_state *, int);

		void Transaction_state(class Transaction_state *);


		/* size: 1472, cachelines: 23, members: 11 */
		/* sum members: 1453, holes: 3, sum holes: 15 */
		/* padding: 4 */
		/* paddings: 1, sum paddings: 3 */
		/* forced alignments: 1 */
	} __attribute__((__aligned__(8)));

	enum Commit_error {
		CE_NONE                      = 0,
		CE_FLUSH_ERROR               = 1,
		CE_FLUSH_GNO_EXHAUSTED_ERROR = 2,
		CE_SYNC_ERROR                = 3,
		CE_COMMIT_ERROR              = 4,
		CE_ERROR_COUNT               = 5,
	};

	enum killed_state {
		NOT_KILLED      = 0,
		KILL_BAD_DATA   = 1,
		KILL_CONNECTION = 1053,
		KILL_QUERY      = 1317,
		KILL_TIMEOUT    = 3024,
		KILLED_NO_VALUE = 3025,
	};

	/* tag__fprintf: volatile_type tag not supported! */;

	union {
		my_bool                    my_bool_value;        /*     0     1 */
		long int                   long_value;           /*     0     8 */
		ulong                      ulong_value;          /*     0     8 */
		ulonglong                  ulonglong_value;      /*     0     8 */
		double                     double_value;         /*     0     8 */
	};

	struct {
		bool                       do_union;             /*     0     1 */
		bool                       unioned_events;       /*     1     1 */
		bool                       unioned_events_trans; /*     2     1 */

		/* XXX 5 bytes hole, try to pack */

		query_id_t                 first_query_id;       /*     8     8 */

		/* size: 16, cachelines: 1, members: 4 */
		/* sum members: 11, holes: 1, sum holes: 5 */
		/* last cacheline: 16 bytes */
	};

	enum enum_binlog_query_type {
		ROW_QUERY_TYPE   = 0,
		STMT_QUERY_TYPE  = 1,
		QUERY_TYPE_COUNT = 2,
	};

public:

	/* class MDL_context_owner   <ancestor>; */      /*     0     8 */
	/* class Query_arena         <ancestor>; */      /*     8    32 */

	/* XXX last struct has 4 bytes of padding */

	/* class Open_tables_state   <ancestor>; */      /*    40   112 */
	void THD(class THD *, class THD &);

	bool is_stmt_prepare(const class THD  *);

	bool is_stmt_prepare_or_first_sp_execute(const class THD  *);

	bool is_stmt_prepare_or_first_stmt_execute(const class THD  *);

	bool is_conventional(const class THD  *);

	class MDL_context         mdl_context;           /*   152   288 */

	/* XXX last struct has 4 bytes of padding */

	enum enum_mark_columns     mark_used_columns;    /*   440     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      want_privilege;       /*   448     8 */
	class LEX *                lex;                  /*   456     8 */
	bool                       gtid_executed_warning_issued; /*   464     1 */

	/* XXX 7 bytes hole, try to pack */

	LEX_CSTRING                m_query_string;       /*   472    16 */
	class String              m_normalized_query;    /*   488    32 */

	/* XXX last struct has 3 bytes of padding */

	volatile int32             m_safe_to_display;    /*   520     4 */

	/* XXX 4 bytes hole, try to pack */

	LEX_CSTRING                m_catalog;            /*   528    16 */
	LEX_CSTRING                m_db;                 /*   544    16 */
	class String              m_rewritten_query;     /*   560    32 */

	/* XXX last struct has 3 bytes of padding */

	class Relay_log_info *     rli_fake;             /*   592     8 */
	class Relay_log_info *     rli_slave;            /*   600     8 */
	bool is_binlog_applier(class THD *);

	void rpl_detach_engine_ha_data(class THD *);

	void rpl_reattach_engine_ha_data(class THD *);

	bool rpl_unflag_detached_engine_ha_data(class THD *);

	void reset_for_next_command(class THD *);


	/* Bitfield combined with previous fields */

	static const const char  *        DEFAULT_WHERE; /*     0     0 */
	struct Query_cache_tls     query_cache_tls;      /*   608     8 */
	NET_SERVER                 m_net_server_extension; /*   616    24 */
	class THD_event_functions * scheduler;           /*   640     8 */
	HASH                       user_vars;            /*   648   112 */
	class String              convert_buffer;        /*   760    32 */

	/* XXX last struct has 3 bytes of padding */

	struct rand_struct         rand;                 /*   792    32 */
	struct rand_struct         slog_rand;            /*   824    32 */
	struct system_variables    variables;            /*   856   904 */

	/* XXX last struct has 5 bytes of padding */

	/* --- cacheline 27 boundary (1728 bytes) was 32 bytes ago --- */
	struct system_status_var   status_var;           /*  1760  1648 */
	/* --- cacheline 53 boundary (3392 bytes) was 16 bytes ago --- */
	class system_status_var *  initial_status_var;   /*  3408     8 */
	bool                       status_var_aggregated; /*  3416     1 */

	/* XXX 7 bytes hole, try to pack */

	double                     m_current_query_cost; /*  3424     8 */
	ulonglong                  m_current_query_partial_plans; /*  3432     8 */
	void clear_current_query_costs(class THD *);

	void save_current_query_costs(class THD *);

	THR_LOCK_INFO              lock_info;            /*  3440    16 */
	/* --- cacheline 54 boundary (3456 bytes) --- */
	mysql_mutex_t              LOCK_thd_data;        /*  3456    48 */
	mysql_mutex_t              LOCK_thd_query;       /*  3504    48 */
	/* --- cacheline 55 boundary (3520 bytes) was 32 bytes ago --- */
	mysql_mutex_t              LOCK_temporary_tables; /*  3552    48 */
	/* --- cacheline 56 boundary (3584 bytes) was 16 bytes ago --- */
	mysql_mutex_t              LOCK_thd_sysvar;      /*  3600    48 */
	/* --- cacheline 57 boundary (3648 bytes) --- */
	mysql_mutex_t              LOCK_query_plan;      /*  3648    48 */
	void lock_query_plan(class THD *);

	void unlock_query_plan(class THD *);

	class Prepared_statement_map stmt_map;           /*  3696   232 */
	/* --- cacheline 61 boundary (3904 bytes) was 24 bytes ago --- */
	const char  *              thread_stack;         /*  3928     8 */
	class Security_context    m_main_security_ctx;   /*  3936   536 */

	/* XXX last struct has 7 bytes of padding */

	/* --- cacheline 69 boundary (4416 bytes) was 56 bytes ago --- */
	class Security_context *   m_security_ctx;       /*  4472     8 */
	class Security_context * security_context(const class THD  *);

	void set_security_context(class THD *, class Security_context *);

	/* --- cacheline 70 boundary (4480 bytes) --- */
	const char  *              proc_info;            /*  4480     8 */
	class Protocol_text       protocol_text;         /*  4488     0 */

	/* XXX 88 bytes hole, try to pack */

	/* --- cacheline 71 boundary (4544 bytes) was 32 bytes ago --- */
	class Protocol_binary     protocol_binary;       /*  4576     0 */

	/* XXX 88 bytes hole, try to pack */
	class Protocol * get_protocol(class THD *);

	SSL * get_ssl(const class THD  *);

	class Protocol_classic * get_protocol_classic(const class THD  *);

	void set_protocol(class THD *, class Protocol *);


	/* --- cacheline 72 boundary (4608 bytes) was 56 bytes ago --- */
	class Protocol *           m_protocol;           /*  4664     8 */
	/* --- cacheline 73 boundary (4672 bytes) --- */
	SSL *                      m_SSL;                /*  4672     8 */
	class Query_plan          query_plan;            /*  4680    40 */

	/* XXX last struct has 7 bytes of padding */
	const LEX_CSTRING  & catalog(const class THD  *);

	void set_catalog(class THD *, const LEX_CSTRING  &);


	unsigned int               m_current_stage_key;  /*  4720     4 */

	/* XXX 4 bytes hole, try to pack */
	void enter_stage(class THD *, const PSI_stage_info  *, PSI_stage_info *, const char  *, const char  *, unsigned int);

	const char  * get_proc_info(const class THD  *);


	const char  *              where;                /*  4728     8 */
	/* --- cacheline 74 boundary (4736 bytes) --- */
	ulong                      max_client_packet_length; /*  4736     8 */
	HASH                       handler_tables_hash;  /*  4744   112 */
	/* --- cacheline 75 boundary (4800 bytes) was 56 bytes ago --- */
	HASH                       ull_hash;             /*  4856   112 */
	/* --- cacheline 77 boundary (4928 bytes) was 40 bytes ago --- */
	bool                       is_killable;          /*  4968     1 */

	/* XXX 7 bytes hole, try to pack */

	mysql_mutex_t              LOCK_current_cond;    /*  4976    48 */
	/* --- cacheline 78 boundary (4992 bytes) was 32 bytes ago --- */
	volatile mysql_mutex_t *   current_mutex;        /*  5024     8 */
	volatile mysql_cond_t *    current_cond;         /*  5032     8 */
	mysql_cond_t               COND_thr_lock;        /*  5040    56 */
	/* --- cacheline 79 boundary (5056 bytes) was 40 bytes ago --- */
	enum enum_server_command   m_command;            /*  5096     4 */
	uint32                     unmasked_server_id;   /*  5100     4 */
	uint32                     server_id;            /*  5104     4 */
	uint32                     file_id;              /*  5108     4 */
	uint16                     peer_port;            /*  5112     2 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 80 boundary (5120 bytes) --- */
	struct timeval             start_time;           /*  5120    16 */
	struct timeval             user_time;            /*  5136    16 */
	ulonglong                  thr_create_utime;     /*  5152     8 */
	ulonglong                  start_utime;          /*  5160     8 */
	ulonglong                  utime_after_lock;     /*  5168     8 */
	ulonglong                  utime_after_query;    /*  5176     8 */
	/* --- cacheline 81 boundary (5184 bytes) --- */
	enum thr_lock_type         update_lock_default;  /*  5184     4 */
	enum thr_lock_type         insert_lock_default;  /*  5188     4 */
	ulonglong                  bytes_sent_old;       /*  5192     8 */
	ulong                      tmp_tables_used;      /*  5200     8 */
	ulong                      tmp_tables_disk_used; /*  5208     8 */
	ulonglong                  tmp_tables_size;      /*  5216     8 */
	ulonglong                  innodb_trx_id;        /*  5224     8 */
	ulong                      innodb_io_reads;      /*  5232     8 */
	ulonglong                  innodb_io_read;       /*  5240     8 */
	/* --- cacheline 82 boundary (5248 bytes) --- */
	uint64_t                   innodb_io_reads_wait_timer; /*  5248     8 */
	uint64_t                   innodb_lock_que_wait_timer; /*  5256     8 */
	uint64_t                   innodb_innodb_que_wait_timer; /*  5264     8 */
	bool                       innodb_was_used;      /*  5272     1 */

	/* XXX 7 bytes hole, try to pack */

	class Bloom_filter        approx_distinct_pages; /*  5280    56 */
	/* --- cacheline 83 boundary (5312 bytes) was 24 bytes ago --- */
	ulong                      innodb_page_access;   /*  5336     8 */
	void mark_innodb_used(class THD *, ulonglong);

	void access_distinct_page(class THD *, ulong);

	bool innodb_slow_log_enabled(const class THD  *);

	bool innodb_slow_log_data_logged(const class THD  *);

	ulong                      query_plan_flags;     /*  5344     8 */
	ulong                      query_plan_fsort_passes; /*  5352     8 */
	uint                       last_errno;           /*  5360     4 */
	void set_slow_log_for_admin_command(class THD *);

	void clear_slow_extended(class THD *);

	void reset_sub_statement_state_slow_extended(class THD *, class Sub_statement_state *);

	void restore_sub_statement_state_slow_extended(class THD *, const class Sub_statement_state  *);

	uint                       in_sub_stmt;          /*  5364     4 */
	bool                       skip_wait_timeout;    /*  5368     1 */

	/* XXX 3 bytes hole, try to pack */
	ulong get_wait_timeout(const class THD  *);


	uint                       fill_status_recursion_level; /*  5372     4 */
	/* --- cacheline 84 boundary (5376 bytes) --- */
	uint                       fill_variables_recursion_level; /*  5376     4 */

	/* XXX 4 bytes hole, try to pack */

	struct Ha_data             ha_data[15];          /*  5384  1080 */
	/* --- cacheline 101 boundary (6464 bytes) --- */
	bool                       order_deterministic;  /*  6464     1 */

	/* XXX 7 bytes hole, try to pack */

	struct rpl_event_coordinates binlog_next_event_pos; /*  6472    16 */
	void set_next_event_pos(class THD *, const char  *, ulonglong);

	void clear_next_event_pos(class THD *);

	uchar *                    binlog_row_event_extra_data; /*  6488     8 */
	bool binlog_row_event_extra_data_eq(const uchar  *, const uchar  *);

	int binlog_setup_trx_data(class THD *);

	int binlog_write_table_map(class THD *, class TABLE *, bool, bool);

	int binlog_write_row(class THD *, class TABLE *, bool, const uchar  *, const uchar  *);

	int binlog_delete_row(class THD *, class TABLE *, bool, const uchar  *, const uchar  *);

	int binlog_update_row(class THD *, class TABLE *, bool, const uchar  *, const uchar  *, const uchar  *);

	void binlog_prepare_row_images(class THD *, class TABLE *);

	void set_server_id(class THD *, uint32);

	class Rows_log_event * binlog_get_pending_rows_event(const class THD  *, bool);

	int binlog_flush_pending_rows_event(class THD *, bool);

	int binlog_flush_pending_rows_event(class THD *, bool, bool);

	int is_current_stmt_binlog_format_row(const class THD  *);

	bool is_current_stmt_binlog_disabled(const class THD  *);

	bool is_current_stmt_binlog_row_enabled_with_write_set_extraction(const class THD  *);

	bool optimizer_switch_flag(const class THD  *, ulonglong);

	void reset_binlog_local_stmt_filter(class THD *);

	void clear_binlog_local_stmt_filter(class THD *);

	void set_binlog_local_stmt_filter(class THD *);

	enum binlog_filter_state get_binlog_local_stmt_filter(class THD *);

	class st_thd_timer_info *  timer;                /*  6496     8 */
	class st_thd_timer_info *  timer_cache;          /*  6504     8 */
	bool                       skip_readonly_check;  /*  6512     1 */

	/* XXX 3 bytes hole, try to pack */

	enum binlog_filter_state   m_binlog_filter_state; /*  6516     4 */
	enum enum_binlog_format    current_stmt_binlog_format; /*  6520     4 */
	uint32                     binlog_unsafe_warning_flags; /*  6524     4 */
	/* --- cacheline 102 boundary (6528 bytes) --- */
	uint                       binlog_table_maps;    /*  6528     4 */

	/* XXX 4 bytes hole, try to pack */

	class List<char> *         binlog_accessed_db_names; /*  6536     8 */
	const char  *              m_trans_log_file;     /*  6544     8 */
	char *                     m_trans_fixed_log_file; /*  6552     8 */
	my_off_t                   m_trans_end_pos;      /*  6560     8 */
	NET                        net;                  /*  6568   680 */
	/* --- cacheline 113 boundary (7232 bytes) was 16 bytes ago --- */
	class String              packet;                /*  7248    32 */

	/* XXX last struct has 3 bytes of padding */
	void set_skip_readonly_check(class THD *);

	bool is_cmd_skip_readonly(class THD *);

	void reset_skip_readonly_check(class THD *);

	void issue_unsafe_warnings(class THD *);

	uint get_binlog_table_maps(const class THD  *);

	void clear_binlog_table_maps(class THD *);

	class List<char> * get_binlog_accessed_db_names(class THD *);

	void clear_binlog_accessed_db_names(class THD *);

	void add_to_binlog_accessed_dbs(class THD *, const char  *);


	class auto_ptr<Transaction_ctx> m_transaction;   /*  7280     8 */
	class Attachable_trx {
	public:

		int ()(void) * *           _vptr.Attachable_trx; /*     0     8 */
		void Attachable_trx(class Attachable_trx *, class THD *);

		virtual void ~Attachable_trx(class Attachable_trx *, int);

		virtual bool is_read_only(const class Attachable_trx  *);

	protected:

		class THD *                m_thd;                /*     8     8 */
		struct Transaction_state   m_trx_state __attribute__((__aligned__(8))); /*    16  1472 */

		/* XXX last struct has 4 bytes of padding */
		void Attachable_trx(class Attachable_trx *, const class Attachable_trx  &);

		class Attachable_trx & operator=(class Attachable_trx *, const class Attachable_trx  &);

		/* vtable has 1 entries: {
		   [2] = is_read_only((null)), 
		} */
		/* size: 1488, cachelines: 24, members: 3 */
		/* paddings: 1, sum paddings: 4 */
		/* forced alignments: 1 */
		/* last cacheline: 16 bytes */
	} __attribute__((__aligned__(8)));

	/* tag__fprintf: const_type tag not supported! */;

	class Attachable_trx *     m_attachable_trx;     /*  7288     8 */
	class Transaction_ctx * get_transaction(class THD *);

	const class Transaction_ctx  * get_transaction(const class THD  *);

	void set_transaction(class THD *, class Transaction_ctx *);

	/* --- cacheline 114 boundary (7296 bytes) --- */
	class Global_read_lock    global_read_lock;      /*  7296    24 */
	class Global_backup_lock  backup_tables_lock;    /*  7320    24 */
	class Global_backup_lock  backup_binlog_lock;    /*  7344    24 */
	/* --- cacheline 115 boundary (7360 bytes) was 8 bytes ago --- */
	class Field *              dup_field;            /*  7368     8 */
	Vio *                      active_vio;           /*  7376     8 */
	Item_change_list           change_list;          /*  7384    32 */
	class Query_arena *        stmt_arena;           /*  7416     8 */
	/* --- cacheline 116 boundary (7424 bytes) --- */
	table_map                  table_map_for_update; /*  7424     8 */
	bool                       arg_of_last_insert_id_function; /*  7432     1 */

	/* XXX 7 bytes hole, try to pack */

	ulonglong                  first_successful_insert_id_in_prev_stmt; /*  7440     8 */
	ulonglong                  first_successful_insert_id_in_prev_stmt_for_binlog; /*  7448     8 */
	ulonglong                  first_successful_insert_id_in_cur_stmt; /*  7456     8 */
	bool                       stmt_depends_on_first_successful_insert_id_in_prev_stmt; /*  7464     1 */

	/* XXX 7 bytes hole, try to pack */

	class Discrete_intervals_list auto_inc_intervals_in_cur_stmt_for_binlog; /*  7472    64 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 117 boundary (7488 bytes) was 48 bytes ago --- */
	class Discrete_intervals_list auto_inc_intervals_forced; /*  7536    64 */

	/* XXX last struct has 4 bytes of padding */
	void record_first_successful_insert_id_in_cur_stmt(class THD *, ulonglong);

	ulonglong read_first_successful_insert_id_in_prev_stmt(class THD *);

	void reset_first_successful_insert_id(class THD *);

	void force_one_auto_inc_interval(class THD *, ulonglong);


	/* --- cacheline 118 boundary (7552 bytes) was 48 bytes ago --- */
	ulonglong                  previous_found_rows;  /*  7600     8 */
	ulonglong                  current_found_rows;   /*  7608     8 */
	/* --- cacheline 119 boundary (7616 bytes) --- */
	bool                       is_operating_gtid_table_implicitly; /*  7616     1 */
	bool                       is_operating_substatement_implicitly; /*  7617     1 */

	/* XXX 6 bytes hole, try to pack */

	longlong                   m_row_count_func;     /*  7624     8 */
	longlong get_row_count_func(const class THD  *);

	void set_row_count_func(class THD *, longlong);

	ha_rows                    cuted_fields;         /*  7632     8 */
	ha_rows                    m_sent_row_count;     /*  7640     8 */
	ha_rows                    m_examined_row_count; /*  7648     8 */
	USER_CONN *                m_user_connect;       /*  7656     8 */
	void set_user_connect(class THD *, USER_CONN *);

	const USER_CONN  * get_user_connect(class THD *);

	void increment_user_connections_counter(class THD *);

	void decrement_user_connections_counter(class THD *);

	void increment_con_per_hour_counter(class THD *);

	void increment_updates_counter(class THD *);

	void increment_questions_counter(class THD *);

	void time_out_user_resource_limits(class THD *);

	ha_rows get_sent_row_count(const class THD  *);

	ha_rows get_examined_row_count(const class THD  *);

	void set_sent_row_count(class THD *, ha_rows);

	void set_examined_row_count(class THD *, ha_rows);

	void inc_sent_row_count(class THD *, ha_rows);

	void inc_examined_row_count(class THD *, ha_rows);

	void inc_status_created_tmp_disk_tables(class THD *);

	void inc_status_created_tmp_files(class THD *);

	void inc_status_created_tmp_tables(class THD *);

	void inc_status_select_full_join(class THD *);

	void inc_status_select_full_range_join(class THD *);

	void inc_status_select_range(class THD *);

	void inc_status_select_range_check(class THD *);

	void inc_status_select_scan(class THD *);

	void inc_status_sort_merge_passes(class THD *);

	void inc_status_sort_range(class THD *);

	void inc_status_sort_rows(class THD *, ha_rows);

	void inc_status_sort_scan(class THD *);

	void set_status_no_index_used(class THD *);

	void set_status_no_good_index_used(class THD *);

	const CHARSET_INFO  *      db_charset;           /*  7664     8 */
	class PROFILING           profiling;             /*  7672    64 */
	/* --- cacheline 120 boundary (7680 bytes) was 56 bytes ago --- */
	PSI_stage_progress *       m_stage_progress_psi; /*  7736     8 */
	/* --- cacheline 121 boundary (7744 bytes) --- */
	sql_digest_state *         m_digest;             /*  7744     8 */
	unsigned char *            m_token_array;        /*  7752     8 */
	sql_digest_state           m_digest_state;       /*  7760    64 */
	/* --- cacheline 122 boundary (7808 bytes) was 16 bytes ago --- */
	PSI_statement_locker *     m_statement_psi;      /*  7824     8 */
	PSI_statement_locker_state m_statement_state;    /*  7832   384 */
	/* --- cacheline 128 boundary (8192 bytes) was 24 bytes ago --- */
	PSI_transaction_locker *   m_transaction_psi;    /*  8216     8 */
	PSI_transaction_locker_state m_transaction_state; /*  8224    88 */
	/* --- cacheline 129 boundary (8256 bytes) was 56 bytes ago --- */
	PSI_idle_locker *          m_idle_psi;           /*  8312     8 */
	/* --- cacheline 130 boundary (8320 bytes) --- */
	PSI_idle_locker_state      m_idle_state;         /*  8320    40 */
	bool                       m_server_idle;        /*  8360     1 */

	/* XXX 7 bytes hole, try to pack */

	query_id_t                 query_id;             /*  8368     8 */
	ulong                      col_access;           /*  8376     8 */
	/* --- cacheline 131 boundary (8384 bytes) --- */
	class QueryStripComments  query_strip_comments;  /*  8384    16 */
	ulong                      statement_id_counter; /*  8400     8 */
	ulong                      rand_saved_seed1;     /*  8408     8 */
	ulong                      rand_saved_seed2;     /*  8416     8 */
	my_thread_t                real_id;              /*  8424     8 */
	my_thread_id               m_thread_id;          /*  8432     4 */
	void set_new_thread_id(class THD *);

	my_thread_id thread_id(const class THD  *);

	uint                       tmp_table;            /*  8436     4 */
	uint                       server_status;        /*  8440     4 */
	uint                       open_options;         /*  8444     4 */
	/* --- cacheline 132 boundary (8448 bytes) --- */
	enum enum_thread_type      system_thread;        /*  8448     4 */
	enum enum_tx_isolation     tx_isolation;         /*  8452     4 */
	bool                       tx_read_only;         /*  8456     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        tx_priority;          /*  8460     4 */
	int                        thd_tx_priority;      /*  8464     4 */
	enum enum_check_fields     count_cuted_fields;   /*  8468     4 */
	ha_rows                    updated_row_count;    /*  8472     8 */
	ha_rows                    sent_row_count_2;     /*  8480     8 */
	class Prealloced_array<st_user_var_events*, 2, true> user_var_events __attribute__((__aligned__(8))); /*  8488    48 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 133 boundary (8512 bytes) was 24 bytes ago --- */
	MEM_ROOT *                 user_var_events_alloc; /*  8536     8 */
	class THD *                next_to_commit;       /*  8544     8 */
	bool                       binlog_need_explicit_defaults_ts; /*  8552     1 */

	/* XXX 3 bytes hole, try to pack */
	void set_trans_pos(class THD *, const char  *, my_off_t);

	void get_trans_pos(const class THD  *, const char  * *, my_off_t *);

	void get_trans_fixed_pos(const class THD  *, const char  * *, my_off_t *);

	my_off_t get_trans_pos(class THD *);


	enum Commit_error          commit_error;         /*  8556     4 */
	enum durability_properties durability_property;  /*  8560     4 */
	volatile enum killed_state  killed;              /*  8564     4 */
	char                       scramble[21];         /*  8568    21 */
	/* --- cacheline 134 boundary (8576 bytes) was 13 bytes ago --- */
	bool                       slave_thread;         /*  8589     1 */
	bool                       no_errors;            /*  8590     1 */
	uchar                      password;             /*  8591     1 */
	bool                       is_fatal_error;       /*  8592     1 */
	bool                       transaction_rollback_request; /*  8593     1 */
	bool                       is_fatal_sub_stmt_error; /*  8594     1 */
	bool                       query_start_usec_used; /*  8595     1 */
	bool                       rand_used;            /*  8596     1 */
	bool                       time_zone_used;       /*  8597     1 */
	bool                       substitute_null_with_insert_id; /*  8598     1 */
	bool                       in_lock_tables;       /*  8599     1 */
	bool                       is_slave_error;       /*  8600     1 */
	bool                       bootstrap;            /*  8601     1 */
	bool                       thread_specific_used; /*  8602     1 */
	bool                       charset_is_system_charset; /*  8603     1 */
	bool                       charset_is_collation_connection; /*  8604     1 */
	bool                       charset_is_character_set_filesystem; /*  8605     1 */
	bool                       enable_slow_log;      /*  8606     1 */
	bool                       got_warning;          /*  8607     1 */
	bool                       derived_tables_processing; /*  8608     1 */
	bool                       tablespace_op;        /*  8609     1 */

	/* XXX 6 bytes hole, try to pack */

	class sp_rcontext *        sp_runtime_ctx;       /*  8616     8 */
	class sp_cache *           sp_proc_cache;        /*  8624     8 */
	class sp_cache *           sp_func_cache;        /*  8632     8 */
	/* --- cacheline 135 boundary (8640 bytes) --- */
	uint                       query_name_consts;    /*  8640     4 */

	/* XXX 4 bytes hole, try to pack */

	LOG_INFO *                 current_linfo;        /*  8648     8 */
	NET *                      slave_net;            /*  8656     8 */
	time_t                     current_connect_time; /*  8664     8 */
	time_t                     last_global_update_time; /*  8672     8 */
	double                     busy_time;            /*  8680     8 */
	double                     diff_total_busy_time; /*  8688     8 */
	double                     cpu_time;             /*  8696     8 */
	/* --- cacheline 136 boundary (8704 bytes) --- */
	double                     diff_total_cpu_time;  /*  8704     8 */
	ulonglong                  bytes_received;       /*  8712     8 */
	ulonglong                  diff_total_bytes_received; /*  8720     8 */
	ulonglong                  bytes_sent;           /*  8728     8 */
	ulonglong                  diff_total_bytes_sent; /*  8736     8 */
	ulonglong                  binlog_bytes_written; /*  8744     8 */
	ulonglong                  diff_total_binlog_bytes_written; /*  8752     8 */
	ha_rows                    diff_total_sent_rows; /*  8760     8 */
	/* --- cacheline 137 boundary (8768 bytes) --- */
	ha_rows                    diff_total_updated_rows; /*  8768     8 */
	ha_rows                    diff_total_read_rows; /*  8776     8 */
	ulonglong                  diff_select_commands; /*  8784     8 */
	ulonglong                  diff_update_commands; /*  8792     8 */
	ulonglong                  diff_other_commands;  /*  8800     8 */
	ulonglong                  diff_commit_trans;    /*  8808     8 */
	ulonglong                  diff_rollback_trans;  /*  8816     8 */
	ulonglong                  diff_denied_connections; /*  8824     8 */
	/* --- cacheline 138 boundary (8832 bytes) --- */
	ulonglong                  diff_lost_connections; /*  8832     8 */
	ulonglong                  diff_access_denied_errors; /*  8840     8 */
	ulonglong                  diff_empty_queries;   /*  8848     8 */
	ulonglong                  query_delay_millis;   /*  8856     8 */
	union {
		my_bool            my_bool_value;        /*  8864     1 */
		long int           long_value;           /*  8864     8 */
		ulong              ulong_value;          /*  8864     8 */
		ulonglong          ulonglong_value;      /*  8864     8 */
		double             double_value;         /*  8864     8 */
	} sys_var_tmp;                                   /*  8864     8 */
	struct {
		bool               do_union;             /*  8872     1 */
		bool               unioned_events;       /*  8873     1 */
		bool               unioned_events_trans; /*  8874     1 */

		/* XXX 5 bytes hole, try to pack */

		query_id_t         first_query_id;       /*  8880     8 */
	} binlog_evt_union;                              /*  8872    16 */
	class Parser_state *       m_parser_state;       /*  8888     8 */
	/* --- cacheline 139 boundary (8896 bytes) --- */
	class Locked_tables_list  locked_tables_list;    /*  8896   120 */
	/* --- cacheline 140 boundary (8960 bytes) was 56 bytes ago --- */
	class partition_info *     work_part_info;       /*  9016     8 */
	/* --- cacheline 141 boundary (9024 bytes) --- */
	class Plugin_array        audit_class_plugins __attribute__((__aligned__(8))); /*  9024    48 */
	class Prealloced_array<long unsigned int, 11, true> audit_class_mask __attribute__((__aligned__(8))); /*  9072   120 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 143 boundary (9152 bytes) was 40 bytes ago --- */
	bool                       m_enable_plugins;     /*  9192     1 */
	void THD(class THD *, bool);

	virtual void ~THD(class THD *, int);

	void release_resources(class THD *);

	bool release_resources_done(const class THD  *);

	bool                       m_release_resources_done; /*  9193     1 */
	bool                       cleanup_done;         /*  9194     1 */

	/* XXX 5 bytes hole, try to pack */
	void cleanup(class THD *);

	void init(class THD *);

	void init_for_queries(class THD *, class Relay_log_info *);

	void cleanup_connection(class THD *);

	void reset_stats(class THD *);

	void reset_diff_stats(class THD *);

	void update_stats(class THD *, bool);

	void cleanup_after_query(class THD *);

	bool store_globals(class THD *);

	void restore_globals(class THD *);

	void set_active_vio(class THD *, Vio *);

	void set_ssl(class THD *, Vio *);

	void clear_active_vio(class THD *);

	enum enum_vio_type get_vio_type(class THD *);

	void shutdown_active_vio(class THD *);

	void awake(class THD *, enum killed_state);

	void disconnect(class THD *, bool);

	int binlog_query(class THD *, enum enum_binlog_query_type, const char  *, size_t, bool, bool, bool, int);

	virtual void enter_cond(class THD *, mysql_cond_t *, mysql_mutex_t *, const PSI_stage_info  *, PSI_stage_info *, const char  *, const char  *, int);

	virtual void exit_cond(class THD *, const PSI_stage_info  *, const char  *, const char  *, int);

	virtual int is_killed(class THD *);

	virtual class THD * get_thd(class THD *);

	virtual void notify_shared_lock(class THD *, class MDL_context_owner *, bool);

	virtual bool notify_hton_pre_acquire_exclusive(class THD *, const MDL_key  *, bool *);

	virtual void notify_hton_post_release_exclusive(class THD *, const MDL_key  *);

	virtual uint get_rand_seed(class THD *);

	bool is_strict_mode(const class THD  *);

	class Time_zone * time_zone(class THD *);

	time_t query_start(class THD *);

	long int query_start_usec(class THD *);

	class timeval query_start_timeval(class THD *);

	class timeval query_start_timeval_trunc(class THD *, uint);

	void set_time(class THD *);

	void set_current_time(class THD *);

	void set_time(class THD *, const class timeval  *);

	void get_time(const class THD  *, QUERY_START_TIME_INFO *);

	void set_time(class THD *, QUERY_START_TIME_INFO *);

	bool is_valid_time(class THD *);

	void set_time_after_lock(class THD *);

	ulonglong current_utime(class THD *);

	void update_server_status(class THD *);

	ulonglong found_rows(class THD *);

	void update_previous_found_rows(class THD *);

	bool in_multi_stmt_transaction_mode(const class THD  *);

	bool in_active_multi_stmt_transaction(const class THD  *);

	bool fill_derived_tables(class THD *);

	bool fill_information_schema_tables(class THD *);

	LEX_CSTRING * make_lex_string(class THD *, LEX_CSTRING *, const char  *, size_t, bool);

	LEX_STRING * make_lex_string(class THD *, LEX_STRING *, const char  *, size_t, bool);

	bool convert_string(class THD *, LEX_STRING *, const CHARSET_INFO  *, const char  *, size_t, const CHARSET_INFO  *);

	bool convert_string(class THD *, LEX_CSTRING *, const CHARSET_INFO  *, const char  *, size_t, const CHARSET_INFO  *);

	bool convert_string(class THD *, class String *, const CHARSET_INFO  *, const CHARSET_INFO  *);

	void add_changed_table(class THD *, class TABLE *);

	void add_changed_table(class THD *, const char  *, long int);

	int send_explain_fields(class THD *, class Query_result *);

	void clear_error(class THD *);

	bool is_classic_protocol(class THD *);

	virtual bool is_connected(class THD *);

	void fatal_error(class THD *);

	bool is_error(const class THD  *);

	class Diagnostics_area * get_stmt_da(class THD *);

	const class Diagnostics_area  * get_stmt_da(const class THD  *);

	const class Diagnostics_area  * get_stacked_da(const class THD  *);

	class Diagnostics_area * get_parser_da(class THD *);

	class Diagnostics_area * get_query_rewrite_plugin_da(class THD *);

	void push_diagnostics_area(class THD *, class Diagnostics_area *, bool);

	void pop_diagnostics_area(class THD *);

	const CHARSET_INFO  * charset(const class THD  *);

	void update_charset(class THD *);

	void change_item_tree(class THD *, class Item * *, class Item *);

	void nocheck_register_item_tree_change(class THD *, class Item * *, class Item *);

	void replace_rollback_place(class THD *, class Item * *);

	void rollback_item_tree_changes(class THD *);

	void end_statement(class THD *);

	int killed_errno(const class THD  *);

	void send_kill_message(const class THD  *);

	void set_status_var_init(class THD *);

	void reset_n_backup_open_tables_state(class THD *, class Open_tables_backup *);

	void restore_backup_open_tables_state(class THD *, class Open_tables_backup *);

	void reset_sub_statement_state(class THD *, class Sub_statement_state *, uint);

	void restore_sub_statement_state(class THD *, class Sub_statement_state *);

	void set_n_backup_active_arena(class THD *, class Query_arena *, class Query_arena *);

	void restore_active_arena(class THD *, class Query_arena *, class Query_arena *);

	void begin_attachable_ro_transaction(class THD *);

	void begin_attachable_rw_transaction(class THD *);

	void end_attachable_transaction(class THD *);

	int is_attachable_transaction_active(const class THD  *);

	bool is_attachable_ro_transaction_active(const class THD  *);

	bool is_attachable_rw_transaction_active(const class THD  *);

	void set_current_stmt_binlog_format_row_if_mixed(class THD *);

	void set_current_stmt_binlog_format_row(class THD *);

	void clear_current_stmt_binlog_format_row(class THD *);

	void reset_current_stmt_binlog_format_row(class THD *);

	void set_currently_executing_gtid_for_slave_thread(class THD *);

	class Gtid_set * get_gtid_next_list(class THD *);

	const class Gtid_set  * get_gtid_next_list_const(const class THD  *);

	bool is_binlog_cache_empty(class THD *, bool);


	struct Gtid                owned_gtid;           /*  9200    16 */

	/* Bitfield combined with previous fields */

	static const int                  OWNED_SIDNO_GTID_SET = 18446744073709551615; /*     0     0 */
	static const int                  OWNED_SIDNO_ANONYMOUS = 18446744073709551614; /*     0     0 */
	/* --- cacheline 144 boundary (9216 bytes) --- */
	rpl_sid                    owned_sid;            /*  9216    16 */
	class Rpl_thd_context     rpl_thd_ctx;           /*  9232    56 */

	/* XXX last struct has 4 bytes of padding */
	void clear_owned_gtids(class THD *);


	/* --- cacheline 145 boundary (9280 bytes) was 8 bytes ago --- */
	bool                       skip_gtid_rollback;   /*  9288     1 */
	bool                       is_commit_in_middle_of_statement; /*  9289     1 */
	bool                       has_gtid_consistency_violation; /*  9290     1 */

	/* XXX 5 bytes hole, try to pack */
	const LEX_CSTRING  & db(const class THD  *);

	bool set_db(class THD *, const LEX_CSTRING  &);

	void reset_db(class THD *, const LEX_CSTRING  &);

	bool copy_db_to(class THD *, char * *, size_t *);


	class thd_scheduler       event_scheduler;       /*  9296     8 */
	void set_psi(class THD *, PSI_thread *);

	PSI_thread * get_psi(class THD *);

	PSI_thread *               m_psi;                /*  9304     8 */
	class Internal_error_handler * get_internal_handler(class THD *);

	void push_internal_handler(class THD *, class Internal_error_handler *);

	bool handle_condition(class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	class Internal_error_handler * pop_internal_handler(class THD *);

	class Opt_trace_context   opt_trace;             /*  9312    16 */

	/* XXX last struct has 4 bytes of padding */
	void raise_error(class THD *, uint);

	void raise_error_printf(class THD *, uint, ...);

	void raise_warning(class THD *, uint);

	void raise_warning_printf(class THD *, uint, ...);

	void raise_note(class THD *, uint);

	void raise_note_printf(class THD *, uint, ...);

	class Sql_condition * raise_condition(class THD *, uint, const char  *, enum enum_severity_level, const char  *, bool);

	void set_command(class THD *, enum enum_server_command);

	enum enum_server_command get_command(const class THD  *);

	const LEX_CSTRING  & query(const class THD  *);

	const class String  normalized_query(class THD *);

	void set_query_for_display(class THD *, const char  *, size_t);

	void reset_query_for_display(class THD *);

	void set_safe_display(class THD *, bool);

	int32 safe_to_display(class THD *);

	void set_query(class THD *, const char  *, size_t);

	void set_query(class THD *, const LEX_CSTRING  &);

	void reset_query(class THD *);

	void swap_rewritten_query(class THD *, class String &);

	const class String  & rewritten_query(const class THD  *);

	void reset_rewritten_query(class THD *);

	void set_query_id(class THD *, query_id_t);

	void set_open_tables(class THD *, class TABLE *);

	void set_is_killable(class THD *, bool);

	void enter_locked_tables_mode(class THD *, enum enum_locked_tables_mode);

	void leave_locked_tables_mode(class THD *);

	int decide_logging_format(class THD *, class TABLE_LIST *, bool);

	bool is_dml_gtid_compatible(class THD *, bool, bool, bool);

	bool is_ddl_gtid_compatible(class THD *);

	void binlog_invoker(class THD *);

	bool need_binlog_invoker(class THD *);

	void get_definer(class THD *, LEX_USER *);

	void set_invoker(class THD *, const LEX_STRING  *, const LEX_STRING  *);

	LEX_CSTRING get_invoker_user(const class THD  *);

	LEX_CSTRING get_invoker_host(const class THD  *);

	bool has_invoker(class THD *);

	void mark_transaction_to_rollback(class THD *, bool);


	class Internal_error_handler * m_internal_handler; /*  9328     8 */
	struct LEX                 main_lex __attribute__((__aligned__(8))); /*  9336     0 */

	/* XXX 2672 bytes hole, try to pack */

	/* --- cacheline 187 boundary (11968 bytes) was 40 bytes ago --- */
	MEM_ROOT                   main_mem_root;        /* 12008    88 */
	/* --- cacheline 189 boundary (12096 bytes) --- */
	class Diagnostics_area    main_da;               /* 12096   744 */
	/* --- cacheline 200 boundary (12800 bytes) was 40 bytes ago --- */
	class Diagnostics_area    m_parser_da;           /* 12840   744 */
	/* --- cacheline 212 boundary (13568 bytes) was 16 bytes ago --- */
	class Diagnostics_area    m_query_rewrite_plugin_da; /* 13584   744 */
	/* --- cacheline 223 boundary (14272 bytes) was 56 bytes ago --- */
	class Diagnostics_area *   m_query_rewrite_plugin_da_ptr; /* 14328     8 */
	/* --- cacheline 224 boundary (14336 bytes) --- */
	class Diagnostics_area *   m_stmt_da;            /* 14336     8 */
	bool                       m_binlog_invoker;     /* 14344     1 */

	/* XXX 7 bytes hole, try to pack */

	LEX_CSTRING                m_invoker_user;       /* 14352    16 */
	LEX_CSTRING                m_invoker_host;       /* 14368    16 */
	class Cost_model_server   m_cost_model;          /* 14384     0 */

	/* XXX 24 bytes hole, try to pack */
	void init_cost_model(class THD *);

	const class Cost_model_server  * cost_model(const class THD  *);


	/* --- cacheline 225 boundary (14400 bytes) was 8 bytes ago --- */
	class Session_tracker     session_tracker;       /* 14408    40 */
	class Session_sysvar_resource_manager session_sysvar_res_mgr; /* 14448   112 */
	void parse_error_at(class THD *, const YYLTYPE  &, const char  *);

	bool send_result_metadata(class THD *, class List<Item> *, uint);

	bool send_result_set_row(class THD *, class List<Item> *);

	void send_statement_status(class THD *);

	/* --- cacheline 227 boundary (14528 bytes) was 32 bytes ago --- */
	bool                       duplicate_slave_id;   /* 14560     1 */
	void claim_memory_ownership(class THD *);

	bool is_a_srv_session(const class THD  *);

	void mark_as_srv_session(class THD *);

	bool                       is_a_srv_session_thd; /* 14561     1 */
	/* vtable has 9 entries: {
	   [2] = enter_cond((null)), 
	   [3] = exit_cond((null)), 
	   [4] = is_killed((null)), 
	   [6] = get_thd((null)), 
	   [7] = notify_shared_lock((null)), 
	   [8] = notify_hton_pre_acquire_exclusive((null)), 
	   [9] = notify_hton_post_release_exclusive((null)), 
	   [10] = get_rand_seed((null)), 
	   [5] = is_connected((null)), 
	} */
	/* size: 14568, cachelines: 228, members: 258, static members: 3 */
	/* sum members: 11411, holes: 28, sum holes: 2999 */
	/* padding: 6 */
	/* paddings: 15, sum paddings: 63 */
	/* forced alignments: 4 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 14568 bytes != 11411 (member bytes) + 0 (member bits) + 2999 (byte holes) + 0 (bit holes), diff = 1216 bits */
} __attribute__((__aligned__(8)));
struct PSI_v1 {
	register_mutex_v1_t        register_mutex;       /*     0     8 */
	register_rwlock_v1_t       register_rwlock;      /*     8     8 */
	register_cond_v1_t         register_cond;        /*    16     8 */
	register_thread_v1_t       register_thread;      /*    24     8 */
	register_file_v1_t         register_file;        /*    32     8 */
	register_stage_v1_t        register_stage;       /*    40     8 */
	register_statement_v1_t    register_statement;   /*    48     8 */
	register_socket_v1_t       register_socket;      /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	init_mutex_v1_t            init_mutex;           /*    64     8 */
	destroy_mutex_v1_t         destroy_mutex;        /*    72     8 */
	init_rwlock_v1_t           init_rwlock;          /*    80     8 */
	destroy_rwlock_v1_t        destroy_rwlock;       /*    88     8 */
	init_cond_v1_t             init_cond;            /*    96     8 */
	destroy_cond_v1_t          destroy_cond;         /*   104     8 */
	init_socket_v1_t           init_socket;          /*   112     8 */
	destroy_socket_v1_t        destroy_socket;       /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	get_table_share_v1_t       get_table_share;      /*   128     8 */
	release_table_share_v1_t   release_table_share;  /*   136     8 */
	drop_table_share_v1_t      drop_table_share;     /*   144     8 */
	open_table_v1_t            open_table;           /*   152     8 */
	unbind_table_v1_t          unbind_table;         /*   160     8 */
	rebind_table_v1_t          rebind_table;         /*   168     8 */
	close_table_v1_t           close_table;          /*   176     8 */
	create_file_v1_t           create_file;          /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	spawn_thread_v1_t          spawn_thread;         /*   192     8 */
	new_thread_v1_t            new_thread;           /*   200     8 */
	set_thread_id_v1_t         set_thread_id;        /*   208     8 */
	set_thread_THD_v1_t        set_thread_THD;       /*   216     8 */
	set_thread_os_id_v1_t      set_thread_os_id;     /*   224     8 */
	get_thread_v1_t            get_thread;           /*   232     8 */
	set_thread_user_v1_t       set_thread_user;      /*   240     8 */
	set_thread_account_v1_t    set_thread_account;   /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	set_thread_db_v1_t         set_thread_db;        /*   256     8 */
	set_thread_command_v1_t    set_thread_command;   /*   264     8 */
	set_connection_type_v1_t   set_connection_type;  /*   272     8 */
	set_thread_start_time_v1_t set_thread_start_time; /*   280     8 */
	set_thread_state_v1_t      set_thread_state;     /*   288     8 */
	set_thread_info_v1_t       set_thread_info;      /*   296     8 */
	set_thread_v1_t            set_thread;           /*   304     8 */
	delete_current_thread_v1_t delete_current_thread; /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	delete_thread_v1_t         delete_thread;        /*   320     8 */
	get_thread_file_name_locker_v1_t get_thread_file_name_locker; /*   328     8 */
	get_thread_file_stream_locker_v1_t get_thread_file_stream_locker; /*   336     8 */
	get_thread_file_descriptor_locker_v1_t get_thread_file_descriptor_locker; /*   344     8 */
	unlock_mutex_v1_t          unlock_mutex;         /*   352     8 */
	unlock_rwlock_v1_t         unlock_rwlock;        /*   360     8 */
	signal_cond_v1_t           signal_cond;          /*   368     8 */
	broadcast_cond_v1_t        broadcast_cond;       /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	start_idle_wait_v1_t       start_idle_wait;      /*   384     8 */
	end_idle_wait_v1_t         end_idle_wait;        /*   392     8 */
	start_mutex_wait_v1_t      start_mutex_wait;     /*   400     8 */
	end_mutex_wait_v1_t        end_mutex_wait;       /*   408     8 */
	start_rwlock_rdwait_v1_t   start_rwlock_rdwait;  /*   416     8 */
	end_rwlock_rdwait_v1_t     end_rwlock_rdwait;    /*   424     8 */
	start_rwlock_wrwait_v1_t   start_rwlock_wrwait;  /*   432     8 */
	end_rwlock_wrwait_v1_t     end_rwlock_wrwait;    /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	start_cond_wait_v1_t       start_cond_wait;      /*   448     8 */
	end_cond_wait_v1_t         end_cond_wait;        /*   456     8 */
	start_table_io_wait_v1_t   start_table_io_wait;  /*   464     8 */
	end_table_io_wait_v1_t     end_table_io_wait;    /*   472     8 */
	start_table_lock_wait_v1_t start_table_lock_wait; /*   480     8 */
	end_table_lock_wait_v1_t   end_table_lock_wait;  /*   488     8 */
	start_file_open_wait_v1_t  start_file_open_wait; /*   496     8 */
	end_file_open_wait_v1_t    end_file_open_wait;   /*   504     8 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	end_file_open_wait_and_bind_to_descriptor_v1_t end_file_open_wait_and_bind_to_descriptor; /*   512     8 */
	end_temp_file_open_wait_and_bind_to_descriptor_v1_t end_temp_file_open_wait_and_bind_to_descriptor; /*   520     8 */
	start_file_wait_v1_t       start_file_wait;      /*   528     8 */
	end_file_wait_v1_t         end_file_wait;        /*   536     8 */
	start_file_close_wait_v1_t start_file_close_wait; /*   544     8 */
	end_file_close_wait_v1_t   end_file_close_wait;  /*   552     8 */
	end_file_rename_wait_v1_t  end_file_rename_wait; /*   560     8 */
	start_stage_v1_t           start_stage;          /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	get_current_stage_progress_v1_t get_current_stage_progress; /*   576     8 */
	end_stage_v1_t             end_stage;            /*   584     8 */
	get_thread_statement_locker_v1_t get_thread_statement_locker; /*   592     8 */
	refine_statement_v1_t      refine_statement;     /*   600     8 */
	start_statement_v1_t       start_statement;      /*   608     8 */
	set_statement_text_v1_t    set_statement_text;   /*   616     8 */
	set_statement_lock_time_t  set_statement_lock_time; /*   624     8 */
	set_statement_rows_sent_t  set_statement_rows_sent; /*   632     8 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	set_statement_rows_examined_t set_statement_rows_examined; /*   640     8 */
	inc_statement_created_tmp_disk_tables_t inc_statement_created_tmp_disk_tables; /*   648     8 */
	inc_statement_created_tmp_tables_t inc_statement_created_tmp_tables; /*   656     8 */
	inc_statement_select_full_join_t inc_statement_select_full_join; /*   664     8 */
	inc_statement_select_full_range_join_t inc_statement_select_full_range_join; /*   672     8 */
	inc_statement_select_range_t inc_statement_select_range; /*   680     8 */
	inc_statement_select_range_check_t inc_statement_select_range_check; /*   688     8 */
	inc_statement_select_scan_t inc_statement_select_scan; /*   696     8 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	inc_statement_sort_merge_passes_t inc_statement_sort_merge_passes; /*   704     8 */
	inc_statement_sort_range_t inc_statement_sort_range; /*   712     8 */
	inc_statement_sort_rows_t  inc_statement_sort_rows; /*   720     8 */
	inc_statement_sort_scan_t  inc_statement_sort_scan; /*   728     8 */
	set_statement_no_index_used_t set_statement_no_index_used; /*   736     8 */
	set_statement_no_good_index_used_t set_statement_no_good_index_used; /*   744     8 */
	end_statement_v1_t         end_statement;        /*   752     8 */
	get_thread_transaction_locker_v1_t get_thread_transaction_locker; /*   760     8 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	start_transaction_v1_t     start_transaction;    /*   768     8 */
	set_transaction_xid_v1_t   set_transaction_xid;  /*   776     8 */
	set_transaction_xa_state_v1_t set_transaction_xa_state; /*   784     8 */
	set_transaction_gtid_v1_t  set_transaction_gtid; /*   792     8 */
	set_transaction_trxid_v1_t set_transaction_trxid; /*   800     8 */
	inc_transaction_savepoints_v1_t inc_transaction_savepoints; /*   808     8 */
	inc_transaction_rollback_to_savepoint_v1_t inc_transaction_rollback_to_savepoint; /*   816     8 */
	inc_transaction_release_savepoint_v1_t inc_transaction_release_savepoint; /*   824     8 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	end_transaction_v1_t       end_transaction;      /*   832     8 */
	start_socket_wait_v1_t     start_socket_wait;    /*   840     8 */
	end_socket_wait_v1_t       end_socket_wait;      /*   848     8 */
	set_socket_state_v1_t      set_socket_state;     /*   856     8 */
	set_socket_info_v1_t       set_socket_info;      /*   864     8 */
	set_socket_thread_owner_v1_t set_socket_thread_owner; /*   872     8 */
	create_prepared_stmt_v1_t  create_prepared_stmt; /*   880     8 */
	destroy_prepared_stmt_v1_t destroy_prepared_stmt; /*   888     8 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	reprepare_prepared_stmt_v1_t reprepare_prepared_stmt; /*   896     8 */
	execute_prepared_stmt_v1_t execute_prepared_stmt; /*   904     8 */
	set_prepared_stmt_text_v1_t set_prepared_stmt_text; /*   912     8 */
	digest_start_v1_t          digest_start;         /*   920     8 */
	digest_end_v1_t            digest_end;           /*   928     8 */
	set_thread_connect_attrs_v1_t set_thread_connect_attrs; /*   936     8 */
	start_sp_v1_t              start_sp;             /*   944     8 */
	end_sp_v1_t                end_sp;               /*   952     8 */
	/* --- cacheline 15 boundary (960 bytes) --- */
	drop_sp_v1_t               drop_sp;              /*   960     8 */
	get_sp_share_v1_t          get_sp_share;         /*   968     8 */
	release_sp_share_v1_t      release_sp_share;     /*   976     8 */
	register_memory_v1_t       register_memory;      /*   984     8 */
	memory_alloc_v1_t          memory_alloc;         /*   992     8 */
	memory_realloc_v1_t        memory_realloc;       /*  1000     8 */
	memory_claim_v1_t          memory_claim;         /*  1008     8 */
	memory_free_v1_t           memory_free;          /*  1016     8 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	unlock_table_v1_t          unlock_table;         /*  1024     8 */
	create_metadata_lock_v1_t  create_metadata_lock; /*  1032     8 */
	set_metadata_lock_status_v1_t set_metadata_lock_status; /*  1040     8 */
	destroy_metadata_lock_v1_t destroy_metadata_lock; /*  1048     8 */
	start_metadata_wait_v1_t   start_metadata_wait;  /*  1056     8 */
	end_metadata_wait_v1_t     end_metadata_wait;    /*  1064     8 */

	/* size: 1072, cachelines: 17, members: 134 */
	/* last cacheline: 48 bytes */
};
struct mysql_malloc_service_st {
	mysql_malloc_t             mysql_malloc;         /*     0     8 */
	mysql_realloc_t            mysql_realloc;        /*     8     8 */
	mysql_claim_t              mysql_claim;          /*    16     8 */
	mysql_free_t               mysql_free;           /*    24     8 */
	my_memdup_t                my_memdup;            /*    32     8 */
	my_strdup_t                my_strdup;            /*    40     8 */
	my_strndup_t               my_strndup;           /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct st_rw_pr_lock_t {
	native_mutex_t             lock;                 /*     0    40 */
	native_cond_t              no_active_readers;    /*    40    48 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	uint                       active_readers;       /*    88     4 */
	uint                       writers_waiting_readers; /*    92     4 */
	my_bool                    active_writer;        /*    96     1 */

	/* size: 104, cachelines: 2, members: 5 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
struct st_mysql_mutex {
	my_mutex_t                 m_mutex;              /*     0    40 */
	class PSI_mutex *          m_psi;                /*    40     8 */

	/* size: 48, cachelines: 1, members: 2 */
	/* last cacheline: 48 bytes */
};
struct st_mysql_rwlock {
	native_rw_lock_t           m_rwlock;             /*     0    56 */
	class PSI_rwlock *         m_psi;                /*    56     8 */

	/* size: 64, cachelines: 1, members: 2 */
};
struct st_mysql_prlock {
	rw_pr_lock_t               m_prlock;             /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	class PSI_rwlock *         m_psi;                /*   104     8 */

	/* size: 112, cachelines: 2, members: 2 */
	/* last cacheline: 48 bytes */
};
struct st_mysql_cond {
	native_cond_t              m_cond;               /*     0    48 */
	class PSI_cond *           m_psi;                /*    48     8 */

	/* size: 56, cachelines: 1, members: 2 */
	/* last cacheline: 56 bytes */
};
struct st_used_mem {
	class st_used_mem *        next;                 /*     0     8 */
	unsigned int               left;                 /*     8     4 */
	unsigned int               size;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct st_mem_root {
	USED_MEM *                 free;                 /*     0     8 */
	USED_MEM *                 used;                 /*     8     8 */
	USED_MEM *                 pre_alloc;            /*    16     8 */
	size_t                     min_malloc;           /*    24     8 */
	size_t                     block_size;           /*    32     8 */
	unsigned int               block_num;            /*    40     4 */
	unsigned int               first_block_usage;    /*    44     4 */
	size_t                     max_capacity;         /*    48     8 */
	size_t                     allocated_size;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	my_bool                    error_for_capacity_exceeded; /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	void                       (*error_handler)(void); /*    72     8 */
	PSI_memory_key             m_psi_key;            /*    80     4 */

	/* size: 88, cachelines: 2, members: 12 */
	/* sum members: 77, holes: 1, sum holes: 7 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct st_typelib {
	unsigned int               count;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              name;                 /*     8     8 */
	const char  * *            type_names;           /*    16     8 */
	unsigned int *             type_lengths;         /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct st_my_file_info {
	char *                     name;                 /*     0     8 */
	enum file_type             type;                 /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct st_dynamic_array {
	uchar *                    buffer;               /*     0     8 */
	uint                       elements;             /*     8     4 */
	uint                       max_element;          /*    12     4 */
	uint                       alloc_increment;      /*    16     4 */
	uint                       size_of_element;      /*    20     4 */
	PSI_memory_key             m_psi_key;            /*    24     4 */

	/* size: 32, cachelines: 1, members: 6 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct st_my_tmpdir {
	char * *                   list;                 /*     0     8 */
	uint                       cur;                  /*     8     4 */
	uint                       max;                  /*    12     4 */
	mysql_mutex_t              mutex;                /*    16    48 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct st_io_cache {
	my_off_t                   pos_in_file;          /*     0     8 */
	my_off_t                   end_of_file;          /*     8     8 */
	uchar *                    read_pos;             /*    16     8 */
	uchar *                    read_end;             /*    24     8 */
	uchar *                    buffer;               /*    32     8 */
	uchar *                    request_pos;          /*    40     8 */
	uchar *                    write_buffer;         /*    48     8 */
	uchar *                    append_read_pos;      /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uchar *                    write_pos;            /*    64     8 */
	uchar *                    write_end;            /*    72     8 */
	uchar * *                  current_pos;          /*    80     8 */
	uchar * *                  current_end;          /*    88     8 */
	mysql_mutex_t              append_buffer_lock;   /*    96    48 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	IO_CACHE_SHARE *           share;                /*   144     8 */
	int                        (*read_function)(class st_io_cache *, uchar *, size_t); /*   152     8 */
	int                        (*write_function)(class st_io_cache *, const uchar  *, size_t); /*   160     8 */
	enum cache_type            type;                 /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	IO_CACHE_CALLBACK          pre_read;             /*   176     8 */
	IO_CACHE_CALLBACK          post_read;            /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	IO_CACHE_CALLBACK          pre_close;            /*   192     8 */
	ulong                      disk_writes;          /*   200     8 */
	void *                     arg;                  /*   208     8 */
	char *                     file_name;            /*   216     8 */
	char *                     dir;                  /*   224     8 */
	char *                     prefix;               /*   232     8 */
	File                       file;                 /*   240     4 */
	PSI_file_key               file_key;             /*   244     4 */
	int                        seek_not_done;        /*   248     4 */
	int                        error;                /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	size_t                     buffer_length;        /*   256     8 */
	size_t                     read_length;          /*   264     8 */
	myf                        myflags;              /*   272     4 */
	my_bool                    alloced_buffer;       /*   276     1 */

	/* size: 280, cachelines: 5, members: 33 */
	/* sum members: 273, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct st_io_cache_share {
	mysql_mutex_t              mutex;                /*     0    48 */
	mysql_cond_t               cond;                 /*    48    56 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	mysql_cond_t               cond_writer;          /*   104    56 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	my_off_t                   pos_in_file;          /*   160     8 */
	class st_io_cache *        source_cache;         /*   168     8 */
	uchar *                    buffer;               /*   176     8 */
	uchar *                    read_end;             /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        running_threads;      /*   192     4 */
	int                        total_threads;        /*   196     4 */
	int                        error;                /*   200     4 */

	/* size: 208, cachelines: 4, members: 10 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct st_syslog_facility {
	int                        id;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct st_mysql_file {
	FILE *                     m_file;               /*     0     8 */
	class PSI_file *           m_psi;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct my_snprintf_service_st {
	size_t                     (*my_snprintf_type)(char *, size_t, const char  *, ...); /*     0     8 */
	size_t                     (*my_vsnprintf_type)(char *, size_t, const char  *, class typedef __va_list_tag __va_list_tag *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Simple_cstring {
	const char  *              m_str;                /*     0     8 */
	size_t                     m_length;             /*     8     8 */
protected:

	void set(class Simple_cstring *, const char  *, size_t);

public:

	void Simple_cstring(class Simple_cstring *);

	void Simple_cstring(class Simple_cstring *, const char  *, size_t);

	void Simple_cstring(class Simple_cstring *, LEX_STRING);

	void reset(class Simple_cstring *);

	void set(class Simple_cstring *, const char  *);

	const char  * ptr(const class Simple_cstring  *);

	bool is_set(const class Simple_cstring  *);

	size_t length(const class Simple_cstring  *);

	bool eq_bin(const class Simple_cstring  *, class Simple_cstring);

	void strcpy(const class Simple_cstring  *, char *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class String {
	char *                     m_ptr;                /*     0     8 */
	size_t                     m_length;             /*     8     8 */
	const CHARSET_INFO  *      m_charset;            /*    16     8 */
	uint32                     m_alloced_length;     /*    24     4 */
	bool                       m_is_alloced;         /*    28     1 */
public:

	void String(class String *);

	void String(class String *, size_t);

	void String(class String *, const char  *, const CHARSET_INFO  *);

	void String(class String *, const char  *, size_t, const CHARSET_INFO  *);

	void String(class String *, char *, size_t, const CHARSET_INFO  *);

	void String(class String *, const class String  &);

	void * operator new(size_t, MEM_ROOT *);

	void operator delete(void *, size_t);

	void operator delete(void *, MEM_ROOT *);

	void ~String(class String *, int);

	void set_charset(class String *, const CHARSET_INFO  *);

	const CHARSET_INFO  * charset(const class String  *);

	size_t length(const class String  *);

	size_t alloced_length(const class String  *);

	char & operator[](const class String  *, size_t);

	void length(class String *, size_t);

	bool is_empty(const class String  *);

	void mark_as_const(class String *);

	const char  * ptr(const class String  *);

	char * c_ptr(class String *);

	char * c_ptr_quick(class String *);

	char * c_ptr_safe(class String *);

	LEX_STRING lex_string(const class String  *);

	LEX_CSTRING lex_cstring(const class String  *);

	void set(class String *, class String &, size_t, size_t);

	void set(class String *, char *, size_t, const CHARSET_INFO  *);

	void set(class String *, const char  *, size_t, const CHARSET_INFO  *);

	bool set_ascii(class String *, const char  *, size_t);

	void set_quick(class String *, char *, size_t, const CHARSET_INFO  *);

	bool set_int(class String *, longlong, bool, const CHARSET_INFO  *);

	bool set(class String *, longlong, const CHARSET_INFO  *);

	bool set(class String *, ulonglong, const CHARSET_INFO  *);

	bool set_real(class String *, double, uint, const CHARSET_INFO  *);

	void chop(class String *);

	void mem_claim(class String *);

	void mem_free(class String *);

	bool alloc(class String *, size_t);

	bool real_alloc(class String *, size_t);

	bool mem_realloc(class String *, size_t, bool);

	size_t next_realloc_exp_size(class String *, size_t);

	bool mem_realloc_exp(class String *, size_t);

	void shrink(class String *, size_t);

	bool is_alloced(const class String  *);

	class String & operator=(class String *, const class String  &);

	void takeover(class String *, class String &);

	bool copy(class String *);

	bool copy(class String *, const class String  &);

	bool copy(class String *, const char  *, size_t, const CHARSET_INFO  *);

	bool needs_conversion(size_t, const CHARSET_INFO  *, const CHARSET_INFO  *, size_t *);

	bool needs_conversion_on_storage(size_t, const CHARSET_INFO  *, const CHARSET_INFO  *);

	bool copy_aligned(class String *, const char  *, size_t, size_t, const CHARSET_INFO  *);

	bool set_or_copy_aligned(class String *, const char  *, size_t, const CHARSET_INFO  *);

	bool copy(class String *, const char  *, size_t, const CHARSET_INFO  *, const CHARSET_INFO  *, uint *);

	bool append(class String *, const class String  &);

	bool append(class String *, const char  *);

	bool append(class String *, LEX_STRING *);

	bool append(class String *, class Simple_cstring);

	bool append(class String *, const char  *, size_t);

	bool append(class String *, const char  *, size_t, const CHARSET_INFO  *);

	bool append_ulonglong(class String *, ulonglong);

	bool append_longlong(class String *, longlong);

	bool append(class String *, IO_CACHE *, size_t);

	bool append_with_prefill(class String *, const char  *, size_t, size_t, char);

	bool append_parenthesized(class String *, long int, int);

	int strstr(class String *, const class String  &, size_t);

	int strrstr(class String *, const class String  &, size_t);

	class String substr(class String *, int, int);

	bool replace(class String *, size_t, size_t, const char  *, size_t);

	bool replace(class String *, size_t, size_t, const class String  &);

	bool append(class String *, char);

	bool fill(class String *, size_t, char);

	void strip_sp(class String *);

	size_t numchars(const class String  *);

	size_t charpos(class String *, size_t, size_t);

	int reserve(class String *, size_t);

	int reserve(class String *, size_t, size_t);

	void q_append(class String *, char);

	void q_append(class String *, uint32);

	void q_append(class String *, double);

	void q_append(class String *, double *);

	void q_append(class String *, const char  *, size_t);

	void write_at_position(class String *, int, uint32);

	void qs_append(class String *, const char  *, size_t);

	void qs_append(class String *, double, size_t);

	void qs_append(class String *, char);

	void qs_append(class String *, int);

	void qs_append(class String *, uint);

	char * prep_append(class String *, size_t, size_t);

	bool append(class String *, const char  *, size_t, size_t);

	void print(class String *, class String *);

	void swap(class String *, class String &);

	bool uses_buffer_owned_by(const class String  *, const class String  *);

	bool is_ascii(const class String  *);

	char * dup(const class String  *, MEM_ROOT *);


	/* size: 32, cachelines: 1, members: 5 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */
};
struct st_bitmap {
	my_bitmap_map *            bitmap;               /*     0     8 */
	uint                       n_bits;               /*     8     4 */
	my_bitmap_map              last_word_mask;       /*    12     4 */
	my_bitmap_map *            last_word_ptr;        /*    16     8 */
	mysql_mutex_t *            mutex;                /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct st_decimal_t {
	int                        intg;                 /*     0     4 */
	int                        frac;                 /*     4     4 */
	int                        len;                  /*     8     4 */
	my_bool                    sign;                 /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	decimal_digit_t *          buf;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct st_mysql_time {
	unsigned int               year;                 /*     0     4 */
	unsigned int               month;                /*     4     4 */
	unsigned int               day;                  /*     8     4 */
	unsigned int               hour;                 /*    12     4 */
	unsigned int               minute;               /*    16     4 */
	unsigned int               second;               /*    20     4 */
	long unsigned int          second_part;          /*    24     8 */
	my_bool                    neg;                  /*    32     1 */

	/* XXX 3 bytes hole, try to pack */

	enum enum_mysql_timestamp_type time_type;        /*    36     4 */

	/* size: 40, cachelines: 1, members: 9 */
	/* sum members: 37, holes: 1, sum holes: 3 */
	/* last cacheline: 40 bytes */
};
class my_decimal : public st_decimal_t {
public:

	/* struct st_decimal_t        <ancestor>; */     /*     0    24 */
	decimal_digit_t            buffer[9];            /*    24    36 */
	void my_decimal(class my_decimal *, const class my_decimal  &);

	class my_decimal & operator=(class my_decimal *, const class my_decimal  &);

	void init(class my_decimal *);

	void my_decimal(class my_decimal *);

	void ~my_decimal(class my_decimal *, int);

	void sanity_check(const class my_decimal  *);

	bool sign(const class my_decimal  *);

	void sign(class my_decimal *, bool);

	uint precision(const class my_decimal  *);

	void swap(class my_decimal *, class my_decimal &);

	int check_result(const class my_decimal  *, uint, int);


	/* size: 64, cachelines: 1, members: 2 */
	/* padding: 4 */

	/* BRAIN FART ALERT! 64 bytes != 36 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Sql_alloc {
public:

	void * operator new(size_t);

	void * operator new [](size_t);

	void * operator new [](size_t, MEM_ROOT *);

	void * operator new(size_t, MEM_ROOT *);

	void operator delete(void *, size_t);

	void operator delete(void *, MEM_ROOT *);

	void operator delete [](void *, MEM_ROOT *);

	void operator delete [](void *, size_t);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
struct st_hash {
	size_t                     key_offset;           /*     0     8 */
	size_t                     key_length;           /*     8     8 */
	size_t                     blength;              /*    16     8 */
	ulong                      records;              /*    24     8 */
	uint                       flags;                /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	DYNAMIC_ARRAY              array;                /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	my_hash_get_key            get_key;              /*    72     8 */
	void                       (*free)(void *);      /*    80     8 */
	CHARSET_INFO *             charset;              /*    88     8 */
	my_hash_function           hash_function;        /*    96     8 */
	PSI_memory_key             m_psi_key;            /*   104     4 */

	/* size: 112, cachelines: 2, members: 11 */
	/* sum members: 104, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
class Atomic_int32 {
public:

	void Atomic_int32(class Atomic_int32 *, int32);

	int32 atomic_get(class Atomic_int32 *);

	void atomic_set(class Atomic_int32 *, int32);

	int32 atomic_add(class Atomic_int32 *, int32);

	int32 atomic_get_and_set(class Atomic_int32 *, int32);

	bool atomic_compare_and_swap(class Atomic_int32 *, int32 *, int32);

	int32 non_atomic_get(class Atomic_int32 *);

	void non_atomic_set(class Atomic_int32 *, int32);

	int32 non_atomic_add(class Atomic_int32 *, int32);

	bool atomic_set_to_max(class Atomic_int32 *, int32, int32 *);

	int32                      value;                /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct st_mysql_show_var {
	const char  *              name;                 /*     0     8 */
	char *                     value;                /*     8     8 */
	enum enum_mysql_show_type  type;                 /*    16     4 */
	enum enum_mysql_show_scope scope;                /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
class Bitmap<64> {
	ulonglong                  map;                  /*     0     8 */
public:

	void Bitmap(class Bitmap<64> *);

	void Bitmap(class Bitmap<64> *, uint);

	void init(class Bitmap<64> *);

	void init(class Bitmap<64> *, uint);

	uint length(const class Bitmap<64>  *);

	void set_bit(class Bitmap<64> *, uint);

	void clear_bit(class Bitmap<64> *, uint);

	void set_prefix(class Bitmap<64> *, uint);

	void set_all(class Bitmap<64> *);

	void clear_all(class Bitmap<64> *);

	void intersect(class Bitmap<64> *, const class Bitmap<64>  &);

	void intersect(class Bitmap<64> *, ulonglong);

	void intersect_extended(class Bitmap<64> *, ulonglong);

	void subtract(class Bitmap<64> *, const class Bitmap<64>  &);

	void merge(class Bitmap<64> *, const class Bitmap<64>  &);

	my_bool is_set(const class Bitmap<64>  *, uint);

	my_bool is_prefix(const class Bitmap<64>  *, uint);

	my_bool is_clear_all(const class Bitmap<64>  *);

	my_bool is_set_all(const class Bitmap<64>  *);

	my_bool is_subset(const class Bitmap<64>  *, const class Bitmap<64>  &);

	my_bool is_overlapping(const class Bitmap<64>  *, const class Bitmap<64>  &);

	my_bool operator==(const class Bitmap<64>  *, const class Bitmap<64>  &);

	my_bool operator!=(const class Bitmap<64>  *, const class Bitmap<64>  &);

	char * print(const class Bitmap<64>  *, char *);

	ulonglong to_ulonglong(const class Bitmap<64>  *);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct system_variables {
	ulong                      dynamic_variables_version; /*     0     8 */
	char *                     dynamic_variables_ptr; /*     8     8 */
	uint                       dynamic_variables_head; /*    16     4 */
	uint                       dynamic_variables_size; /*    20     4 */
	LIST *                     dynamic_variables_allocs; /*    24     8 */
	ulonglong                  max_heap_table_size;  /*    32     8 */
	ulonglong                  tmp_table_size;       /*    40     8 */
	ulonglong                  long_query_time;      /*    48     8 */
	my_bool                    end_markers_in_json;  /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  optimizer_switch;     /*    64     8 */
	ulonglong                  optimizer_trace;      /*    72     8 */
	ulonglong                  optimizer_trace_features; /*    80     8 */
	long int                   optimizer_trace_offset; /*    88     8 */
	long int                   optimizer_trace_limit; /*    96     8 */
	ulong                      optimizer_trace_max_mem_size; /*   104     8 */
	sql_mode_t                 sql_mode;             /*   112     8 */
	ulonglong                  option_bits;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ha_rows                    select_limit;         /*   128     8 */
	ha_rows                    max_join_size;        /*   136     8 */
	ulong                      auto_increment_increment; /*   144     8 */
	ulong                      auto_increment_offset; /*   152     8 */
	ulong                      bulk_insert_buff_size; /*   160     8 */
	uint                       eq_range_index_dive_limit; /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      join_buff_size;       /*   176     8 */
	ulong                      lock_wait_timeout;    /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	ulong                      max_allowed_packet;   /*   192     8 */
	ulong                      max_error_count;      /*   200     8 */
	ulong                      max_length_for_sort_data; /*   208     8 */
	ulong                      max_points_in_geometry; /*   216     8 */
	ulong                      max_sort_length;      /*   224     8 */
	ulong                      max_tmp_tables;       /*   232     8 */
	ulong                      max_insert_delayed_threads; /*   240     8 */
	ulong                      min_examined_row_limit; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	ulong                      multi_range_count;    /*   256     8 */
	ulong                      myisam_repair_threads; /*   264     8 */
	ulong                      myisam_sort_buff_size; /*   272     8 */
	ulong                      myisam_stats_method;  /*   280     8 */
	ulong                      net_buffer_length;    /*   288     8 */
	ulong                      net_interactive_timeout; /*   296     8 */
	ulong                      net_read_timeout;     /*   304     8 */
	ulong                      net_retry_count;      /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	ulong                      net_wait_timeout;     /*   320     8 */
	ulong                      net_write_timeout;    /*   328     8 */
	ulong                      optimizer_prune_level; /*   336     8 */
	ulong                      optimizer_search_depth; /*   344     8 */
	ulonglong                  parser_max_mem_size;  /*   352     8 */
	ulong                      range_optimizer_max_mem_size; /*   360     8 */
	ulong                      preload_buff_size;    /*   368     8 */
	ulong                      profiling_history_size; /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	ulong                      read_buff_size;       /*   384     8 */
	ulong                      read_rnd_buff_size;   /*   392     8 */
	ulong                      div_precincrement;    /*   400     8 */
	ulong                      sortbuff_size;        /*   408     8 */
	ulong                      max_sp_recursion_depth; /*   416     8 */
	ulong                      default_week_format;  /*   424     8 */
	ulong                      max_seeks_for_key;    /*   432     8 */
	ulong                      range_alloc_block_size; /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	ulong                      query_alloc_block_size; /*   448     8 */
	ulong                      query_prealloc_size;  /*   456     8 */
	ulong                      trans_alloc_block_size; /*   464     8 */
	ulong                      trans_prealloc_size;  /*   472     8 */
	ulong                      group_concat_max_len; /*   480     8 */
	ulong                      binlog_format;        /*   488     8 */
	ulong                      rbr_exec_mode_options; /*   496     8 */
	my_bool                    binlog_direct_non_trans_update; /*   504     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 8 boundary (512 bytes) --- */
	ulong                      binlog_row_image;     /*   512     8 */
	my_bool                    sql_log_bin;          /*   520     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      transaction_write_set_extraction; /*   528     8 */
	ulong                      completion_type;      /*   536     8 */
	ulong                      query_cache_type;     /*   544     8 */
	ulong                      tx_isolation;         /*   552     8 */
	ulong                      transaction_isolation; /*   560     8 */
	ulong                      updatable_views_with_limit; /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	uint                       max_user_connections; /*   576     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      my_aes_mode;          /*   584     8 */
	my_thread_id               pseudo_thread_id;     /*   592     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      pseudo_server_id;     /*   600     8 */
	my_bool                    tx_read_only;         /*   608     1 */
	my_bool                    transaction_read_only; /*   609     1 */
	my_bool                    low_priority_updates; /*   610     1 */
	my_bool                    new_mode;             /*   611     1 */
	my_bool                    query_cache_wlock_invalidate; /*   612     1 */
	my_bool                    keep_files_on_create; /*   613     1 */
	my_bool                    online_alter_index;   /*   614     1 */
	my_bool                    old_alter_table;      /*   615     1 */
	uint                       old_passwords;        /*   616     4 */
	my_bool                    big_tables;           /*   620     1 */

	/* XXX 3 bytes hole, try to pack */

	plugin_ref                 table_plugin;         /*   624     8 */
	plugin_ref                 temp_table_plugin;    /*   632     8 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	const CHARSET_INFO  *      character_set_filesystem; /*   640     8 */
	const CHARSET_INFO  *      character_set_client; /*   648     8 */
	const CHARSET_INFO  *      character_set_results; /*   656     8 */
	const CHARSET_INFO  *      collation_server;     /*   664     8 */
	const CHARSET_INFO  *      collation_database;   /*   672     8 */
	const CHARSET_INFO  *      collation_connection; /*   680     8 */
	class MY_LOCALE *          lc_messages;          /*   688     8 */
	class MY_LOCALE *          lc_time_names;        /*   696     8 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	class Time_zone *          time_zone;            /*   704     8 */
	my_bool                    explicit_defaults_for_timestamp; /*   712     1 */
	my_bool                    sysdate_is_now;       /*   713     1 */
	my_bool                    binlog_rows_query_log_events; /*   714     1 */

	/* XXX 5 bytes hole, try to pack */

	ulong                      log_slow_rate_limit;  /*   720     8 */
	ulonglong                  log_slow_filter;      /*   728     8 */
	ulonglong                  log_slow_verbosity;   /*   736     8 */
	ulong                      innodb_io_reads;      /*   744     8 */
	ulonglong                  innodb_io_read;       /*   752     8 */
	uint64_t                   innodb_io_reads_wait_timer; /*   760     8 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	uint64_t                   innodb_lock_que_wait_timer; /*   768     8 */
	uint64_t                   innodb_innodb_que_wait_timer; /*   776     8 */
	ulong                      innodb_page_access;   /*   784     8 */
	double                     long_query_time_double; /*   792     8 */
	my_bool                    pseudo_slave_mode;    /*   800     1 */

	/* XXX 7 bytes hole, try to pack */

	struct Gtid_specification  gtid_next;            /*   808    24 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	struct Gtid_set_or_null    gtid_next_list;       /*   832    16 */

	/* XXX last struct has 7 bytes of padding */

	ulong                      session_track_gtids;  /*   848     8 */
	ulong                      max_execution_time;   /*   856     8 */
	char *                     track_sysvars_ptr;    /*   864     8 */
	my_bool                    session_track_schema; /*   872     1 */
	my_bool                    session_track_state_change; /*   873     1 */
	my_bool                    expand_fast_index_creation; /*   874     1 */

	/* XXX 1 byte hole, try to pack */

	uint                       threadpool_high_prio_tickets; /*   876     4 */
	ulong                      threadpool_high_prio_mode; /*   880     8 */
	ulong                      session_track_transaction_info; /*   888     8 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	my_bool                    show_create_table_verbosity; /*   896     1 */
	my_bool                    show_old_temporals;   /*   897     1 */
	my_bool                    ft_query_extra_word_chars; /*   898     1 */

	/* size: 904, cachelines: 15, members: 126 */
	/* sum members: 850, holes: 10, sum holes: 49 */
	/* padding: 5 */
	/* paddings: 1, sum paddings: 7 */
	/* last cacheline: 8 bytes */
};
struct system_status_var {
	ulonglong                  created_tmp_disk_tables; /*     0     8 */
	ulonglong                  created_tmp_tables;   /*     8     8 */
	ulonglong                  ha_commit_count;      /*    16     8 */
	ulonglong                  ha_delete_count;      /*    24     8 */
	ulonglong                  ha_read_first_count;  /*    32     8 */
	ulonglong                  ha_read_last_count;   /*    40     8 */
	ulonglong                  ha_read_key_count;    /*    48     8 */
	ulonglong                  ha_read_next_count;   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  ha_read_prev_count;   /*    64     8 */
	ulonglong                  ha_read_rnd_count;    /*    72     8 */
	ulonglong                  ha_read_rnd_next_count; /*    80     8 */
	ulonglong                  ha_multi_range_read_init_count; /*    88     8 */
	ulonglong                  ha_rollback_count;    /*    96     8 */
	ulonglong                  ha_update_count;      /*   104     8 */
	ulonglong                  ha_write_count;       /*   112     8 */
	ulonglong                  ha_prepare_count;     /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ulonglong                  ha_discover_count;    /*   128     8 */
	ulonglong                  ha_savepoint_count;   /*   136     8 */
	ulonglong                  ha_savepoint_rollback_count; /*   144     8 */
	ulonglong                  ha_external_lock_count; /*   152     8 */
	ulonglong                  opened_tables;        /*   160     8 */
	ulonglong                  opened_shares;        /*   168     8 */
	ulonglong                  table_open_cache_hits; /*   176     8 */
	ulonglong                  table_open_cache_misses; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	ulonglong                  table_open_cache_overflows; /*   192     8 */
	ulonglong                  select_full_join_count; /*   200     8 */
	ulonglong                  select_full_range_join_count; /*   208     8 */
	ulonglong                  select_range_count;   /*   216     8 */
	ulonglong                  select_range_check_count; /*   224     8 */
	ulonglong                  select_scan_count;    /*   232     8 */
	ulonglong                  long_query_count;     /*   240     8 */
	ulonglong                  filesort_merge_passes; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	ulonglong                  filesort_range_count; /*   256     8 */
	ulonglong                  filesort_rows;        /*   264     8 */
	ulonglong                  filesort_scan_count;  /*   272     8 */
	ulonglong                  com_stmt_prepare;     /*   280     8 */
	ulonglong                  com_stmt_reprepare;   /*   288     8 */
	ulonglong                  com_stmt_execute;     /*   296     8 */
	ulonglong                  com_stmt_send_long_data; /*   304     8 */
	ulonglong                  com_stmt_fetch;       /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	ulonglong                  com_stmt_reset;       /*   320     8 */
	ulonglong                  com_stmt_close;       /*   328     8 */
	ulonglong                  bytes_received;       /*   336     8 */
	ulonglong                  bytes_sent;           /*   344     8 */
	ulonglong                  max_execution_time_exceeded; /*   352     8 */
	ulonglong                  max_execution_time_set; /*   360     8 */
	ulonglong                  max_execution_time_set_failed; /*   368     8 */
	ulonglong                  questions;            /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	ulong                      com_other;            /*   384     8 */
	ulong                      com_stat[150];        /*   392  1200 */
	/* --- cacheline 24 boundary (1536 bytes) was 56 bytes ago --- */
	double                     last_query_cost;      /*  1592     8 */
	/* --- cacheline 25 boundary (1600 bytes) --- */
	ulonglong                  last_query_partial_plans; /*  1600     8 */
	struct fragmentation_stats_t fragmentation_stats; /*  1608    40 */

	/* size: 1648, cachelines: 26, members: 53 */
	/* last cacheline: 48 bytes */
};
struct handlerton {
	enum SHOW_COMP_OPTION      state;                /*     0     4 */
	enum legacy_db_type        db_type;              /*     4     4 */
	uint                       slot;                 /*     8     4 */
	uint                       savepoint_offset;     /*    12     4 */
	int                        (*close_connection)(class handlerton *, class THD *); /*    16     8 */
	void                       (*kill_connection)(class handlerton *, class THD *); /*    24     8 */
	int                        (*savepoint_set)(class handlerton *, class THD *, void *); /*    32     8 */
	int                        (*savepoint_rollback)(class handlerton *, class THD *, void *); /*    40     8 */
	bool                       (*savepoint_rollback_can_release_mdl)(class handlerton *, class THD *); /*    48     8 */
	int                        (*savepoint_release)(class handlerton *, class THD *, void *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        (*commit)(class handlerton *, class THD *, bool); /*    64     8 */
	int                        (*rollback)(class handlerton *, class THD *, bool); /*    72     8 */
	int                        (*prepare)(class handlerton *, class THD *, bool); /*    80     8 */
	int                        (*recover)(class handlerton *, XID *, uint); /*    88     8 */
	int                        (*commit_by_xid)(class handlerton *, XID *); /*    96     8 */
	int                        (*rollback_by_xid)(class handlerton *, XID *); /*   104     8 */
	class handler *            (*create)(class handlerton *, class TABLE_SHARE *, MEM_ROOT *); /*   112     8 */
	void                       (*drop_database)(class handlerton *, char *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        (*panic)(class handlerton *, enum ha_panic_function); /*   128     8 */
	int                        (*start_consistent_snapshot)(class handlerton *, class THD *); /*   136     8 */
	int                        (*clone_consistent_snapshot)(class handlerton *, class THD *, class THD *); /*   144     8 */
	bool                       (*flush_logs)(class handlerton *, bool); /*   152     8 */
	int                        (*store_binlog_info)(class handlerton *, class THD *); /*   160     8 */
	bool                       (*show_status)(class handlerton *, class THD *, stat_print_fn *, enum ha_stat_type); /*   168     8 */
	uint                       (*partition_flags)(void); /*   176     8 */
	int                        (*get_tablespace)(class THD *, LEX_CSTRING, LEX_CSTRING, LEX_CSTRING *); /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        (*alter_tablespace)(class handlerton *, class THD *, class st_alter_tablespace *); /*   192     8 */
	int                        (*fill_is_table)(class handlerton *, class THD *, class TABLE_LIST *, class Item *, enum enum_schema_tables); /*   200     8 */
	my_bool                    (*flush_changed_page_bitmaps)(void); /*   208     8 */
	my_bool                    (*purge_changed_page_bitmaps)(ulonglong); /*   216     8 */
	int                        (*get_parent_fk_list)(class THD *, const char  *, class List<st_foreign_key_info> *); /*   224     8 */
	uint32                     flags;                /*   232     4 */

	/* XXX 4 bytes hole, try to pack */

	int                        (*binlog_func)(class handlerton *, class THD *, enum enum_binlog_func, void *); /*   240     8 */
	void                       (*binlog_log_query)(class handlerton *, class THD *, enum enum_binlog_command, const char  *, uint, const char  *, const char  *); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        (*release_temporary_latches)(class handlerton *, class THD *); /*   256     8 */
	int                        (*discover)(class handlerton *, class THD *, const char  *, const char  *, uchar * *, size_t *); /*   264     8 */
	int                        (*find_files)(class handlerton *, class THD *, const char  *, const char  *, const char  *, bool, class List<st_mysql_lex_string> *); /*   272     8 */
	int                        (*table_exists_in_engine)(class handlerton *, class THD *, const char  *, const char  *); /*   280     8 */
	int                        (*make_pushed_join)(class handlerton *, class THD *, const class Join_plan  *); /*   288     8 */
	const char  *              (*system_database)(void); /*   296     8 */
	bool                       (*is_supported_system_table)(const char  *, const char  *, bool); /*   304     8 */
	class SE_cost_constants *  (*get_cost_constants)(uint); /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	void                       (*replace_native_transaction_in_thd)(class THD *, void *, void * *); /*   320     8 */
	bool                       (*notify_exclusive_mdl)(class THD *, const MDL_key  *, enum ha_notification_type, bool *); /*   328     8 */
	bool                       (*notify_alter_table)(class THD *, const MDL_key  *, enum ha_notification_type); /*   336     8 */
	bool                       (*rotate_encryption_master_key)(void); /*   344     8 */
	bool                       (*is_reserved_db_name)(class handlerton *, const char  *); /*   352     8 */
	bool                       (*fix_tablespaces_empty_uuid)(void); /*   360     8 */
	enum handler_create_zip_dict_result (*create_zip_dict)(class handlerton *, class THD *, const char  *, ulong *, const char  *, ulong *); /*   368     8 */
	enum handler_drop_zip_dict_result (*drop_zip_dict)(class handlerton *, class THD *, const char  *, ulong *); /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint32                     license;              /*   384     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     data;                 /*   392     8 */

	/* size: 400, cachelines: 7, members: 52 */
	/* sum members: 392, holes: 2, sum holes: 8 */
	/* last cacheline: 16 bytes */
};
struct my_option {
	const char  *              name;                 /*     0     8 */
	int                        id;                   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              comment;              /*    16     8 */
	void *                     value;                /*    24     8 */
	void *                     u_max_value;          /*    32     8 */
	class st_typelib *         typelib;              /*    40     8 */
	ulong                      var_type;             /*    48     8 */
	enum get_opt_arg_type      arg_type;             /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	longlong                   def_value;            /*    64     8 */
	longlong                   min_value;            /*    72     8 */
	ulonglong                  max_value;            /*    80     8 */
	longlong                   sub_size;             /*    88     8 */
	long int                   block_size;           /*    96     8 */
	void *                     app_type;             /*   104     8 */

	/* size: 112, cachelines: 2, members: 14 */
	/* sum members: 104, holes: 2, sum holes: 8 */
	/* last cacheline: 48 bytes */
};
struct st_VioSSLFd {
	SSL_CTX *                  ssl_context;          /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Security_context {
public:

	void Security_context(class Security_context *);

	void ~Security_context(class Security_context *, int);

	void Security_context(class Security_context *, const class Security_context  &);

	class Security_context & operator=(class Security_context *, const class Security_context  &);

	void skip_grants(class Security_context *);

	LEX_CSTRING user(const class Security_context  *);

	void set_user_ptr(class Security_context *, const char  *, int);

	void assign_user(class Security_context *, const char  *, int);

	LEX_CSTRING host(const class Security_context  *);

	void set_host_ptr(class Security_context *, const char  *, int);

	void assign_host(class Security_context *, const char  *, int);

	LEX_CSTRING ip(const class Security_context  *);

	void set_ip_ptr(class Security_context *, const char  *, int);

	void assign_ip(class Security_context *, const char  *, int);

	LEX_CSTRING host_or_ip(const class Security_context  *);

	void set_host_or_ip_ptr(class Security_context *);

	void set_host_or_ip_ptr(class Security_context *, const char  *, int);

	LEX_CSTRING external_user(const class Security_context  *);

	void set_external_user_ptr(class Security_context *, const char  *, int);

	void assign_external_user(class Security_context *, const char  *, int);

	LEX_CSTRING priv_user(const class Security_context  *);

	void assign_priv_user(class Security_context *, const char  *, size_t);

	LEX_CSTRING proxy_user(const class Security_context  *);

	void assign_proxy_user(class Security_context *, const char  *, size_t);

	LEX_CSTRING priv_host(const class Security_context  *);

	void assign_priv_host(class Security_context *, const char  *, size_t);

	const char  * priv_host_name(const class Security_context  *);

	ulong master_access(const class Security_context  *);

	void set_master_access(class Security_context *, ulong);

	bool has_account_assigned(const class Security_context  *);

	bool check_access(class Security_context *, ulong, bool);

	ulong db_access(const class Security_context  *);

	void set_db_access(class Security_context *, ulong);

	bool password_expired(const class Security_context  *);

	void set_password_expired(class Security_context *, bool);

	bool change_security_context(class Security_context *, class THD *, const LEX_CSTRING  &, const LEX_CSTRING  &, LEX_STRING *, class Security_context * *);

	void restore_security_context(class Security_context *, class THD *, class Security_context *);

	bool user_matches(class Security_context *, class Security_context *);

	void init(class Security_context *);

	void destroy(class Security_context *);

	void copy_security_ctx(class Security_context *, const class Security_context  &);

	class String              m_user;                /*     0    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_host;                /*    32    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) --- */
	class String              m_ip;                  /*    64    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_host_or_ip;          /*    96    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) --- */
	class String              m_external_user;       /*   128    32 */

	/* XXX last struct has 3 bytes of padding */

	char                       m_priv_user[96];      /*   160    96 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	size_t                     m_priv_user_length;   /*   256     8 */
	char                       m_proxy_user[162];    /*   264   162 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 6 boundary (384 bytes) was 48 bytes ago --- */
	size_t                     m_proxy_user_length;  /*   432     8 */
	char                       m_priv_host[61];      /*   440    61 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 7 boundary (448 bytes) was 56 bytes ago --- */
	size_t                     m_priv_host_length;   /*   504     8 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	ulong                      m_master_access;      /*   512     8 */
	ulong                      m_db_access;          /*   520     8 */
	bool                       m_password_expired;   /*   528     1 */

	/* size: 536, cachelines: 9, members: 14 */
	/* sum members: 520, holes: 2, sum holes: 9 */
	/* padding: 7 */
	/* paddings: 5, sum paddings: 15 */
	/* last cacheline: 24 bytes */
};
class MY_LOCALE_ERRMSGS {
	const char  *              language;             /*     0     8 */
	const char  * *            errmsgs;              /*     8     8 */
public:

	void MY_LOCALE_ERRMSGS(class MY_LOCALE_ERRMSGS *, const char  *);

	const char  * lookup(class MY_LOCALE_ERRMSGS *, int);

	bool is_loaded(const class MY_LOCALE_ERRMSGS  *);

	void destroy(class MY_LOCALE_ERRMSGS *);

	bool read_texts(class MY_LOCALE_ERRMSGS *);

	const char  * get_language(const class MY_LOCALE_ERRMSGS  *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Discrete_interval {
	ulonglong                  interval_min;         /*     0     8 */
	ulonglong                  interval_values;      /*     8     8 */
	ulonglong                  interval_max;         /*    16     8 */
public:

	class Discrete_interval *  next;                 /*    24     8 */
	bool in_range(const class Discrete_interval  *, ulonglong);

	void replace(class Discrete_interval *, ulonglong, ulonglong, ulonglong);

	void Discrete_interval(class Discrete_interval *, ulonglong, ulonglong, ulonglong);

	void Discrete_interval(class Discrete_interval *);

	ulonglong minimum(const class Discrete_interval  *);

	ulonglong values(const class Discrete_interval  *);

	ulonglong maximum(const class Discrete_interval  *);

	bool merge_if_contiguous(class Discrete_interval *, ulonglong, ulonglong, ulonglong);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Discrete_intervals_list {
	class Discrete_interval   first_interval;        /*     0    32 */
	class Discrete_interval *  head;                 /*    32     8 */
	class Discrete_interval *  tail;                 /*    40     8 */
	class Discrete_interval *  current;              /*    48     8 */
	uint                       elements;             /*    56     4 */
	void operator=(class Discrete_intervals_list *, class Discrete_intervals_list &);

	bool append(class Discrete_intervals_list *, class Discrete_interval *);

	void copy_shallow(class Discrete_intervals_list *, const class Discrete_intervals_list  *);

	void Discrete_intervals_list(class Discrete_intervals_list *, const class Discrete_intervals_list  &);

public:

	void Discrete_intervals_list(class Discrete_intervals_list *);

	void empty(class Discrete_intervals_list *);

	void swap(class Discrete_intervals_list *, class Discrete_intervals_list *);

	const class Discrete_interval  * get_next(class Discrete_intervals_list *);

	void ~Discrete_intervals_list(class Discrete_intervals_list *, int);

	bool append(class Discrete_intervals_list *, ulonglong, ulonglong, ulonglong);

	ulonglong minimum(const class Discrete_intervals_list  *);

	ulonglong maximum(const class Discrete_intervals_list  *);

	uint nb_elements(const class Discrete_intervals_list  *);


	/* size: 64, cachelines: 1, members: 5 */
	/* padding: 4 */
};
struct st_list {
	class st_list *            prev;                 /*     0     8 */
	class st_list *            next;                 /*     8     8 */
	void *                     data;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct st_thr_lock_info {
	my_thread_id               thread_id;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	mysql_cond_t *             suspend;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct st_thr_lock_data {
	THR_LOCK_INFO *            owner;                /*     0     8 */
	class st_thr_lock_data *   next;                 /*     8     8 */
	class st_thr_lock_data * * prev;                 /*    16     8 */
	class st_thr_lock *        lock;                 /*    24     8 */
	mysql_cond_t *             cond;                 /*    32     8 */
	enum thr_lock_type         type;                 /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     status_param;         /*    48     8 */
	void *                     debug_print_param;    /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class PSI_table *          m_psi;                /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* sum members: 68, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct st_thr_lock {
	LIST                       list;                 /*     0    24 */
	mysql_mutex_t              mutex;                /*    24    48 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	struct st_lock_list        read_wait;            /*    72    16 */
	struct st_lock_list        read;                 /*    88    16 */
	struct st_lock_list        write_wait;           /*   104    16 */
	struct st_lock_list        write;                /*   120    16 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	ulong                      write_lock_count;     /*   136     8 */
	uint                       read_no_write_count;  /*   144     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*get_status)(void *, int); /*   152     8 */
	void                       (*copy_status)(void *, void *); /*   160     8 */
	void                       (*update_status)(void *); /*   168     8 */
	void                       (*restore_status)(void *); /*   176     8 */
	my_bool                    (*check_status)(void *); /*   184     8 */

	/* size: 192, cachelines: 3, members: 13 */
	/* sum members: 188, holes: 1, sum holes: 4 */
};
struct st_lock_list {
	THR_LOCK_DATA *            data;                 /*     0     8 */
	THR_LOCK_DATA * *          last;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_plugin_int {
	LEX_STRING                 name;                 /*     0    16 */
	class st_mysql_plugin *    plugin;               /*    16     8 */
	class st_plugin_dl *       plugin_dl;            /*    24     8 */
	uint                       state;                /*    32     4 */
	uint                       ref_count;            /*    36     4 */
	void *                     data;                 /*    40     8 */
	MEM_ROOT                   mem_root;             /*    48    88 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	class sys_var *            system_vars;          /*   136     8 */
	enum enum_plugin_load_option load_option;        /*   144     4 */

	/* size: 152, cachelines: 3, members: 9 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct st_mysql_plugin {
	int                        type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     info;                 /*     8     8 */
	const char  *              name;                 /*    16     8 */
	const char  *              author;               /*    24     8 */
	const char  *              descr;                /*    32     8 */
	int                        license;              /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	int                        (*init)(MYSQL_PLUGIN); /*    48     8 */
	int                        (*deinit)(MYSQL_PLUGIN); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned int               version;              /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	class st_mysql_show_var *  status_vars;          /*    72     8 */
	class st_mysql_sys_var * * system_vars;          /*    80     8 */
	void *                     __reserved1;          /*    88     8 */
	long unsigned int          flags;                /*    96     8 */

	/* size: 104, cachelines: 2, members: 13 */
	/* sum members: 92, holes: 3, sum holes: 12 */
	/* last cacheline: 40 bytes */
};
struct st_plugin_dl {
	LEX_STRING                 dl;                   /*     0    16 */
	void *                     handle;               /*    16     8 */
	class st_mysql_plugin *    plugins;              /*    24     8 */
	int                        version;              /*    32     4 */
	uint                       ref_count;            /*    36     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct my_aligned_storage<16, 8> {
	union {
		char                       data[16];             /*     0    16 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[16];             /*     0    16 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* forced alignments: 1 */
	/* last cacheline: 16 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<st_plugin_int*, 2, true> {
	class st_plugin_int * * cast_rawbuff(class Prealloced_array<st_plugin_int*, 2, true> *);

public:

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2, true> *, const class Prealloced_array<st_plugin_int*, 2, true>  &);

	void Prealloced_array(class Prealloced_array<st_plugin_int*, 2, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class st_plugin_int * const * const_iterator;

	class Prealloced_array<st_plugin_int*, 2, true> & operator=(class Prealloced_array<st_plugin_int*, 2, true> *, const class Prealloced_array<st_plugin_int*, 2, true>  &);

	void ~Prealloced_array(class Prealloced_array<st_plugin_int*, 2, true> *, int);

	size_t capacity(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	size_t element_size(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	bool empty(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	size_t size(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	class st_plugin_int * & at(class Prealloced_array<st_plugin_int*, 2, true> *, size_t);

	class st_plugin_int * const & at(const class Prealloced_array<st_plugin_int*, 2, true>  *, size_t);

	class st_plugin_int * & operator[](class Prealloced_array<st_plugin_int*, 2, true> *, size_t);

	class st_plugin_int * const & operator[](const class Prealloced_array<st_plugin_int*, 2, true>  *, size_t);

	class st_plugin_int * & back(class Prealloced_array<st_plugin_int*, 2, true> *);

	class st_plugin_int * const & back(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	class st_plugin_int * & front(class Prealloced_array<st_plugin_int*, 2, true> *);

	class st_plugin_int * const & front(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	typedef class st_plugin_int * * iterator;

	iterator begin(class Prealloced_array<st_plugin_int*, 2, true> *);

	iterator end(class Prealloced_array<st_plugin_int*, 2, true> *);

	const_iterator begin(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	const_iterator end(const class Prealloced_array<st_plugin_int*, 2, true>  *);

	bool reserve(class Prealloced_array<st_plugin_int*, 2, true> *, size_t);

	bool push_back(class Prealloced_array<st_plugin_int*, 2, true> *, class st_plugin_int * const &);

	void pop_back(class Prealloced_array<st_plugin_int*, 2, true> *);

	iterator insert(class Prealloced_array<st_plugin_int*, 2, true> *, iterator, const value_type  &);

	typedef class st_plugin_int * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<st_plugin_int**, bool> insert_unique(class Prealloced_array<st_plugin_int*, 2, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<st_plugin_int*, 2, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<st_plugin_int*, 2, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<st_plugin_int*, 2, true> *, iterator);

	iterator erase(class Prealloced_array<st_plugin_int*, 2, true> *, size_t);

	void erase_at_end(class Prealloced_array<st_plugin_int*, 2, true> *, iterator);

	iterator erase(class Prealloced_array<st_plugin_int*, 2, true> *, iterator, iterator);

	void swap(class Prealloced_array<st_plugin_int*, 2, true> *, class Prealloced_array<st_plugin_int*, 2, true> &);

	void shrink_to_fit(class Prealloced_array<st_plugin_int*, 2, true> *);

	void resize(class Prealloced_array<st_plugin_int*, 2, true> *, size_t, class st_plugin_int * const &);

	void clear(class Prealloced_array<st_plugin_int*, 2, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<16, 8> m_buff __attribute__((__aligned__(8))); /*    16    16 */
	class st_plugin_int * *    m_array_ptr;          /*    32     8 */
	PSI_memory_key             m_psi_key;            /*    40     4 */

	/* size: 48, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
class Plugin_array : public Prealloced_array<st_plugin_int*, 2, true> {
public:

	/* class Prealloced_array<st_plugin_int*, 2, true> <ancestor>; */ /*     0    48 */

	/* XXX last struct has 4 bytes of padding */
	void Plugin_array(class Plugin_array *, PSI_memory_key);

	bool exists(class Plugin_array *, plugin_ref);

	void ~Plugin_array(class Plugin_array *, int);


	/* size: 48, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 48 bytes */

	/* BRAIN FART ALERT! 48 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 384 bits */
} __attribute__((__aligned__(8)));
class KEY_PART_INFO {
public:

	class Field *              field;                /*     0     8 */
	uint                       offset;               /*     8     4 */
	uint                       null_offset;          /*    12     4 */
	uint16                     length;               /*    16     2 */
	uint16                     store_length;         /*    18     2 */
	uint16                     key_type;             /*    20     2 */
	uint16                     fieldnr;              /*    22     2 */
	uint16                     key_part_flag;        /*    24     2 */
	uint8                      type;                 /*    26     1 */
	uint8                      null_bit;             /*    27     1 */
	void init_from_field(class KEY_PART_INFO *, class Field *);

	void init_flags(class KEY_PART_INFO *);


	/* size: 32, cachelines: 1, members: 10 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct st_key {
	union {
		plugin_ref                 parser;               /*     0     8 */
		LEX_STRING *               parser_name;          /*     0     8 */
	};

	union {
		int                        bdb_return_if_eq;     /*     0     4 */
	};

	uint                       key_length;           /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      flags;                /*     8     8 */
	ulong                      actual_flags;         /*    16     8 */
	uint                       user_defined_key_parts; /*    24     4 */
	uint                       actual_key_parts;     /*    28     4 */
	uint                       unused_key_parts;     /*    32     4 */
	uint                       usable_key_parts;     /*    36     4 */
	uint                       block_size;           /*    40     4 */
	enum ha_key_alg            algorithm;            /*    44     4 */
	union {
		plugin_ref         parser;               /*    48     8 */
		LEX_STRING *       parser_name;          /*    48     8 */
	};                                               /*    48     8 */
	class KEY_PART_INFO *      key_part;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     name;                 /*    64     8 */
	ulong *                    rec_per_key;          /*    72     8 */
private:

	double                     m_in_memory_estimate; /*    80     8 */
	rec_per_key_t *            rec_per_key_float;    /*    88     8 */
	union {
		int                bdb_return_if_eq;     /*    96     4 */
	} handler;                                       /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	class TABLE *              table;                /*   104     8 */
	LEX_STRING                 comment;              /*   112    16 */
	bool has_records_per_key(const class st_key  *, uint);

	rec_per_key_t records_per_key(const class st_key  *, uint);

	void set_records_per_key(class st_key *, uint, rec_per_key_t);

	bool supports_records_per_key(const class st_key  *);

	void set_rec_per_key_array(class st_key *, ulong *, rec_per_key_t *);

	double in_memory_estimate(const class st_key  *);

	void set_in_memory_estimate(class st_key *, double);


	/* size: 128, cachelines: 2, members: 18 */
	/* sum members: 120, holes: 2, sum holes: 8 */
};
struct TABLE {
	struct {
		class JOIN_TAB *           join_tab;             /*     0     8 */
		class QEP_TAB *            qep_tab;              /*     8     8 */
		enum thr_lock_type         lock_type;            /*    16     4 */
		bool                       not_exists_optimize;  /*    20     1 */
		bool                       impossible_range;     /*    21     1 */

		/* size: 24, cachelines: 1, members: 5 */
		/* padding: 2 */
		/* last cacheline: 24 bytes */
	};

	void TABLE(class TABLE *);

	class TABLE_SHARE *        s;                    /*     0     8 */
	class handler *            file;                 /*     8     8 */
	class TABLE *              next;                 /*    16     8 */
	class TABLE *              prev;                 /*    24     8 */
private:

	class TABLE *              cache_next;           /*    32     8 */
	class TABLE * *            cache_prev;           /*    40     8 */
	class THD *                in_use;               /*    48     8 */
	class Field * *            field;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint                       hidden_field_count;   /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	uchar *                    record[2];            /*    72    16 */
	uchar *                    write_row_record;     /*    88     8 */
	uchar *                    insert_values;        /*    96     8 */
	key_map                    covering_keys;        /*   104     8 */
	key_map                    quick_keys;           /*   112     8 */
	key_map                    merge_keys;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	key_map                    possible_quick_keys;  /*   128     8 */
	key_map                    keys_in_use_for_query; /*   136     8 */
	key_map                    keys_in_use_for_group_by; /*   144     8 */
	key_map                    keys_in_use_for_order_by; /*   152     8 */
	KEY *                      key_info;             /*   160     8 */
	class Field *              next_number_field;    /*   168     8 */
	class Field *              found_next_number_field; /*   176     8 */
	class Field * *            vfield;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	class Field *              hash_field;           /*   192     8 */
	class Field *              fts_doc_id_field;     /*   200     8 */
	class Table_trigger_dispatcher * triggers;       /*   208     8 */
	class TABLE_LIST *         pos_in_table_list;    /*   216     8 */
	class TABLE_LIST *         pos_in_locked_tables; /*   224     8 */
	ORDER *                    group;                /*   232     8 */
	const char  *              alias;                /*   240     8 */
	uchar *                    null_flags;           /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	my_bitmap_map *            bitmap_init_value;    /*   256     8 */
	MY_BITMAP                  def_read_set;         /*   264    32 */
	MY_BITMAP                  def_write_set;        /*   296    32 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	MY_BITMAP                  tmp_set;              /*   328    32 */
	MY_BITMAP                  cond_set;             /*   360    32 */
	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
	MY_BITMAP                  def_fields_set_during_insert; /*   392    32 */
	MY_BITMAP *                read_set;             /*   424     8 */
	MY_BITMAP *                write_set;            /*   432     8 */
	MY_BITMAP *                fields_set_during_insert; /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	query_id_t                 query_id;             /*   448     8 */
	ha_rows                    quick_rows[64];       /*   456   512 */
	/* --- cacheline 15 boundary (960 bytes) was 8 bytes ago --- */
	key_part_map               const_key_parts[64];  /*   968   512 */
	/* --- cacheline 23 boundary (1472 bytes) was 8 bytes ago --- */
	uint                       quick_key_parts[64];  /*  1480   256 */
	/* --- cacheline 27 boundary (1728 bytes) was 8 bytes ago --- */
	uint                       quick_n_ranges[64];   /*  1736   256 */
	/* --- cacheline 31 boundary (1984 bytes) was 8 bytes ago --- */
	ha_rows                    quick_condition_rows; /*  1992     8 */
	uint                       lock_position;        /*  2000     4 */
	uint                       lock_data_start;      /*  2004     4 */
	uint                       lock_count;           /*  2008     4 */
	uint                       temp_pool_slot;       /*  2012     4 */
	uint                       db_stat;              /*  2016     4 */
	int                        current_lock;         /*  2020     4 */
	my_bool                    nullable;             /*  2024     1 */
	my_bool                    null_row;             /*  2025     1 */
	uint8                      status;               /*  2026     1 */
	my_bool                    copy_blobs;           /*  2027     1 */
	my_bool                    force_index;          /*  2028     1 */
	my_bool                    force_index_order;    /*  2029     1 */
	my_bool                    force_index_group;    /*  2030     1 */
	my_bool                    distinct;             /*  2031     1 */
	my_bool                    const_table;          /*  2032     1 */
	my_bool                    no_rows;              /*  2033     1 */
	my_bool                    key_read;             /*  2034     1 */
	my_bool                    no_keyread;           /*  2035     1 */
	my_bool                    locked_by_logger;     /*  2036     1 */
	my_bool                    no_replicate;         /*  2037     1 */
	my_bool                    locked_by_name;       /*  2038     1 */
	my_bool                    fulltext_searched;    /*  2039     1 */
	my_bool                    no_cache;             /*  2040     1 */
	my_bool                    open_by_handler;      /*  2041     1 */
	my_bool                    auto_increment_field_not_null; /*  2042     1 */
	my_bool                    insert_or_update;     /*  2043     1 */
	my_bool                    alias_name_used;      /*  2044     1 */
	my_bool                    get_fields_in_item_tree; /*  2045     1 */
	my_bool                    m_needs_reopen;       /*  2046     1 */
	bool                       created;              /*  2047     1 */
	/* --- cacheline 32 boundary (2048 bytes) --- */
	uint                       max_keys;             /*  2048     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		class JOIN_TAB *   join_tab;             /*  2056     8 */
		class QEP_TAB *    qep_tab;              /*  2064     8 */
		enum thr_lock_type lock_type;            /*  2072     4 */
		bool               not_exists_optimize;  /*  2076     1 */
		bool               impossible_range;     /*  2077     1 */
	} reginfo;                                       /*  2056    24 */

	/* XXX last struct has 2 bytes of padding */

	MEM_ROOT                   mem_root;             /*  2080    88 */
	/* --- cacheline 33 boundary (2112 bytes) was 56 bytes ago --- */
	class Blob_mem_storage *   blob_storage;         /*  2168     8 */
	/* --- cacheline 34 boundary (2176 bytes) --- */
	struct GRANT_INFO          grant;                /*  2176    56 */
	class Filesort_info       sort;                  /*  2232   128 */
	/* --- cacheline 36 boundary (2304 bytes) was 56 bytes ago --- */
	class partition_info *     part_info;            /*  2360     8 */
	/* --- cacheline 37 boundary (2368 bytes) --- */
	bool                       all_partitions_pruned_away; /*  2368     1 */

	/* XXX 7 bytes hole, try to pack */

	class MDL_ticket *         mdl_ticket;           /*  2376     8 */
	class Cost_model_table    m_cost_model;          /*  2384    24 */
	void init(class TABLE *, class THD *, class TABLE_LIST *);

	bool fill_item_list(const class TABLE  *, class List<Item> *);

	void reset_item_list(const class TABLE  *, class List<Item> *);

	void clear_column_bitmaps(class TABLE *);

	void prepare_for_position(class TABLE *);

	void mark_column_used(class TABLE *, class THD *, class Field *, enum enum_mark_columns);

	void mark_columns_used_by_index_no_reset(class TABLE *, uint, MY_BITMAP *, uint);

	void mark_columns_used_by_index(class TABLE *, uint);

	void mark_auto_increment_column(class TABLE *);

	void mark_columns_needed_for_update(class TABLE *, bool);

	void mark_columns_needed_for_delete(class TABLE *);

	void mark_columns_needed_for_insert(class TABLE *);

	void mark_columns_per_binlog_row_image(class TABLE *);

	void mark_generated_columns(class TABLE *, bool);

	bool is_field_used_by_generated_columns(class TABLE *, uint);

	void mark_gcol_in_maps(class TABLE *, class Field *);

	void column_bitmaps_set(class TABLE *, MY_BITMAP *, MY_BITMAP *);

	void column_bitmaps_set_no_signal(class TABLE *, MY_BITMAP *, MY_BITMAP *);

	void use_all_columns(class TABLE *);

	void default_column_bitmaps(class TABLE *);

	bool needs_reopen(class TABLE *);

	class Field * * visible_field_ptr(const class TABLE  *);

	uint visible_field_count(const class TABLE  *);

	bool alloc_keys(class TABLE *, uint);

	bool add_tmp_key(class TABLE *, Field_map *, char *);

	void use_index(class TABLE *, int);

	void set_keyread(class TABLE *, bool);

	bool index_contains_some_virtual_gcol(class TABLE *, uint);

	bool update_const_key_parts(class TABLE *, class Item *);

	bool check_read_removal(class TABLE *, uint);

	my_ptrdiff_t default_values_offset(const class TABLE  *);

	bool is_created(const class TABLE  *);

	void set_created(class TABLE *);

	void set_deleted(class TABLE *);

	void set_nullable(class TABLE *);

	bool is_nullable(const class TABLE  *);

	bool has_gcol(const class TABLE  *);

	bool has_virtual_gcol(const class TABLE  *);

	void set_null_row(class TABLE *);

	void reset_null_row(class TABLE *);

	bool has_null_row(const class TABLE  *);

	void init_cost_model(class TABLE *, const class Cost_model_server  *);

	const class Cost_model_table  * cost_model(const class TABLE  *);

	bool refix_gc_items(class TABLE *, class THD *);

	void cleanup_gc_items(class TABLE *);

	bool has_compressed_columns(const class TABLE  *);

	bool has_compressed_columns_with_dictionaries(const class TABLE  *);

	void update_compressed_columns_info(class TABLE *, const class List<Create_field>  &);

	bool contains_records(class TABLE *, class THD *, bool *);

	bool                       should_binlog_drop_if_temp_flag; /*  2408     1 */
	void blobs_need_not_keep_old_value(class TABLE *);

	void set_binlog_drop_if_temp(class TABLE *, bool);

	bool should_binlog_drop_if_temp(const class TABLE  *);


	/* size: 2416, cachelines: 38, members: 87 */
	/* sum members: 2394, holes: 3, sum holes: 15 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 2 */
	/* last cacheline: 48 bytes */
};
struct list_node : Sql_alloc {
	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class list_node *          next;                 /*     0     8 */
	void *                     info;                 /*     8     8 */
	void list_node(class list_node *, void *, class list_node *);

	void list_node(class list_node *);


	/* size: 16, cachelines: 1, members: 3 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 16 bytes */
};
class base_list : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
protected:


	class list_node *          first;                /*     0     8 */
	class list_node * *        last;                 /*     8     8 */
public:

	uint                       elements;             /*    16     4 */
	bool operator==(const class base_list  *, const class base_list  &);

	void empty(class base_list *);

	void base_list(class base_list *);

	void base_list(class base_list *, const class base_list  &);

	class base_list & operator=(class base_list *, const class base_list  &);

	void base_list(class base_list *, const class base_list  &, MEM_ROOT *);

	void base_list(class base_list *, bool);

	bool push_back(class base_list *, void *);

	bool push_back(class base_list *, void *, MEM_ROOT *);

	bool push_front(class base_list *, void *);

	bool push_front(class base_list *, void *, MEM_ROOT *);

	void remove(class base_list *, class list_node * *);

	void concat(class base_list *, class base_list *);

	void * pop(class base_list *);

	void disjoin(class base_list *, class base_list *);

	void prepand(class base_list *, class base_list *);

	void sort(class base_list *, Node_cmp_func, void *);

	void swap(class base_list *, class base_list &);

	class list_node * last_node(class base_list *);

	class list_node * first_node(class base_list *);

	void * head(class base_list *);

	void * * head_ref(class base_list *);

	bool is_empty(const class base_list  *);

	class list_node * last_ref(class base_list *);

protected:

	void after(class base_list *, void *, class list_node *);

	bool after(class base_list *, void *, class list_node *, MEM_ROOT *);


	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
class base_list_iterator {
protected:

	class base_list *          list;                 /*     0     8 */
	class list_node * *        el;                   /*     8     8 */
	class list_node * *        prev;                 /*    16     8 */
	class list_node *          current;              /*    24     8 */
	void sublist(class base_list_iterator *, class base_list &, uint);

public:

	void base_list_iterator(class base_list_iterator *);

	void base_list_iterator(class base_list_iterator *, class base_list &);

	void init(class base_list_iterator *, class base_list &);

	void * next(class base_list_iterator *);

	void * next_fast(class base_list_iterator *);

	void rewind(class base_list_iterator *);

	void * replace(class base_list_iterator *, void *);

	void * replace(class base_list_iterator *, class base_list &);

	void remove(class base_list_iterator *);

	void after(class base_list_iterator *, void *);

	bool after(class base_list_iterator *, void *, MEM_ROOT *);

	void * * ref(class base_list_iterator *);

	bool is_last(class base_list_iterator *);

	bool is_before_first(const class base_list_iterator  *);

	bool prepend(class base_list_iterator *, void *, MEM_ROOT *);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct lconv {
	char *                     decimal_point;        /*     0     8 */
	char *                     thousands_sep;        /*     8     8 */
	char *                     grouping;             /*    16     8 */
	char *                     int_curr_symbol;      /*    24     8 */
	char *                     currency_symbol;      /*    32     8 */
	char *                     mon_decimal_point;    /*    40     8 */
	char *                     mon_thousands_sep;    /*    48     8 */
	char *                     mon_grouping;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     positive_sign;        /*    64     8 */
	char *                     negative_sign;        /*    72     8 */
	char                       int_frac_digits;      /*    80     1 */
	char                       frac_digits;          /*    81     1 */
	char                       p_cs_precedes;        /*    82     1 */
	char                       p_sep_by_space;       /*    83     1 */
	char                       n_cs_precedes;        /*    84     1 */
	char                       n_sep_by_space;       /*    85     1 */
	char                       p_sign_posn;          /*    86     1 */
	char                       n_sign_posn;          /*    87     1 */
	char                       int_p_cs_precedes;    /*    88     1 */
	char                       int_p_sep_by_space;   /*    89     1 */
	char                       int_n_cs_precedes;    /*    90     1 */
	char                       int_n_sep_by_space;   /*    91     1 */
	char                       int_p_sign_posn;      /*    92     1 */
	char                       int_n_sign_posn;      /*    93     1 */

	/* size: 96, cachelines: 2, members: 24 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
struct xid_t {
private:

	static const uint                 MYSQL_XID_PREFIX_LEN = 8; /*     0     0 */
	static const uint                 MYSQL_XID_OFFSET = 16; /*     0     0 */
	static const uint                 MYSQL_XID_GTRID_LEN = 24; /*     0     0 */
	long int                   formatID;             /*     0     8 */
	long int                   gtrid_length;         /*     8     8 */
	long int                   bqual_length;         /*    16     8 */
	char                       data[128];            /*    24   128 */
	void xid_t(class xid_t *);

	long int get_format_id(const class xid_t  *);

	void set_format_id(class xid_t *, long int);

	long int get_gtrid_length(const class xid_t  *);

	void set_gtrid_length(class xid_t *, long int);

	long int get_bqual_length(const class xid_t  *);

	void set_bqual_length(class xid_t *, long int);

	const char  * get_data(const class xid_t  *);

	void set_data(class xid_t *, const void  *, long int);

	void reset(class xid_t *);

	void set(class xid_t *, long int, const char  *, long int, const char  *, long int);

	my_xid get_my_xid(const class xid_t  *);

	uchar * key(class xid_t *);

	const uchar  * key(const class xid_t  *);

	uint key_length(const class xid_t  *);


	/* Bitfield combined with previous fields */

	static const uint                 ser_buf_size = 297; /*     0     0 */
	char * serialize(const class xid_t  *, char *);

	bool eq(const class xid_t  *, const class xid_t  *);

	bool is_null(const class xid_t  *);

	void set(class xid_t *, const class xid_t  *);

	void set(class xid_t *, my_xid);

	void null(class xid_t *);


	/* size: 152, cachelines: 3, members: 4, static members: 4 */
	/* last cacheline: 24 bytes */
};
class st_alter_tablespace : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	const char  *              tablespace_name;      /*     0     8 */
	const char  *              logfile_group_name;   /*     8     8 */
	enum ts_command_type       ts_cmd_type;          /*    16     4 */
	enum ts_alter_tablespace_type ts_alter_tablespace_type; /*    20     4 */
	const char  *              data_file_name;       /*    24     8 */
	const char  *              undo_file_name;       /*    32     8 */
	const char  *              redo_file_name;       /*    40     8 */
	ulonglong                  extent_size;          /*    48     8 */
	ulonglong                  undo_buffer_size;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulonglong                  redo_buffer_size;     /*    64     8 */
	ulonglong                  initial_size;         /*    72     8 */
	ulonglong                  autoextend_size;      /*    80     8 */
	ulonglong                  max_size;             /*    88     8 */
	ulonglong                  file_block_size;      /*    96     8 */
	uint                       nodegroup_id;         /*   104     4 */

	/* XXX 4 bytes hole, try to pack */

	class handlerton *         storage_engine;       /*   112     8 */
	bool                       wait_until_completed; /*   120     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	const char  *              ts_comment;           /*   128     8 */
	enum tablespace_access_mode ts_access_mode;      /*   136     4 */
	bool                       encrypt;              /*   140     1 */

	/* XXX 3 bytes hole, try to pack */

	LEX_STRING                 encrypt_type;         /*   144    16 */
	bool is_tablespace_command(class st_alter_tablespace *);

	void st_alter_tablespace(class st_alter_tablespace *);


	/* size: 160, cachelines: 3, members: 22 */
	/* sum members: 146, holes: 3, sum holes: 14 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 32 bytes */
};
struct TABLE_LIST {
	enum {
		OPEN_NORMAL     = 0,
		OPEN_IF_EXISTS  = 1,
		OPEN_FOR_CREATE = 2,
		OPEN_STUB       = 3,
	};

	void TABLE_LIST(class TABLE_LIST *);

	void init_one_table(class TABLE_LIST *, const char  *, size_t, const char  *, size_t, const char  *, enum thr_lock_type, enum enum_mdl_type);

	void init_one_table(class TABLE_LIST *, const char  *, size_t, const char  *, size_t, const char  *, enum thr_lock_type);

	class TABLE_LIST * new_nested_join(MEM_ROOT *, const char  *, class TABLE_LIST *, class List<TABLE_LIST> *, class st_select_lex *);

	class Item * * join_cond_ref(class TABLE_LIST *);

	class Item * join_cond(const class TABLE_LIST  *);

	void set_join_cond(class TABLE_LIST *, class Item *);

	class Item * join_cond_optim(const class TABLE_LIST  *);

	void set_join_cond_optim(class TABLE_LIST *, class Item *);

	class Item * * join_cond_optim_ref(class TABLE_LIST *);

	class Item * sj_cond(const class TABLE_LIST  *);

	void set_sj_cond(class TABLE_LIST *, class Item *);

	bool merge_underlying_tables(class TABLE_LIST *, class st_select_lex *);

	void reset(class TABLE_LIST *);

	void calc_md5(class TABLE_LIST *, char *);

	int view_check_option(const class TABLE_LIST  *, class THD *);

	void cleanup_items(class TABLE_LIST *);

	bool is_placeholder(const class TABLE_LIST  *);

	void print(const class TABLE_LIST  *, class THD *, class String *, enum enum_query_type);

	bool check_single_table(class TABLE_LIST *, class TABLE_LIST * *, table_map);

	bool set_insert_values(class TABLE_LIST *, MEM_ROOT *);

	class TABLE_LIST * first_leaf_for_name_resolution(class TABLE_LIST *);

	class TABLE_LIST * last_leaf_for_name_resolution(class TABLE_LIST *);

	bool is_leaf_for_name_resolution(const class TABLE_LIST  *);

	const class TABLE_LIST  * top_table(const class TABLE_LIST  *);

	class TABLE_LIST * top_table(class TABLE_LIST *);

	bool prepare_check_option(class TABLE_LIST *, class THD *, bool);

	bool merge_where(class TABLE_LIST *, class THD *);

	bool prepare_replace_filter(class TABLE_LIST *, class THD *);

	bool is_view(const class TABLE_LIST  *);

	bool is_derived(const class TABLE_LIST  *);

	bool is_view_or_derived(const class TABLE_LIST  *);

	bool is_mergeable(const class TABLE_LIST  *);

	bool materializable_is_const(const class TABLE_LIST  *);

	bool is_merged(const class TABLE_LIST  *);

	void set_merged(class TABLE_LIST *);

	bool uses_materialization(const class TABLE_LIST  *);

	void set_uses_materialization(class TABLE_LIST *);

	bool is_updatable(const class TABLE_LIST  *);

	void set_updatable(class TABLE_LIST *);

	bool is_insertable(const class TABLE_LIST  *);

	void set_insertable(class TABLE_LIST *);

	bool is_multiple_tables(const class TABLE_LIST  *);

	uint leaf_tables_count(const class TABLE_LIST  *);

	class TABLE_LIST * first_leaf_table(class TABLE_LIST *);

	class TABLE_LIST * any_outer_leaf_table(class TABLE_LIST *);

	void set_view_query(class TABLE_LIST *, class LEX *);

	class LEX * view_query(const class TABLE_LIST  *);

	void set_derived_unit(class TABLE_LIST *, class st_select_lex_unit *);

	class st_select_lex_unit * derived_unit(const class TABLE_LIST  *);

	void set_name_temporary(class TABLE_LIST *);

	void reset_name_temporary(class TABLE_LIST *);

	bool resolve_derived(class TABLE_LIST *, class THD *, bool);

	bool optimize_derived(class TABLE_LIST *, class THD *);

	bool create_derived(class TABLE_LIST *, class THD *);

	bool materialize_derived(class TABLE_LIST *, class THD *);

	bool cleanup_derived(class TABLE_LIST *);

	void set_want_privilege(class TABLE_LIST *, ulong);

	bool prepare_security(class TABLE_LIST *, class THD *);

	class Security_context * find_view_security_context(class TABLE_LIST *, class THD *);

	bool prepare_view_securety_context(class TABLE_LIST *, class THD *);

	void reinit_before_use(class TABLE_LIST *, class THD *);

	bool process_index_hints(class TABLE_LIST *, class TABLE *);

	bool is_table_ref_id_equal(const class TABLE_LIST  *, class TABLE_SHARE *);

	void set_table_ref_id(class TABLE_LIST *, class TABLE_SHARE *);

	void set_table_ref_id(class TABLE_LIST *, enum enum_table_ref_type, ulonglong);

	uint query_block_id(const class TABLE_LIST  *);

	const char  * get_db_name(const class TABLE_LIST  *);

	const char  * get_table_name(const class TABLE_LIST  *);

	int fetch_number_of_rows(class TABLE_LIST *);

	bool update_derived_keys(class TABLE_LIST *, class Field *, class Item * *, uint);

	bool generate_keys(class TABLE_LIST *);

	bool setup_materialized_derived(class TABLE_LIST *, class THD *);

	bool create_field_translation(class TABLE_LIST *, class THD *);

	class TABLE_LIST * outer_join_nest(const class TABLE_LIST  *);

	bool is_inner_table_of_outer_join(const class TABLE_LIST  *);

	class TABLE_LIST * updatable_base_table(class TABLE_LIST *);

	void set_privileges(class TABLE_LIST *, ulong);

	class TABLE_LIST *         next_local;           /*     0     8 */
	class TABLE_LIST *         next_global;          /*     8     8 */
	class TABLE_LIST * *       prev_global;          /*    16     8 */
	const char  *              db;                   /*    24     8 */
	const char  *              table_name;           /*    32     8 */
	const char  *              alias;                /*    40     8 */
	LEX_CSTRING                target_tablespace_name; /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     schema_table_name;    /*    64     8 */
	char *                     option;               /*    72     8 */
	class Opt_hints_table *    opt_hints_table;      /*    80     8 */
	class Opt_hints_qb *       opt_hints_qb;         /*    88     8 */
private:

	uint                       m_tableno;            /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	table_map                  m_map;                /*   104     8 */
	class Item *               m_join_cond;          /*   112     8 */
	class Item *               m_sj_cond;            /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	table_map                  sj_inner_tables;      /*   128     8 */
	class TABLE_LIST *         natural_join;         /*   136     8 */
	bool                       is_natural_join;      /*   144     1 */

	/* XXX 7 bytes hole, try to pack */

	class List<String> *       join_using_fields;    /*   152     8 */
	class List<Natural_join_column> * join_columns;  /*   160     8 */
	bool                       is_join_columns_complete; /*   168     1 */

	/* XXX 7 bytes hole, try to pack */

	class TABLE_LIST *         next_name_resolution_table; /*   176     8 */
	class List<Index_hint> *   index_hints;          /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	class TABLE *              table;                /*   192     8 */
	class Table_id            table_id;              /*   200     8 */
	class Query_result_union * derived_result;       /*   208     8 */
	class TABLE_LIST *         correspondent_table;  /*   216     8 */
	class st_select_lex_unit * derived;              /*   224     8 */
	ST_SCHEMA_TABLE *          schema_table;         /*   232     8 */
	class st_select_lex *      schema_select_lex;    /*   240     8 */
	bool                       schema_table_reformed; /*   248     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 4 boundary (256 bytes) --- */
	class Temp_table_param *   schema_table_param;   /*   256     8 */
	class st_select_lex *      select_lex;           /*   264     8 */
	class LEX *                view;                 /*   272     8 */
	class Field_translator *   field_translation;    /*   280     8 */
	class Field_translator *   field_translation_end; /*   288     8 */
	class TABLE_LIST *         merge_underlying_list; /*   296     8 */
	class List<TABLE_LIST> *   view_tables;          /*   304     8 */
	class TABLE_LIST *         belong_to_view;       /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	class TABLE_LIST *         referencing_view;     /*   320     8 */
	class TABLE_LIST *         parent_l;             /*   328     8 */
	class Security_context *   security_ctx;         /*   336     8 */
	class Security_context *   view_sctx;            /*   344     8 */
	bool                       allowed_show;         /*   352     1 */

	/* XXX 7 bytes hole, try to pack */

	class TABLE_LIST *         next_leaf;            /*   360     8 */
	class Item *               derived_where_cond;   /*   368     8 */
	class Item *               check_option;         /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	class Item *               replace_filter;       /*   384     8 */
	LEX_STRING                 select_stmt;          /*   392    16 */
	LEX_STRING                 md5;                  /*   408    16 */
	LEX_STRING                 source;               /*   424    16 */
	LEX_CSTRING                view_db;              /*   440    16 */
	/* --- cacheline 7 boundary (448 bytes) was 8 bytes ago --- */
	LEX_CSTRING                view_name;            /*   456    16 */
	LEX_STRING                 timestamp;            /*   472    16 */
	struct st_lex_user         definer;              /*   488    80 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 8 boundary (512 bytes) was 56 bytes ago --- */
	ulonglong                  file_version;         /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	ulonglong                  updatable_view;       /*   576     8 */
	ulonglong                  algorithm;            /*   584     8 */
	ulonglong                  view_suid;            /*   592     8 */
	ulonglong                  with_check;           /*   600     8 */
	enum enum_view_algorithm   effective_algorithm;  /*   608     4 */

	/* XXX 4 bytes hole, try to pack */

	struct GRANT_INFO          grant;                /*   616    56 */
	/* --- cacheline 10 boundary (640 bytes) was 32 bytes ago --- */
	ulonglong                  engine_data;          /*   672     8 */
	qc_engine_callback         callback_func;        /*   680     8 */
	enum thr_lock_type         lock_type;            /*   688     4 */
	uint                       outer_join;           /*   692     4 */
	uint                       shared;               /*   696     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 11 boundary (704 bytes) --- */
	size_t                     db_length;            /*   704     8 */
	size_t                     table_name_length;    /*   712     8 */
	bool                       m_updatable;          /*   720     1 */
	bool                       m_insertable;         /*   721     1 */
	bool                       straight;             /*   722     1 */
	bool                       updating;             /*   723     1 */
	bool                       force_index;          /*   724     1 */
	bool                       ignore_leaves;        /*   725     1 */

	/* XXX 2 bytes hole, try to pack */

	table_map                  dep_tables;           /*   728     8 */
	table_map                  on_expr_dep_tables;   /*   736     8 */
	class st_nested_join *     nested_join;          /*   744     8 */
	class TABLE_LIST *         embedding;            /*   752     8 */
	class List<TABLE_LIST> *   join_list;            /*   760     8 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	bool                       cacheable_table;      /*   768     1 */
	bool                       table_in_first_from_clause; /*   769     1 */

	/* XXX 2 bytes hole, try to pack */

	enum enum_open_type        open_type;            /*   772     4 */
	bool                       contain_auto_increment; /*   776     1 */
	bool                       check_option_processed; /*   777     1 */
	bool                       replace_filter_processed; /*   778     1 */

	/* XXX 1 byte hole, try to pack */

	enum frm_type_enum         required_type;        /*   780     4 */
	char                       timestamp_buffer[20]; /*   784    20 */
	bool                       prelocking_placeholder; /*   804     1 */

	/* XXX 3 bytes hole, try to pack */

	enum {
		OPEN_NORMAL     = 0,
		OPEN_IF_EXISTS  = 1,
		OPEN_FOR_CREATE = 2,
		OPEN_STUB       = 3,
	} open_strategy;                                 /*   808     4 */
	bool                       internal_tmp_table;   /*   812     1 */
	bool                       is_alias;             /*   813     1 */
	bool                       is_fqtn;              /*   814     1 */

	/* XXX 1 byte hole, try to pack */

	class View_creation_ctx *  view_creation_ctx;    /*   816     8 */
	LEX_STRING                 view_client_cs_name;  /*   824    16 */
	/* --- cacheline 13 boundary (832 bytes) was 8 bytes ago --- */
	LEX_STRING                 view_connection_cl_name; /*   840    16 */
	LEX_STRING                 view_body_utf8;       /*   856    16 */
	class List<Derived_key>   derived_key_list;      /*   872    24 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	uint8                      trg_event_map;        /*   896     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       i_s_requested_object; /*   900     4 */
	bool                       has_db_lookup_value;  /*   904     1 */
	bool                       has_table_lookup_value; /*   905     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       table_open_method;    /*   908     4 */
	enum enum_schema_table_state schema_table_state; /*   912     4 */

	/* XXX 4 bytes hole, try to pack */

	class MDL_request         mdl_request;           /*   920   440 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 21 boundary (1344 bytes) was 16 bytes ago --- */
	bool                       view_no_explain;      /*  1360     1 */

	/* XXX 7 bytes hole, try to pack */

	class List<String> *       partition_names;      /*  1368     8 */
	void set_tableno(class TABLE_LIST *, uint);

	uint tableno(const class TABLE_LIST  *);

	table_map map(const class TABLE_LIST  *);

	class Item *               m_join_cond_optim;    /*  1376     8 */
	class COND_EQUAL *         cond_equal;           /*  1384     8 */
	bool                       optimized_away;       /*  1392     1 */
	bool                       derived_keys_ready;   /*  1393     1 */

	/* XXX 2 bytes hole, try to pack */

	enum enum_table_ref_type   m_table_ref_type;     /*  1396     4 */
	ulonglong                  m_table_ref_version;  /*  1400     8 */

	/* size: 1408, cachelines: 22, members: 113 */
	/* sum members: 1341, holes: 17, sum holes: 67 */
	/* paddings: 2, sum paddings: 8 */
};
class List<st_mysql_lex_string> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<st_mysql_lex_string> *);

	void List(class List<st_mysql_lex_string> *, const class List<st_mysql_lex_string>  &);

	class List<st_mysql_lex_string> & operator=(class List<st_mysql_lex_string> *, const class List<st_mysql_lex_string>  &);

	void List(class List<st_mysql_lex_string> *, const class List<st_mysql_lex_string>  &, MEM_ROOT *);

	bool push_back(class List<st_mysql_lex_string> *, class st_mysql_lex_string *);

	bool push_back(class List<st_mysql_lex_string> *, class st_mysql_lex_string *, MEM_ROOT *);

	bool push_front(class List<st_mysql_lex_string> *, class st_mysql_lex_string *);

	bool push_front(class List<st_mysql_lex_string> *, class st_mysql_lex_string *, MEM_ROOT *);

	class st_mysql_lex_string * head(class List<st_mysql_lex_string> *);

	class st_mysql_lex_string * * head_ref(class List<st_mysql_lex_string> *);

	class st_mysql_lex_string * pop(class List<st_mysql_lex_string> *);

	void concat(class List<st_mysql_lex_string> *, class List<st_mysql_lex_string> *);

	void disjoin(class List<st_mysql_lex_string> *, class List<st_mysql_lex_string> *);

	void prepand(class List<st_mysql_lex_string> *, class List<st_mysql_lex_string> *);

	void delete_elements(class List<st_mysql_lex_string> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct st_key_create_information {
	enum ha_key_alg            algorithm;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      block_size;           /*     8     8 */
	LEX_STRING                 parser_name;          /*    16    16 */
	LEX_STRING                 comment;              /*    32    16 */
	bool                       check_for_duplicate_indexes; /*    48     1 */

	/* size: 56, cachelines: 1, members: 5 */
	/* sum members: 45, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct st_savepoint {
	class st_savepoint *       prev;                 /*     0     8 */
	char *                     name;                 /*     8     8 */
	size_t                     length;               /*    16     8 */
	class Ha_trx_info *        ha_list;              /*    24     8 */
	class MDL_savepoint       mdl_savepoint;         /*    32    16 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
class Cost_estimate {
	double                     io_cost;              /*     0     8 */
	double                     cpu_cost;             /*     8     8 */
	double                     import_cost;          /*    16     8 */
	double                     mem_cost;             /*    24     8 */
public:

	void Cost_estimate(class Cost_estimate *);

	double total_cost(const class Cost_estimate  *);

	double get_io_cost(const class Cost_estimate  *);

	double get_cpu_cost(const class Cost_estimate  *);

	double get_import_cost(const class Cost_estimate  *);

	double get_mem_cost(const class Cost_estimate  *);

	bool is_zero(const class Cost_estimate  *);

	bool is_max_cost(const class Cost_estimate  *);

	void reset(class Cost_estimate *);

	void set_max_cost(class Cost_estimate *);

	void multiply(class Cost_estimate *, double);

	class Cost_estimate & operator+=(class Cost_estimate *, const class Cost_estimate  &);

	class Cost_estimate operator+(class Cost_estimate *, const class Cost_estimate  &);

	class Cost_estimate operator-(class Cost_estimate *, const class Cost_estimate  &);

	bool operator>(const class Cost_estimate  *, const class Cost_estimate  &);

	bool operator<(const class Cost_estimate  *, const class Cost_estimate  &);

	void add_io(class Cost_estimate *, double);

	void add_cpu(class Cost_estimate *, double);

	void add_import(class Cost_estimate *, double);

	void add_mem(class Cost_estimate *, double);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Prealloced_array<Opt_trace_stmt*, 16, true> {
	class Opt_trace_stmt * * cast_rawbuff(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

public:

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16, true> *, const class Prealloced_array<Opt_trace_stmt*, 16, true>  &);

	void Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Opt_trace_stmt * const * const_iterator;

	class Prealloced_array<Opt_trace_stmt*, 16, true> & operator=(class Prealloced_array<Opt_trace_stmt*, 16, true> *, const class Prealloced_array<Opt_trace_stmt*, 16, true>  &);

	void ~Prealloced_array(class Prealloced_array<Opt_trace_stmt*, 16, true> *, int);

	size_t capacity(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	size_t element_size(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	bool empty(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	size_t size(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	class Opt_trace_stmt * & at(class Prealloced_array<Opt_trace_stmt*, 16, true> *, size_t);

	class Opt_trace_stmt * const & at(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *, size_t);

	class Opt_trace_stmt * & operator[](class Prealloced_array<Opt_trace_stmt*, 16, true> *, size_t);

	class Opt_trace_stmt * const & operator[](const class Prealloced_array<Opt_trace_stmt*, 16, true>  *, size_t);

	class Opt_trace_stmt * & back(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

	class Opt_trace_stmt * const & back(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	class Opt_trace_stmt * & front(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

	class Opt_trace_stmt * const & front(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	typedef class Opt_trace_stmt * * iterator;

	iterator begin(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

	iterator end(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

	const_iterator begin(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	const_iterator end(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *);

	bool reserve(class Prealloced_array<Opt_trace_stmt*, 16, true> *, size_t);

	bool push_back(class Prealloced_array<Opt_trace_stmt*, 16, true> *, class Opt_trace_stmt * const &);

	void pop_back(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

	iterator insert(class Prealloced_array<Opt_trace_stmt*, 16, true> *, iterator, const value_type  &);

	typedef class Opt_trace_stmt * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<Opt_trace_stmt**, bool> insert_unique(class Prealloced_array<Opt_trace_stmt*, 16, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Opt_trace_stmt*, 16, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Opt_trace_stmt*, 16, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<Opt_trace_stmt*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<Opt_trace_stmt*, 16, true> *, size_t);

	void erase_at_end(class Prealloced_array<Opt_trace_stmt*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<Opt_trace_stmt*, 16, true> *, iterator, iterator);

	void swap(class Prealloced_array<Opt_trace_stmt*, 16, true> *, class Prealloced_array<Opt_trace_stmt*, 16, true> &);

	void shrink_to_fit(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

	void resize(class Prealloced_array<Opt_trace_stmt*, 16, true> *, size_t, class Opt_trace_stmt * const &);

	void clear(class Prealloced_array<Opt_trace_stmt*, 16, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<128, 8> m_buff __attribute__((__aligned__(8))); /*    16   128 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class Opt_trace_stmt * *   m_array_ptr;          /*   144     8 */
	PSI_memory_key             m_psi_key;            /*   152     4 */

	/* size: 160, cachelines: 3, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Opt_trace_context {
	enum feature_value {
		GREEDY_SEARCH      = 1,
		RANGE_OPTIMIZER    = 2,
		DYNAMIC_RANGE      = 4,
		REPEATED_SUBSELECT = 8,
		MISC               = 128,
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Opt_trace_context_impl {
	public:

		void Opt_trace_context_impl(class Opt_trace_context_impl *);

		void disable_I_S_for_this_and_children(class Opt_trace_context_impl *);

		void restore_I_S(class Opt_trace_context_impl *);

		class Opt_trace_stmt *     current_stmt_in_gen;  /*     0     8 */
		Opt_trace_stmt_array       stack_of_current_stmts __attribute__((__aligned__(8))); /*     8   160 */
		/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
		Opt_trace_stmt_array       all_stmts_for_I_S __attribute__((__aligned__(8))); /*   168   160 */
		/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
		Opt_trace_stmt_array       all_stmts_to_del __attribute__((__aligned__(8))); /*   328   160 */
		/* --- cacheline 7 boundary (448 bytes) was 40 bytes ago --- */
		bool                       end_marker;           /*   488     1 */
		bool                       one_line;             /*   489     1 */

		/* XXX 2 bytes hole, try to pack */

		enum feature_value         features;             /*   492     4 */
		long int                   offset;               /*   496     8 */
		long int                   limit;                /*   504     8 */
		/* --- cacheline 8 boundary (512 bytes) --- */
		size_t                     max_mem_size;         /*   512     8 */
		long int                   since_offset_0;       /*   520     8 */

		/* size: 528, cachelines: 9, members: 11 */
		/* sum members: 526, holes: 1, sum holes: 2 */
		/* forced alignments: 3 */
		/* last cacheline: 16 bytes */
	} __attribute__((__aligned__(8)));

public:

	void Opt_trace_context(class Opt_trace_context *);

	void ~Opt_trace_context(class Opt_trace_context *, int);

	bool start(class Opt_trace_context *, bool, bool, bool, bool, long int, long int, ulong, ulonglong);

	void end(class Opt_trace_context *);

	bool is_started(const class Opt_trace_context  *);

	bool support_I_S(const class Opt_trace_context  *);

	void set_query(class Opt_trace_context *, const char  *, size_t, const CHARSET_INFO  *);

	void reset(class Opt_trace_context *);

	bool get_end_marker(const class Opt_trace_context  *);

	bool get_one_line(const class Opt_trace_context  *);

	static const char  *              flag_names[0]; /*     0     0 */
	static const char  *              feature_names[0]; /*     0     0 */
	void missing_privilege(class Opt_trace_context *);

	static const enum feature_value   default_features; /*     0     0 */
	bool feature_enabled(const class Opt_trace_context  *, enum feature_value);

	class Opt_trace_stmt * get_current_stmt_in_gen(class Opt_trace_context *);

	const class Opt_trace_stmt  * get_next_stmt_for_I_S(const class Opt_trace_context  *, long int *);

	void disable_I_S_for_this_and_children(class Opt_trace_context *);

	void restore_I_S(class Opt_trace_context *);

	class Opt_trace_context_impl * pimpl;            /*     0     8 */
	int                        I_S_disabled;         /*     8     4 */
	void purge_stmts(class Opt_trace_context *, bool);

	size_t allowed_mem_size_for_current_stmt(const class Opt_trace_context  *);

	void Opt_trace_context(class Opt_trace_context *, const class Opt_trace_context  &);

	class Opt_trace_context & operator=(class Opt_trace_context *, const class Opt_trace_context  &);


	/* size: 16, cachelines: 1, members: 2, static members: 3 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct my_aligned_storage<128, 8> {
	union {
		char                       data[128];            /*     0   128 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[128];            /*     0   128 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0   128 */

	/* size: 128, cachelines: 2, members: 1 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class I_P_List_null_counter {
protected:

	void reset(class I_P_List_null_counter *);

	void inc(class I_P_List_null_counter *);

	void dec(class I_P_List_null_counter *);

	void swap(class I_P_List_null_counter *, class I_P_List_null_counter &);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List_counter {
	uint                       m_counter;            /*     0     4 */
protected:

	void I_P_List_counter(class I_P_List_counter *);

	void reset(class I_P_List_counter *);

	void inc(class I_P_List_counter *);

	void dec(class I_P_List_counter *);

	void swap(class I_P_List_counter *, class I_P_List_counter &);

public:

	uint elements(const class I_P_List_counter  *);


	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
class Sql_condition : public Sql_alloc {
	enum enum_severity_level {
		SL_NOTE      = 0,
		SL_WARNING   = 1,
		SL_ERROR     = 2,
		SEVERITY_END = 3,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	const char  * message_text(const class Sql_condition  *);

	size_t message_octet_length(const class Sql_condition  *);

	const char  * returned_sqlstate(const class Sql_condition  *);

	uint mysql_errno(const class Sql_condition  *);

	enum enum_severity_level severity(const class Sql_condition  *);

	void Sql_condition(class Sql_condition *, MEM_ROOT *);

	void Sql_condition(class Sql_condition *, MEM_ROOT *, uint, const char  *, enum enum_severity_level, const char  *);

	void ~Sql_condition(class Sql_condition *, int);

	void copy_opt_attributes(class Sql_condition *, const class Sql_condition  *);

	void set_message_text(class Sql_condition *, const char  *);

	void set_returned_sqlstate(class Sql_condition *, const char  *);

	void set_class_origins(class Sql_condition *);


	class String              m_class_origin;        /*     0    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_subclass_origin;     /*    32    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) --- */
	class String              m_constraint_catalog;  /*    64    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_constraint_schema;   /*    96    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) --- */
	class String              m_constraint_name;     /*   128    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_catalog_name;        /*   160    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 3 boundary (192 bytes) --- */
	class String              m_schema_name;         /*   192    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_table_name;          /*   224    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 4 boundary (256 bytes) --- */
	class String              m_column_name;         /*   256    32 */

	/* XXX last struct has 3 bytes of padding */

	class String              m_cursor_name;         /*   288    32 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 5 boundary (320 bytes) --- */
	class String              m_message_text;        /*   320    32 */

	/* XXX last struct has 3 bytes of padding */

	uint                       m_mysql_errno;        /*   352     4 */
	char                       m_returned_sqlstate[6]; /*   356     6 */

	/* XXX 2 bytes hole, try to pack */

	enum enum_severity_level   m_severity_level;     /*   364     4 */
	class Sql_condition *      m_next_condition;     /*   368     8 */
	class Sql_condition * *    m_prev_condition;     /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	MEM_ROOT *                 m_mem_root;           /*   384     8 */

	/* size: 392, cachelines: 7, members: 18 */
	/* sum members: 390, holes: 1, sum holes: 2 */
	/* paddings: 12, sum paddings: 34 */
	/* last cacheline: 8 bytes */
};
class ErrConvString {
	char                       err_buffer[512];      /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	size_t                     buf_length;           /*   512     8 */
public:

	void ErrConvString(class ErrConvString *, class String *);

	void ErrConvString(class ErrConvString *, const char  *, const CHARSET_INFO  *);

	void ErrConvString(class ErrConvString *, const char  *, size_t);

	void ErrConvString(class ErrConvString *, const char  *, size_t, const CHARSET_INFO  *);

	void ErrConvString(class ErrConvString *, longlong);

	void ErrConvString(class ErrConvString *, longlong, bool);

	void ErrConvString(class ErrConvString *, double);

	void ErrConvString(class ErrConvString *, const class my_decimal  *);

	void ErrConvString(class ErrConvString *, const class st_mysql_time  *, uint);

	void ~ErrConvString(class ErrConvString *, int);

	char * ptr(class ErrConvString *);

	size_t length(const class ErrConvString  *);


	/* size: 520, cachelines: 9, members: 2 */
	/* last cacheline: 8 bytes */
};
class I_P_List_fast_push_back<Sql_condition> {
	class Sql_condition * *    m_last;               /*     0     8 */
protected:

	void I_P_List_fast_push_back(class I_P_List_fast_push_back<Sql_condition> *, class Sql_condition * *);

	void set_last(class I_P_List_fast_push_back<Sql_condition> *, class Sql_condition * *);

	class Sql_condition * * get_last(const class I_P_List_fast_push_back<Sql_condition>  *);

	void swap(class I_P_List_fast_push_back<Sql_condition> *, class I_P_List_fast_push_back<Sql_condition> &);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > : public I_P_List_counter, public I_P_List_fast_push_back<Sql_condition> {
public:

	/* class I_P_List_counter    <ancestor>; */      /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	/* class I_P_List_fast_push_back<Sql_condition> <ancestor>; */ /*     8     8 */
	class Sql_condition *      m_first;              /*    16     8 */
	void I_P_List(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	void empty(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	bool is_empty(const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	void push_front(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *);

	void push_back(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *);

	void insert_after(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *, class Sql_condition *);

	void remove(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class Sql_condition *);

	class Sql_condition * front(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	const class Sql_condition  * front(const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	class Sql_condition * pop_front(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	void swap(class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio, class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_conditio);

	typedef struct I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > > Const_Iterator;


	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 8, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 8 (member bytes) + 0 (member bits) + 4 (byte holes) + 0 (bit holes), diff = 96 bits */
};
struct I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition> {
	class Sql_condition * * next_ptr(class Sql_condition *);

	const class Sql_condition  * const * next_ptr(const class Sql_condition  *);

	class Sql_condition * * * prev_ptr(class Sql_condition *);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > > {
	const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co list; /*     0     8 */
	const class Sql_condition  * current;            /*     8     8 */
public:

	void I_P_List_iterator(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	void I_P_List_iterator(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co, const class Sql_condition  *);

	void init(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, const class I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_co);

	const class Sql_condition  * operator++(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con, int);

	const class Sql_condition  * operator++(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con);

	void rewind(class I_P_List_iterator<const Sql_condition, I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_con);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Diagnostics_area {
	enum enum_diagnostics_status {
		DA_EMPTY    = 0,
		DA_OK       = 1,
		DA_EOF      = 2,
		DA_ERROR    = 3,
		DA_DISABLED = 4,
	};

public:

	void Diagnostics_area(class Diagnostics_area *, bool);

	void ~Diagnostics_area(class Diagnostics_area *, int);

	void set_overwrite_status(class Diagnostics_area *, bool);

	bool is_sent(const class Diagnostics_area  *);

	void set_is_sent(class Diagnostics_area *, bool);

	void set_ok_status(class Diagnostics_area *, ulonglong, ulonglong, const char  *);

	void set_eof_status(class Diagnostics_area *, class THD *);

	void set_error_status(class Diagnostics_area *, uint);

	void set_error_status(class Diagnostics_area *, uint, const char  *, const char  *);

	void disable_status(class Diagnostics_area *);

	void reset_diagnostics_area(class Diagnostics_area *);

	bool is_set(const class Diagnostics_area  *);

	bool is_error(const class Diagnostics_area  *);

	bool is_eof(const class Diagnostics_area  *);

	bool is_ok(const class Diagnostics_area  *);

	bool is_disabled(const class Diagnostics_area  *);

	enum enum_diagnostics_status status(const class Diagnostics_area  *);

	const char  * message_text(const class Diagnostics_area  *);

	uint mysql_errno(const class Diagnostics_area  *);

	const char  * returned_sqlstate(const class Diagnostics_area  *);

	ulonglong affected_rows(const class Diagnostics_area  *);

	ulonglong last_insert_id(const class Diagnostics_area  *);

	uint last_statement_cond_count(const class Diagnostics_area  *);

	ulong current_statement_cond_count(const class Diagnostics_area  *);

	void reset_statement_cond_count(class Diagnostics_area *);

	bool has_sql_condition(const class Diagnostics_area  *, const char  *, size_t);

	bool has_sql_condition(const class Diagnostics_area  *, uint);

	void reset_condition_info(class Diagnostics_area *, class THD *);

	ulong current_row_for_condition(const class Diagnostics_area  *);

	void inc_current_row_for_condition(class Diagnostics_area *);

	void reset_current_row_for_condition(class Diagnostics_area *);

	ulong error_count(const class Diagnostics_area  *, class THD *);

	ulong warn_count(const class Diagnostics_area  *, class THD *);

	uint cond_count(const class Diagnostics_area  *);

	typedef Const_Iterator Sql_condition_iterator;

	Sql_condition_iterator sql_conditions(const class Diagnostics_area  *);

	const char  * get_first_condition_message(class Diagnostics_area *);

	void reserve_number_of_conditions(class Diagnostics_area *, class THD *, uint);

	class Sql_condition * push_warning(class Diagnostics_area *, class THD *, uint, const char  *, enum enum_severity_level, const char  *);

	void mark_preexisting_sql_conditions(class Diagnostics_area *);

	void copy_new_sql_conditions(class Diagnostics_area *, class THD *, const class Diagnostics_area  *);

	void copy_sql_conditions_from_da(class Diagnostics_area *, class THD *, const class Diagnostics_area  *);

	void copy_non_errors_from_da(class Diagnostics_area *, class THD *, const class Diagnostics_area  *);

	class Sql_condition * error_condition(const class Diagnostics_area  *);

	class Sql_condition * push_warning(class Diagnostics_area *, class THD *, const class Sql_condition  *);

	void push_diagnostics_area(class Diagnostics_area *, class THD *, class Diagnostics_area *, bool);

	class Diagnostics_area * pop_diagnostics_area(class Diagnostics_area *);

	const class Diagnostics_area  * stacked_da(const class Diagnostics_area  *);

	class Diagnostics_area *   m_stacked_da;         /*     0     8 */
	MEM_ROOT                   m_condition_root;     /*     8    88 */
	typedef struct I_P_List<Sql_condition, I_P_List_adapter<Sql_condition, &Sql_condition::m_next_condition, &Sql_condition::m_prev_condition>, I_P_List_counter, I_P_List_fast_push_back<Sql_condition> > Sql_condition_list;

	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	Sql_condition_list         m_conditions_list;    /*    96    24 */
	class List<const Sql_condition> m_preexisting_sql_conditions; /*   120    24 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	bool                       m_is_sent;            /*   144     1 */
	bool                       m_can_overwrite_status; /*   145     1 */
	bool                       m_allow_unlimited_conditions; /*   146     1 */

	/* XXX 1 byte hole, try to pack */

	enum enum_diagnostics_status m_status;           /*   148     4 */
	char                       m_message_text[512];  /*   152   512 */
	/* --- cacheline 10 boundary (640 bytes) was 24 bytes ago --- */
	char                       m_returned_sqlstate[6]; /*   664     6 */

	/* XXX 2 bytes hole, try to pack */

	uint                       m_mysql_errno;        /*   672     4 */

	/* XXX 4 bytes hole, try to pack */

	ulonglong                  m_affected_rows;      /*   680     8 */
	ulonglong                  m_last_insert_id;     /*   688     8 */
	uint                       m_last_statement_cond_count; /*   696     4 */
	uint                       m_current_statement_cond_count; /*   700     4 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	uint                       m_current_statement_cond_count_by_sl[3]; /*   704    12 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      m_current_row_for_condition; /*   720     8 */
	ulong                      m_saved_error_count;  /*   728     8 */
	ulong                      m_saved_warn_count;   /*   736     8 */

	/* size: 744, cachelines: 12, members: 19 */
	/* sum members: 733, holes: 4, sum holes: 11 */
	/* last cacheline: 40 bytes */
};
class List<const Sql_condition> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<const Sql_condition> *);

	void List(class List<const Sql_condition> *, const class List<const Sql_condition>  &);

	class List<const Sql_condition> & operator=(class List<const Sql_condition> *, const class List<const Sql_condition>  &);

	void List(class List<const Sql_condition> *, const class List<const Sql_condition>  &, MEM_ROOT *);

	bool push_back(class List<const Sql_condition> *, const class Sql_condition  *);

	bool push_back(class List<const Sql_condition> *, const class Sql_condition  *, MEM_ROOT *);

	bool push_front(class List<const Sql_condition> *, const class Sql_condition  *);

	bool push_front(class List<const Sql_condition> *, const class Sql_condition  *, MEM_ROOT *);

	const class Sql_condition  * head(class List<const Sql_condition> *);

	const class Sql_condition  * * head_ref(class List<const Sql_condition> *);

	const class Sql_condition  * pop(class List<const Sql_condition> *);

	void concat(class List<const Sql_condition> *, class List<const Sql_condition> *);

	void disjoin(class List<const Sql_condition> *, class List<const Sql_condition> *);

	void prepand(class List<const Sql_condition> *, class List<const Sql_condition> *);

	void delete_elements(class List<const Sql_condition> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct st_mysql_socket {
	my_socket                  fd;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class PSI_socket *         m_psi;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct st_com_init_db_data {
	const char  *              db_name;              /*     0     8 */
	long unsigned int          length;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_com_refresh_data {
	unsigned char              options;              /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct st_com_shutdown_data {
	enum mysql_enum_shutdown_level level;            /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct st_com_kill_data {
	long unsigned int          id;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct st_com_set_option_data {
	unsigned int               opt_command;          /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct st_com_stmt_execute_data {
	long unsigned int          stmt_id;              /*     0     8 */
	long unsigned int          flags;                /*     8     8 */
	unsigned char *            params;               /*    16     8 */
	long unsigned int          params_length;        /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct st_com_stmt_fetch_data {
	long unsigned int          stmt_id;              /*     0     8 */
	long unsigned int          num_rows;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_com_stmt_send_long_data_data {
	long unsigned int          stmt_id;              /*     0     8 */
	unsigned int               param_number;         /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	unsigned char *            longdata;             /*    16     8 */
	long unsigned int          length;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct st_com_stmt_prepare_data {
	const char  *              query;                /*     0     8 */
	unsigned int               length;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct st_stmt_close_data {
	unsigned int               stmt_id;              /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct st_com_stmt_reset_data {
	unsigned int               stmt_id;              /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct st_com_query_data {
	const char  *              query;                /*     0     8 */
	unsigned int               length;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct st_com_field_list_data {
	unsigned char *            table_name;           /*     0     8 */
	unsigned int               table_name_length;    /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const unsigned char  *     query;                /*    16     8 */
	unsigned int               query_length;         /*    24     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 24, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
union COM_DATA {
	COM_INIT_DB_DATA           com_init_db;        /*     0    16 */
	COM_REFRESH_DATA           com_refresh;        /*     0     1 */
	COM_SHUTDOWN_DATA          com_shutdown;       /*     0     4 */
	COM_KILL_DATA              com_kill;           /*     0     8 */
	COM_SET_OPTION_DATA        com_set_option;     /*     0     4 */
	COM_STMT_EXECUTE_DATA      com_stmt_execute;   /*     0    32 */
	COM_STMT_FETCH_DATA        com_stmt_fetch;     /*     0    16 */
	COM_STMT_SEND_LONG_DATA_DATA com_stmt_send_long_data; /*     0    32 */
	COM_STMT_PREPARE_DATA      com_stmt_prepare;   /*     0    16 */
	COM_STMT_CLOSE_DATA        com_stmt_close;     /*     0     4 */
	COM_STMT_RESET_DATA        com_stmt_reset;     /*     0     4 */
	COM_QUERY_DATA             com_query;          /*     0    16 */
	COM_FIELD_LIST_DATA        com_field_list;     /*     0    32 */
};
class Protocol {
	enum enum_protocol_type {
		PROTOCOL_TEXT   = 0,
		PROTOCOL_BINARY = 1,
		PROTOCOL_LOCAL  = 2,
		PROTOCOL_ERROR  = 3,
		PROTOCOL_PLUGIN = 4,
	};

	enum {
		SEND_NUM_ROWS = 1,
		SEND_DEFAULTS = 2,
		SEND_EOF      = 4,
	};

public:

	void Protocol(class Protocol *, const class Protocol  &);

	void Protocol(class Protocol *);

	void ~Protocol(class Protocol *, int);

	int ()(void) * *           _vptr.Protocol;       /*     0     8 */
	virtual int read_packet(class Protocol *);

	virtual int get_command(class Protocol *, union COM_DATA *, enum enum_server_command *);

	virtual enum enum_protocol_type type(class Protocol *);

	virtual enum enum_vio_type connection_type(class Protocol *);

	virtual bool store_null(class Protocol *);

	virtual bool store_tiny(class Protocol *, longlong);

	virtual bool store_short(class Protocol *, longlong);

	virtual bool store_long(class Protocol *, longlong);

	virtual bool store_longlong(class Protocol *, longlong, bool);

	virtual bool store_decimal(class Protocol *, const class my_decimal  *, uint, uint);

	virtual bool store(class Protocol *, const char  *, size_t, const CHARSET_INFO  *);

	virtual bool store(class Protocol *, float, uint32, class String *);

	virtual bool store(class Protocol *, double, uint32, class String *);

	virtual bool store(class Protocol *, MYSQL_TIME *, uint);

	virtual bool store_date(class Protocol *, MYSQL_TIME *);

	virtual bool store_time(class Protocol *, MYSQL_TIME *, uint);

	virtual bool store(class Protocol *, class Proto_field *);

	bool store(class Protocol *, int);

	bool store(class Protocol *, uint32);

	bool store(class Protocol *, longlong);

	bool store(class Protocol *, ulonglong);

	bool store(class Protocol *, const char  *, const CHARSET_INFO  *);

	bool store(class Protocol *, class String *);

	bool store(class Protocol *, const LEX_STRING  &, const CHARSET_INFO  *);

	virtual ulong get_client_capabilities(class Protocol *);

	virtual bool has_client_capability(class Protocol *, long unsigned int);

	virtual bool connection_alive(class Protocol *);

	virtual void start_row(class Protocol *);

	virtual bool end_row(class Protocol *);

	virtual void abort_row(class Protocol *);

	virtual void end_partial_result_set(class Protocol *);

	virtual int shutdown(class Protocol *, bool);

	virtual uint get_rw_status(class Protocol *);

	virtual bool get_compression(class Protocol *);

	virtual bool start_result_metadata(class Protocol *, uint, uint, const CHARSET_INFO  *);

	virtual bool send_field_metadata(class Protocol *, class Send_field *, const CHARSET_INFO  *);

	virtual bool end_result_metadata(class Protocol *);

	virtual bool send_ok(class Protocol *, uint, uint, ulonglong, ulonglong, const char  *);

	virtual bool send_eof(class Protocol *, uint, uint);

	virtual bool send_error(class Protocol *, uint, const char  *, const char  *);

	/* vtable has 33 entries: {
	   [0] = read_packet((null)), 
	   [1] = get_command((null)), 
	   [2] = type((null)), 
	   [3] = connection_type((null)), 
	   [4] = store_null((null)), 
	   [5] = store_tiny((null)), 
	   [6] = store_short((null)), 
	   [7] = store_long((null)), 
	   [8] = store_longlong((null)), 
	   [9] = store_decimal((null)), 
	   [10] = store((null)), 
	   [11] = store((null)), 
	   [12] = store((null)), 
	   [13] = store((null)), 
	   [14] = store_date((null)), 
	   [15] = store_time((null)), 
	   [16] = store((null)), 
	   [17] = get_client_capabilities((null)), 
	   [18] = has_client_capability((null)), 
	   [19] = connection_alive((null)), 
	   [20] = start_row((null)), 
	   [21] = end_row((null)), 
	   [22] = abort_row((null)), 
	   [23] = end_partial_result_set((null)), 
	   [24] = shutdown((null)), 
	   [25] = get_rw_status((null)), 
	   [26] = get_compression((null)), 
	   [27] = start_result_metadata((null)), 
	   [28] = send_field_metadata((null)), 
	   [29] = end_result_metadata((null)), 
	   [30] = send_ok((null)), 
	   [31] = send_eof((null)), 
	   [32] = send_error((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class MDL_request {
public:

	enum enum_mdl_type         type;                 /*     0     4 */
	enum enum_mdl_duration     duration;             /*     4     4 */
	class MDL_request *        next_in_list;         /*     8     8 */
	class MDL_request * *      prev_in_list;         /*    16     8 */
	class MDL_ticket *         ticket;               /*    24     8 */
	MDL_key                    key;                  /*    32   392 */
	/* --- cacheline 6 boundary (384 bytes) was 40 bytes ago --- */
	const char  *              m_src_file;           /*   424     8 */
	uint                       m_src_line;           /*   432     4 */
	void * operator new(size_t, MEM_ROOT *);

	void operator delete(void *, MEM_ROOT *);

	void init_with_source(class MDL_request *, enum enum_mdl_namespace, const char  *, const char  *, enum enum_mdl_type, enum enum_mdl_duration, const char  *, uint);

	void init_by_key_with_source(class MDL_request *, const MDL_key  *, enum enum_mdl_type, enum enum_mdl_duration, const char  *, uint);

	void set_type(class MDL_request *, enum enum_mdl_type);

	bool is_write_lock_request(const class MDL_request  *);

	bool is_ddl_or_lock_tables_lock_request(const class MDL_request  *);

	class MDL_request & operator=(class MDL_request *, const class MDL_request  &);

	void MDL_request(class MDL_request *);

	void MDL_request(class MDL_request *, const class MDL_request  *);


	/* size: 440, cachelines: 7, members: 8 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
class MDL_savepoint {
public:

	void MDL_savepoint(class MDL_savepoint *);

	void MDL_savepoint(class MDL_savepoint *, class MDL_ticket *, class MDL_ticket *);

	class MDL_ticket *         m_stmt_ticket;        /*     0     8 */
	class MDL_ticket *         m_trans_ticket;       /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class MDL_wait {
	enum enum_wait_status {
		EMPTY   = 0,
		GRANTED = 1,
		VICTIM  = 2,
		TIMEOUT = 3,
		KILLED  = 4,
	};

public:

	void MDL_wait(class MDL_wait *);

	void ~MDL_wait(class MDL_wait *, int);

	bool set_status(class MDL_wait *, enum enum_wait_status);

	enum enum_wait_status get_status(class MDL_wait *);

	void reset_status(class MDL_wait *);

	enum enum_wait_status timed_wait(class MDL_wait *, class MDL_context_owner *, class timespec *, bool, const PSI_stage_info  *);

	mysql_mutex_t              m_LOCK_wait_status;   /*     0    48 */
	mysql_cond_t               m_COND_wait_status;   /*    48    56 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	enum enum_wait_status      m_wait_status;        /*   104     4 */

	/* size: 112, cachelines: 2, members: 3 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
class MDL_context_owner {
public:

	void MDL_context_owner(class MDL_context_owner *, const class MDL_context_owner  &);

	void MDL_context_owner(class MDL_context_owner *);

	class MDL_context_owner & operator=(class MDL_context_owner *, const class MDL_context_owner  &);

	int ()(void) * *           _vptr.MDL_context_owner; /*     0     8 */
	virtual void ~MDL_context_owner(class MDL_context_owner *, int);

	virtual void enter_cond(class MDL_context_owner *, mysql_cond_t *, mysql_mutex_t *, const PSI_stage_info  *, PSI_stage_info *, const char  *, const char  *, int);

	virtual void exit_cond(class MDL_context_owner *, const PSI_stage_info  *, const char  *, const char  *, int);

	virtual int is_killed(class MDL_context_owner *);

	virtual bool is_connected(class MDL_context_owner *);

	virtual class THD * get_thd(class MDL_context_owner *);

	virtual void notify_shared_lock(class MDL_context_owner *, class MDL_context_owner *, bool);

	virtual bool notify_hton_pre_acquire_exclusive(class MDL_context_owner *, const MDL_key  *, bool *);

	virtual void notify_hton_post_release_exclusive(class MDL_context_owner *, const MDL_key  *);

	virtual uint get_rand_seed(class MDL_context_owner *);

	/* vtable has 9 entries: {
	   [2] = enter_cond((null)), 
	   [3] = exit_cond((null)), 
	   [4] = is_killed((null)), 
	   [5] = is_connected((null)), 
	   [6] = get_thd((null)), 
	   [7] = notify_shared_lock((null)), 
	   [8] = notify_hton_pre_acquire_exclusive((null)), 
	   [9] = notify_hton_post_release_exclusive((null)), 
	   [10] = get_rand_seed((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class I_P_List_no_push_back<MDL_ticket> {
protected:

	void I_P_List_no_push_back(class I_P_List_no_push_back<MDL_ticket> *, class MDL_ticket * *);

	void set_last(class I_P_List_no_push_back<MDL_ticket> *, class MDL_ticket * *);

	void swap(class I_P_List_no_push_back<MDL_ticket> *, class I_P_List_no_push_back<MDL_ticket> &);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_null_counter, I_P_List_no_push_back<MDL_ticket> > : public I_P_List_null_counter, public I_P_List_no_push_back<MDL_ticket> {
public:

	/* class I_P_List_null_counter <ancestor>; */    /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	/* class I_P_List_no_push_back<MDL_ticket> <ancestor>; */ /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class MDL_ticket *         m_first;              /*     0     8 */
	void I_P_List(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	void empty(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	bool is_empty(const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_);

	void push_front(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *);

	void push_back(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *);

	void insert_after(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *, class MDL_ticket *);

	void remove(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class MDL_ticket *);

	class MDL_ticket * front(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	const class MDL_ticket  * front(const class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_);

	class MDL_ticket * pop_front(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);

	void swap(class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n, class I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_n);


	/* size: 8, cachelines: 1, members: 3 */
	/* paddings: 2, sum paddings: 2 */
	/* last cacheline: 8 bytes */
};
class MDL_context {
public:

	void MDL_context(class MDL_context *);

	void destroy(class MDL_context *);

	bool try_acquire_lock(class MDL_context *, class MDL_request *);

	bool acquire_lock(class MDL_context *, class MDL_request *, ulong);

	bool acquire_locks(class MDL_context *, MDL_request_list *, ulong);

	bool upgrade_shared_lock(class MDL_context *, class MDL_ticket *, enum enum_mdl_type, ulong);

	bool clone_ticket(class MDL_context *, class MDL_request *);

	void release_all_locks_for_name(class MDL_context *, class MDL_ticket *);

	void release_locks(class MDL_context *, class MDL_release_locks_visitor *);

	void release_lock(class MDL_context *, class MDL_ticket *);

	bool owns_equal_or_stronger_lock(class MDL_context *, enum enum_mdl_namespace, const char  *, const char  *, enum enum_mdl_type);

	bool find_lock_owner(class MDL_context *, const MDL_key  *, class MDL_context_visitor *);

	bool has_lock(class MDL_context *, const class MDL_savepoint  &, class MDL_ticket *);

	bool has_locks(const class MDL_context  *);

	bool has_locks(const class MDL_context  *, enum enum_mdl_namespace);

	bool has_locks_waited_for(const class MDL_context  *);

	class MDL_savepoint mdl_savepoint(class MDL_context *);

	void set_explicit_duration_for_all_locks(class MDL_context *);

	void set_transaction_duration_for_all_locks(class MDL_context *);

	void set_lock_duration(class MDL_context *, class MDL_ticket *, enum enum_mdl_duration);

	void release_statement_locks(class MDL_context *);

	void release_transactional_locks(class MDL_context *);

	void rollback_to_savepoint(class MDL_context *, const class MDL_savepoint  &);

	class MDL_context_owner * get_owner(const class MDL_context  *);

	uint get_deadlock_weight(const class MDL_context  *);

	void init(class MDL_context *, class MDL_context_owner *);

	void set_needs_thr_lock_abort(class MDL_context *, bool);

	bool get_needs_thr_lock_abort(const class MDL_context  *);

	void set_force_dml_deadlock_weight(class MDL_context *, bool);

	uint get_random(class MDL_context *);

	class THD * get_thd(const class MDL_context  *);

	class MDL_wait            m_wait;                /*     0   112 */

	/* XXX last struct has 4 bytes of padding */
	typedef struct I_P_List<MDL_ticket, I_P_List_adapter<MDL_ticket, &MDL_ticket::next_in_context, &MDL_ticket::prev_in_context>, I_P_List_null_counter, I_P_List_no_push_back<MDL_ticket> > Ticket_list;


	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	Ticket_list                m_tickets[3];         /*   112    24 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	class MDL_context_owner *  m_owner;              /*   136     8 */
	bool                       m_needs_thr_lock_abort; /*   144     1 */
	bool                       m_force_dml_deadlock_weight; /*   145     1 */

	/* XXX 6 bytes hole, try to pack */

	mysql_prlock_t             m_LOCK_waiting_for;   /*   152   112 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	class MDL_wait_for_subgraph * m_waiting_for;     /*   264     8 */
	LF_PINS *                  m_pins;               /*   272     8 */
	uint                       m_rand_state;         /*   280     4 */
	class MDL_ticket * find_ticket(class MDL_context *, class MDL_request *, enum enum_mdl_duration *);

	void release_locks_stored_before(class MDL_context *, enum enum_mdl_duration, class MDL_ticket *);

	void release_lock(class MDL_context *, enum enum_mdl_duration, class MDL_ticket *);

	bool try_acquire_lock_impl(class MDL_context *, class MDL_request *, class MDL_ticket * *);

	void materialize_fast_path_locks(class MDL_context *);

	bool fix_pins(class MDL_context *);

	void find_deadlock(class MDL_context *);

	bool visit_subgraph(class MDL_context *, class MDL_wait_for_graph_visitor *);

	void will_wait_for(class MDL_context *, class MDL_wait_for_subgraph *);

	void done_waiting_for(class MDL_context *);

	void lock_deadlock_victim(class MDL_context *);

	void unlock_deadlock_victim(class MDL_context *);

	void MDL_context(class MDL_context *, const class MDL_context  &);

	class MDL_context & operator=(class MDL_context *, class MDL_context &);

	void ~MDL_context(class MDL_context *, int);


	/* size: 288, cachelines: 5, members: 9 */
	/* sum members: 278, holes: 1, sum holes: 6 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 32 bytes */
};
class MDL_release_locks_visitor {
public:

	int ()(void) * *           _vptr.MDL_release_locks_visitor; /*     0     8 */
	virtual void ~MDL_release_locks_visitor(class MDL_release_locks_visitor *, int);

	virtual bool release(class MDL_release_locks_visitor *, class MDL_ticket *);

	/* vtable has 1 entries: {
	   [2] = release((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class MDL_context_visitor {
public:

	int ()(void) * *           _vptr.MDL_context_visitor; /*     0     8 */
	virtual void ~MDL_context_visitor(class MDL_context_visitor *, int);

	virtual void visit_context(class MDL_context_visitor *, const class MDL_context  *);

	/* vtable has 1 entries: {
	   [2] = visit_context((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Cost_model_table {
public:

	void Cost_model_table(class Cost_model_table *);

	void init(class Cost_model_table *, const class Cost_model_server  *, const class TABLE  *);

	double row_evaluate_cost(const class Cost_model_table  *, double);

	double key_compare_cost(const class Cost_model_table  *, double);

	double io_block_read_cost(const class Cost_model_table  *, double);

	double buffer_block_read_cost(const class Cost_model_table  *, double);

	double page_read_cost(const class Cost_model_table  *, double);

	double page_read_cost_index(const class Cost_model_table  *, uint, double);

	double disk_seek_base_cost(const class Cost_model_table  *);

	double disk_seek_prop_cost(const class Cost_model_table  *);

	double disk_seek_cost(const class Cost_model_table  *, double);

protected:

	const class Cost_model_server  * m_cost_model_server; /*     0     8 */
	const class SE_cost_constants  * m_se_cost_constants; /*     8     8 */
	const class TABLE  *       m_table;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Filesort_buffer {
public:

	void Filesort_buffer(class Filesort_buffer *);

	void sort_buffer(class Filesort_buffer *, const class Sort_param  *, uint);

	void reverse_record_pointers(class Filesort_buffer *);

	void init_record_pointers(class Filesort_buffer *);

	void init_next_record_pointer(class Filesort_buffer *);

	size_t space_used_for_data(const class Filesort_buffer  *);

	size_t spaceleft(const class Filesort_buffer  *);

	bool isfull(const class Filesort_buffer  *);

	uchar * get_next_record_pointer(class Filesort_buffer *);

	void adjust_next_record_pointer(class Filesort_buffer *, uint);

	size_t sort_buffer_size(const class Filesort_buffer  *);

	uchar * alloc_sort_buffer(class Filesort_buffer *, uint, uint);

	void free_sort_buffer(class Filesort_buffer *);

	uchar * * get_sort_keys(class Filesort_buffer *);

	uchar * get_sorted_record(class Filesort_buffer *, uint);

	class Bounds_checked_array<unsigned char> get_raw_buf(class Filesort_buffer *);

	class Filesort_buffer & operator=(class Filesort_buffer *, const class Filesort_buffer  &);

	uint get_sort_length(const class Filesort_buffer  *);

	void set_sort_length(class Filesort_buffer *, uint);

	uchar *                    m_next_rec_ptr;       /*     0     8 */
	uchar *                    m_rawmem;             /*     8     8 */
	uchar * *                  m_record_pointers;    /*    16     8 */
	uchar * *                  m_sort_keys;          /*    24     8 */
	uint                       m_num_records;        /*    32     4 */
	uint                       m_record_length;      /*    36     4 */
	uint                       m_sort_length;        /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     m_size_in_bytes;      /*    48     8 */
	longlong                   m_idx;                /*    56     8 */

	/* size: 64, cachelines: 1, members: 9 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
class Sort_param {
public:

	uint                       rec_length;           /*     0     4 */
	uint                       sort_length;          /*     4     4 */
	uint                       ref_length;           /*     8     4 */
	uint                       addon_length;         /*    12     4 */
	uint                       res_length;           /*    16     4 */
	uint                       max_keys_per_buffer;  /*    20     4 */
	ha_rows                    max_rows;             /*    24     8 */
	ha_rows                    examined_rows;        /*    32     8 */
	class TABLE *              sort_form;            /*    40     8 */
	bool                       use_hash;             /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	class Bounds_checked_array<st_sort_field> local_sortorder; /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	class Addon_fields *       addon_fields;         /*    72     8 */
	uchar *                    unique_buff;          /*    80     8 */
	bool                       not_killable;         /*    88     1 */
	bool                       using_pq;             /*    89     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     tmp_buffer;           /*    96     8 */
	struct Merge_chunk_compare_context cmp_context;  /*   104    16 */
	typedef int (*chunk_compare_fun)(class Merge_chunk_compare_context *, uchar *, uchar *);

	chunk_compare_fun          compare;              /*   120     8 */
	void Sort_param(class Sort_param *);

	void init_for_filesort(class Sort_param *, class Filesort *, uint, class TABLE *, ulong, ha_rows, bool);

	void try_to_pack_addons(class Sort_param *, ulong);

	bool using_packed_addons(const class Sort_param  *);

	bool using_addon_fields(const class Sort_param  *);

	uint make_sortkey(class Sort_param *, uchar *, const uchar  *);

	size_t compare_length(const class Sort_param  *);

	void get_rec_and_res_len(class Sort_param *, uchar *, uint *, uint *);

	/* --- cacheline 2 boundary (128 bytes) --- */
	uint                       m_packable_length;    /*   128     4 */
	bool                       m_using_packed_addons; /*   132     1 */
	void Sort_param(class Sort_param *, const class Sort_param  &);

	class Sort_param & operator=(class Sort_param *, const class Sort_param  &);


	/* size: 136, cachelines: 3, members: 20 */
	/* sum members: 120, holes: 2, sum holes: 13 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
class Bounds_checked_array<unsigned char> {
public:

	void Bounds_checked_array(class Bounds_checked_array<unsigned char> *);

	void Bounds_checked_array(class Bounds_checked_array<unsigned char> *, unsigned char *, size_t);

	void reset(class Bounds_checked_array<unsigned char> *);

	void reset(class Bounds_checked_array<unsigned char> *, unsigned char *, size_t);

	void resize(class Bounds_checked_array<unsigned char> *, size_t);

	unsigned char & operator[](class Bounds_checked_array<unsigned char> *, size_t);

	const unsigned char  & operator[](const class Bounds_checked_array<unsigned char>  *, size_t);

	typedef unsigned char * iterator;

	iterator begin(class Bounds_checked_array<unsigned char> *);

	iterator end(class Bounds_checked_array<unsigned char> *);

	typedef const unsigned char  * const_iterator;

	const_iterator begin(const class Bounds_checked_array<unsigned char>  *);

	const_iterator end(const class Bounds_checked_array<unsigned char>  *);

	size_t element_size(const class Bounds_checked_array<unsigned char>  *);

	size_t size(const class Bounds_checked_array<unsigned char>  *);

	bool is_null(const class Bounds_checked_array<unsigned char>  *);

	void pop_front(class Bounds_checked_array<unsigned char> *);

	unsigned char * array(const class Bounds_checked_array<unsigned char>  *);

	bool operator==(const class Bounds_checked_array<unsigned char>  *, const class Bounds_checked_array<unsigned char>  &);

	bool operator!=(const class Bounds_checked_array<unsigned char>  *, const class Bounds_checked_array<unsigned char>  &);

	unsigned char *            m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_sort_field {
	class Field *              field;                /*     0     8 */
	class Item *               item;                 /*     8     8 */
	uint                       length;               /*    16     4 */
	uint                       suffix_length;        /*    20     4 */
	enum Item_result           result_type;          /*    24     4 */
	enum_field_types           field_type;           /*    28     4 */
	bool                       reverse;              /*    32     1 */
	bool                       need_strxnfrm;        /*    33     1 */

	/* size: 40, cachelines: 1, members: 8 */
	/* padding: 6 */
	/* last cacheline: 40 bytes */
};
struct Sort_addon_field {
	class Field *              field;                /*     0     8 */
	uint                       offset;               /*     8     4 */
	uint                       null_offset;          /*    12     4 */
	uint                       max_length;           /*    16     4 */
	uint8                      null_bit;             /*    20     1 */

	/* size: 24, cachelines: 1, members: 5 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct Merge_chunk_compare_context {
	qsort_cmp2                 key_compare;          /*     0     8 */
	const void  *              key_compare_arg;      /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Merge_chunk {
	void Merge_chunk(class Merge_chunk *);

	my_off_t file_position(const class Merge_chunk  *);

	void set_file_position(class Merge_chunk *, my_off_t);

	void advance_file_position(class Merge_chunk *, my_off_t);

	uchar * buffer_start(class Merge_chunk *);

	const uchar  * buffer_end(const class Merge_chunk  *);

	void set_buffer(class Merge_chunk *, uchar *, uchar *);

	void set_buffer_start(class Merge_chunk *, uchar *);

	void set_buffer_end(class Merge_chunk *, uchar *);

	void init_current_key(class Merge_chunk *);

	uchar * current_key(class Merge_chunk *);

	void advance_current_key(class Merge_chunk *, uint);

	void decrement_rowcount(class Merge_chunk *, ha_rows);

	void set_rowcount(class Merge_chunk *, ha_rows);

	ha_rows rowcount(const class Merge_chunk  *);

	ha_rows mem_count(const class Merge_chunk  *);

	void set_mem_count(class Merge_chunk *, ha_rows);

	ha_rows decrement_mem_count(class Merge_chunk *);

	ha_rows max_keys(const class Merge_chunk  *);

	void set_max_keys(class Merge_chunk *, ha_rows);

	size_t buffer_size(const class Merge_chunk  *);

	bool merge_freed_buff(const class Merge_chunk  *, class Merge_chunk *);

private:

	uchar *                    m_current_key;        /*     0     8 */
	my_off_t                   m_file_position;      /*     8     8 */
	uchar *                    m_buffer_start;       /*    16     8 */
	uchar *                    m_buffer_end;         /*    24     8 */
	ha_rows                    m_rowcount;           /*    32     8 */
	ha_rows                    m_mem_count;          /*    40     8 */
	ha_rows                    m_max_keys;           /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
class Bounds_checked_array<Sort_addon_field> {
public:

	void Bounds_checked_array(class Bounds_checked_array<Sort_addon_field> *);

	void Bounds_checked_array(class Bounds_checked_array<Sort_addon_field> *, class Sort_addon_field *, size_t);

	void reset(class Bounds_checked_array<Sort_addon_field> *);

	void reset(class Bounds_checked_array<Sort_addon_field> *, class Sort_addon_field *, size_t);

	void resize(class Bounds_checked_array<Sort_addon_field> *, size_t);

	class Sort_addon_field & operator[](class Bounds_checked_array<Sort_addon_field> *, size_t);

	const class Sort_addon_field  & operator[](const class Bounds_checked_array<Sort_addon_field>  *, size_t);

	typedef class Sort_addon_field * iterator;

	iterator begin(class Bounds_checked_array<Sort_addon_field> *);

	iterator end(class Bounds_checked_array<Sort_addon_field> *);

	typedef const class Sort_addon_field  * const_iterator;

	const_iterator begin(const class Bounds_checked_array<Sort_addon_field>  *);

	const_iterator end(const class Bounds_checked_array<Sort_addon_field>  *);

	size_t element_size(const class Bounds_checked_array<Sort_addon_field>  *);

	size_t size(const class Bounds_checked_array<Sort_addon_field>  *);

	bool is_null(const class Bounds_checked_array<Sort_addon_field>  *);

	void pop_front(class Bounds_checked_array<Sort_addon_field> *);

	class Sort_addon_field * array(const class Bounds_checked_array<Sort_addon_field>  *);

	bool operator==(const class Bounds_checked_array<Sort_addon_field>  *, const class Bounds_checked_array<Sort_addon_field>  &);

	bool operator!=(const class Bounds_checked_array<Sort_addon_field>  *, const class Bounds_checked_array<Sort_addon_field>  &);

	class Sort_addon_field *   m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Bounds_checked_array<Merge_chunk> {
public:

	void Bounds_checked_array(class Bounds_checked_array<Merge_chunk> *);

	void Bounds_checked_array(class Bounds_checked_array<Merge_chunk> *, class Merge_chunk *, size_t);

	void reset(class Bounds_checked_array<Merge_chunk> *);

	void reset(class Bounds_checked_array<Merge_chunk> *, class Merge_chunk *, size_t);

	void resize(class Bounds_checked_array<Merge_chunk> *, size_t);

	class Merge_chunk & operator[](class Bounds_checked_array<Merge_chunk> *, size_t);

	const class Merge_chunk  & operator[](const class Bounds_checked_array<Merge_chunk>  *, size_t);

	typedef class Merge_chunk * iterator;

	iterator begin(class Bounds_checked_array<Merge_chunk> *);

	iterator end(class Bounds_checked_array<Merge_chunk> *);

	typedef const class Merge_chunk  * const_iterator;

	const_iterator begin(const class Bounds_checked_array<Merge_chunk>  *);

	const_iterator end(const class Bounds_checked_array<Merge_chunk>  *);

	size_t element_size(const class Bounds_checked_array<Merge_chunk>  *);

	size_t size(const class Bounds_checked_array<Merge_chunk>  *);

	bool is_null(const class Bounds_checked_array<Merge_chunk>  *);

	void pop_front(class Bounds_checked_array<Merge_chunk> *);

	class Merge_chunk * array(const class Bounds_checked_array<Merge_chunk>  *);

	bool operator==(const class Bounds_checked_array<Merge_chunk>  *, const class Bounds_checked_array<Merge_chunk>  &);

	bool operator!=(const class Bounds_checked_array<Merge_chunk>  *, const class Bounds_checked_array<Merge_chunk>  &);

	class Merge_chunk *        m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Addon_fields {
public:

	void Addon_fields(class Addon_fields *, Addon_fields_array);

	class Sort_addon_field * begin(class Addon_fields *);

	class Sort_addon_field * end(class Addon_fields *);

	size_t num_field_descriptors(const class Addon_fields  *);

	uchar * allocate_addon_buf(class Addon_fields *, uint);

	uchar * get_addon_buf(class Addon_fields *);

	uint get_addon_buf_length(const class Addon_fields  *);

	void set_using_packed_addons(class Addon_fields *, bool);

	bool using_packed_addons(const class Addon_fields  *);

	bool can_pack_addon_fields(uint);

	uint read_addon_length(uchar *);

	void store_addon_length(uchar *, uint);

	static const uint                 size_of_length_field = 2; /*     0     0 */
	Addon_fields_array         m_field_descriptors;  /*     0    16 */
	uchar *                    m_addon_buf;          /*    16     8 */
	uint                       m_addon_buf_length;   /*    24     4 */
	bool                       m_using_packed_addons; /*    28     1 */

	/* size: 32, cachelines: 1, members: 4, static members: 1 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */
};
class Bounds_checked_array<st_sort_field> {
public:

	void Bounds_checked_array(class Bounds_checked_array<st_sort_field> *);

	void Bounds_checked_array(class Bounds_checked_array<st_sort_field> *, class st_sort_field *, size_t);

	void reset(class Bounds_checked_array<st_sort_field> *);

	void reset(class Bounds_checked_array<st_sort_field> *, class st_sort_field *, size_t);

	void resize(class Bounds_checked_array<st_sort_field> *, size_t);

	class st_sort_field & operator[](class Bounds_checked_array<st_sort_field> *, size_t);

	const class st_sort_field  & operator[](const class Bounds_checked_array<st_sort_field>  *, size_t);

	typedef class st_sort_field * iterator;

	iterator begin(class Bounds_checked_array<st_sort_field> *);

	iterator end(class Bounds_checked_array<st_sort_field> *);

	typedef const class st_sort_field  * const_iterator;

	const_iterator begin(const class Bounds_checked_array<st_sort_field>  *);

	const_iterator end(const class Bounds_checked_array<st_sort_field>  *);

	size_t element_size(const class Bounds_checked_array<st_sort_field>  *);

	size_t size(const class Bounds_checked_array<st_sort_field>  *);

	bool is_null(const class Bounds_checked_array<st_sort_field>  *);

	void pop_front(class Bounds_checked_array<st_sort_field> *);

	class st_sort_field * array(const class Bounds_checked_array<st_sort_field>  *);

	bool operator==(const class Bounds_checked_array<st_sort_field>  *, const class Bounds_checked_array<st_sort_field>  &);

	bool operator!=(const class Bounds_checked_array<st_sort_field>  *, const class Bounds_checked_array<st_sort_field>  &);

	class st_sort_field *      m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Filesort_info {
	class Filesort_buffer     filesort_buffer;       /*     0    64 */
public:

	/* --- cacheline 1 boundary (64 bytes) --- */
	IO_CACHE *                 io_cache;             /*    64     8 */
	Merge_chunk_array          merge_chunks;         /*    72    16 */
	class Addon_fields *       addon_fields;         /*    88     8 */
	bool                       sorted_result_in_fsbuf; /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	uchar *                    sorted_result;        /*   104     8 */
	uchar *                    sorted_result_end;    /*   112     8 */
	ha_rows                    found_records;        /*   120     8 */
	void Filesort_info(class Filesort_info *);

	bool has_filesort_result_in_memory(const class Filesort_info  *);

	bool has_filesort_result(const class Filesort_info  *);

	void sort_buffer(class Filesort_info *, class Sort_param *, uint);

	void read_chunk_descriptors(class Filesort_info *, IO_CACHE *, uint);

	bool using_addon_fields(const class Filesort_info  *);

	bool using_packed_addons(const class Filesort_info  *);

	size_t space_used_for_data(const class Filesort_info  *);

	bool isfull(const class Filesort_info  *);

	void init_next_record_pointer(class Filesort_info *);

	uchar * get_next_record_pointer(class Filesort_info *);

	void adjust_next_record_pointer(class Filesort_info *, uint32);

	uchar * get_sorted_record(class Filesort_info *, uint);

	uchar * * get_sort_keys(class Filesort_info *);

	class Bounds_checked_array<unsigned char> get_raw_buf(class Filesort_info *);

	uchar * alloc_sort_buffer(class Filesort_info *, uint, uint);

	void free_sort_buffer(class Filesort_info *);

	void init_record_pointers(class Filesort_info *);

	size_t sort_buffer_size(const class Filesort_info  *);

	uint get_sort_length(const class Filesort_info  *);

	void set_sort_length(class Filesort_info *, uint);


	/* size: 128, cachelines: 2, members: 8 */
	/* sum members: 121, holes: 1, sum holes: 7 */
};
class Table_id {
	static const long long unsigned int TABLE_ID_MAX = 281474976710655; /*     0     0 */
	uint64_t                   m_id;                 /*     0     8 */
public:

	void Table_id(class Table_id *);

	void Table_id(class Table_id *, long long unsigned int);

	void Table_id(class Table_id *, const class Table_id  &);

	long long unsigned int id(const class Table_id  *);

	bool is_valid(const class Table_id  *);

	void operator=(class Table_id *, const class Table_id  &);

	void operator=(class Table_id *, long long unsigned int);

	bool operator==(const class Table_id  *, const class Table_id  &);

	bool operator!=(const class Table_id  *, const class Table_id  &);

	long long unsigned int operator long long unsigned int(const class Table_id  *);

	class Table_id operator++(class Table_id *, int);


	/* size: 8, cachelines: 1, members: 1, static members: 1 */
	/* last cacheline: 8 bytes */
};
struct st_mysql_lock {
	class TABLE * *            table;                /*     0     8 */
	uint                       table_count;          /*     8     4 */
	uint                       lock_count;           /*    12     4 */
	THR_LOCK_DATA * *          locks;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct st_order {
	enum enum_order {
		ORDER_NOT_RELEVANT = 0,
		ORDER_ASC          = 1,
		ORDER_DESC         = 2,
	};

	class st_order *           next;                 /*     0     8 */
	class Item * *             item;                 /*     8     8 */
	class Item *               item_ptr;             /*    16     8 */
	enum enum_order            direction;            /*    24     4 */
	bool                       in_field_list;        /*    28     1 */
	bool                       used_alias;           /*    29     1 */

	/* XXX 2 bytes hole, try to pack */

	class Field *              field;                /*    32     8 */
	char *                     buff;                 /*    40     8 */
	table_map                  used;                 /*    48     8 */
	table_map                  depend_map;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       is_position;          /*    64     1 */

	/* size: 72, cachelines: 2, members: 11 */
	/* sum members: 63, holes: 1, sum holes: 2 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
struct st_grant_internal_info {
	void st_grant_internal_info(class st_grant_internal_info *);

	bool                       m_schema_lookup_done; /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	const class ACL_internal_schema_access  * m_schema_access; /*     8     8 */
	bool                       m_table_lookup_done;  /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	const class ACL_internal_table_access  * m_table_access; /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct GRANT_INFO {
	void GRANT_INFO(class GRANT_INFO *);

	class GRANT_TABLE *        grant_table;          /*     0     8 */
	uint                       version;              /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      privilege;            /*    16     8 */
	GRANT_INTERNAL_INFO        m_internal;           /*    24    32 */

	/* size: 56, cachelines: 1, members: 4 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct st_table_field_type {
	LEX_STRING                 name;                 /*     0    16 */
	LEX_STRING                 type;                 /*    16    16 */
	LEX_STRING                 cset;                 /*    32    16 */

	/* size: 48, cachelines: 1, members: 3 */
	/* last cacheline: 48 bytes */
};
struct st_table_field_def {
	uint                       count;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const TABLE_FIELD_TYPE  *  field;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, I_P_List_null_counter, I_P_List_no_push_back<Wait_for_flush> > : public I_P_List_null_counter, public I_P_List_no_push_back<Wait_for_flush> {
public:

	/* class I_P_List_null_counter <ancestor>; */    /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	/* class I_P_List_no_push_back<Wait_for_flush> <ancestor>; */ /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class Wait_for_flush *     m_first;              /*     0     8 */
	void I_P_List(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	void empty(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	bool is_empty(const class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_);

	void push_front(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *);

	void push_back(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *);

	void insert_after(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *, class Wait_for_flush *);

	void remove(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class Wait_for_flush *);

	class Wait_for_flush * front(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	const class Wait_for_flush  * front(const class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_);

	class Wait_for_flush * pop_front(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);

	void swap(class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>, class I_P_List<Wait_for_flush, I_P_List_adapter<Wait_for_flush, &Wait_for_flush::next_in_share, &Wait_for_flush::prev_in_share>);


	/* size: 8, cachelines: 1, members: 3 */
	/* paddings: 2, sum paddings: 2 */
	/* last cacheline: 8 bytes */
};
class I_P_List_no_push_back<Wait_for_flush> {
protected:

	void I_P_List_no_push_back(class I_P_List_no_push_back<Wait_for_flush> *, class Wait_for_flush * *);

	void set_last(class I_P_List_no_push_back<Wait_for_flush> *, class Wait_for_flush * *);

	void swap(class I_P_List_no_push_back<Wait_for_flush> *, class I_P_List_no_push_back<Wait_for_flush> &);


	/* size: 1, cachelines: 0, members: 0 */
	/* padding: 1 */
	/* last cacheline: 1 bytes */
};
class Handler_share {
public:

	int ()(void) * *           _vptr.Handler_share;  /*     0     8 */
	void Handler_share(class Handler_share *);

	virtual void ~Handler_share(class Handler_share *, int);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Blob_mem_storage : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	MEM_ROOT                   storage;              /*     0    88 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	bool                       truncated_value;      /*    88     1 */
	void Blob_mem_storage(class Blob_mem_storage *);

	void ~Blob_mem_storage(class Blob_mem_storage *, int);

	void reset(class Blob_mem_storage *);

	char * store(class Blob_mem_storage *, const char  *, size_t);

	void set_truncated_value(class Blob_mem_storage *, bool);

	bool is_truncated_value(class Blob_mem_storage *);


	/* size: 96, cachelines: 2, members: 3 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 32 bytes */
};
class Bitmap<4096> {
	MY_BITMAP                  map;                  /*     0    32 */
	uint32                     buffer[128];          /*    32   512 */
public:

	void Bitmap(class Bitmap<4096> *);

	void Bitmap(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void Bitmap(class Bitmap<4096> *, uint);

	void init(class Bitmap<4096> *);

	void init(class Bitmap<4096> *, uint);

	uint length(const class Bitmap<4096>  *);

	class Bitmap<4096> & operator=(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void set_bit(class Bitmap<4096> *, uint);

	void clear_bit(class Bitmap<4096> *, uint);

	void set_prefix(class Bitmap<4096> *, uint);

	void set_all(class Bitmap<4096> *);

	void clear_all(class Bitmap<4096> *);

	void intersect(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void intersect(class Bitmap<4096> *, ulonglong);

	void intersect_extended(class Bitmap<4096> *, ulonglong);

	void subtract(class Bitmap<4096> *, const class Bitmap<4096>  &);

	void merge(class Bitmap<4096> *, const class Bitmap<4096>  &);

	my_bool is_set(const class Bitmap<4096>  *, uint);

	my_bool is_prefix(const class Bitmap<4096>  *, uint);

	my_bool is_clear_all(const class Bitmap<4096>  *);

	my_bool is_set_all(const class Bitmap<4096>  *);

	my_bool is_subset(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	my_bool is_overlapping(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	my_bool operator==(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	my_bool operator!=(const class Bitmap<4096>  *, const class Bitmap<4096>  &);

	char * print(const class Bitmap<4096>  *, char *);

	ulonglong to_ulonglong(const class Bitmap<4096>  *);

	uint bits_set(const class Bitmap<4096>  *);


	/* size: 544, cachelines: 9, members: 2 */
	/* last cacheline: 32 bytes */
};
class List<Item> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Item> *);

	void List(class List<Item> *, const class List<Item>  &);

	class List<Item> & operator=(class List<Item> *, const class List<Item>  &);

	void List(class List<Item> *, const class List<Item>  &, MEM_ROOT *);

	bool push_back(class List<Item> *, class Item *);

	bool push_back(class List<Item> *, class Item *, MEM_ROOT *);

	bool push_front(class List<Item> *, class Item *);

	bool push_front(class List<Item> *, class Item *, MEM_ROOT *);

	class Item * head(class List<Item> *);

	class Item * * head_ref(class List<Item> *);

	class Item * pop(class List<Item> *);

	void concat(class List<Item> *, class List<Item> *);

	void disjoin(class List<Item> *, class List<Item> *);

	void prepand(class List<Item> *, class List<Item> *);

	void delete_elements(class List<Item> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class List<Create_field> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Create_field> *);

	void List(class List<Create_field> *, const class List<Create_field>  &);

	class List<Create_field> & operator=(class List<Create_field> *, const class List<Create_field>  &);

	void List(class List<Create_field> *, const class List<Create_field>  &, MEM_ROOT *);

	bool push_back(class List<Create_field> *, class Create_field *);

	bool push_back(class List<Create_field> *, class Create_field *, MEM_ROOT *);

	bool push_front(class List<Create_field> *, class Create_field *);

	bool push_front(class List<Create_field> *, class Create_field *, MEM_ROOT *);

	class Create_field * head(class List<Create_field> *);

	class Create_field * * head_ref(class List<Create_field> *);

	class Create_field * pop(class List<Create_field> *);

	void concat(class List<Create_field> *, class List<Create_field> *);

	void disjoin(class List<Create_field> *, class List<Create_field> *);

	void prepand(class List<Create_field> *, class List<Create_field> *);

	void delete_elements(class List<Create_field> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct st_field_info {
	const char  *              field_name;           /*     0     8 */
	uint                       field_length;         /*     8     4 */
	enum enum_field_types      field_type;           /*    12     4 */
	int                        value;                /*    16     4 */
	uint                       field_flags;          /*    20     4 */
	const char  *              old_name;             /*    24     8 */
	uint                       open_method;          /*    32     4 */

	/* size: 40, cachelines: 1, members: 7 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct st_schema_table {
	const char  *              table_name;           /*     0     8 */
	ST_FIELD_INFO *            fields_info;          /*     8     8 */
	class TABLE *              (*create_table)(class THD *, class TABLE_LIST *); /*    16     8 */
	int                        (*fill_table)(class THD *, class TABLE_LIST *, class Item *); /*    24     8 */
	int                        (*old_format)(class THD *, class st_schema_table *); /*    32     8 */
	int                        (*process_table)(class THD *, class TABLE_LIST *, class TABLE *, bool, LEX_STRING *, LEX_STRING *); /*    40     8 */
	int                        idx_field1;           /*    48     4 */
	int                        idx_field2;           /*    52     4 */
	bool                       hidden;               /*    56     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       i_s_requested_object; /*    60     4 */

	/* size: 64, cachelines: 1, members: 10 */
	/* sum members: 61, holes: 1, sum holes: 3 */
};
struct Field_translator {
	class Item *               item;                 /*     0     8 */
	const char  *              name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_lex_alter {
	bool                       update_password_expired_fields; /*     0     1 */
	bool                       update_password_expired_column; /*     1     1 */
	bool                       use_default_password_lifetime; /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	uint16                     expire_after_days;    /*     4     2 */
	bool                       update_account_locked_column; /*     6     1 */
	bool                       account_locked;       /*     7     1 */

	/* size: 8, cachelines: 1, members: 6 */
	/* sum members: 7, holes: 1, sum holes: 1 */
	/* last cacheline: 8 bytes */
};
struct st_lex_user {
	LEX_CSTRING                user;                 /*     0    16 */
	LEX_CSTRING                host;                 /*    16    16 */
	LEX_CSTRING                plugin;               /*    32    16 */
	LEX_CSTRING                auth;                 /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       uses_identified_by_clause; /*    64     1 */
	bool                       uses_identified_with_clause; /*    65     1 */
	bool                       uses_authentication_string_clause; /*    66     1 */
	bool                       uses_identified_by_password_clause; /*    67     1 */
	LEX_ALTER                  alter_status;         /*    68     8 */

	/* size: 80, cachelines: 2, members: 9 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
class Derived_key : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	table_map                  referenced_by;        /*     0     8 */
	Field_map                  used_fields;          /*     8   544 */

	/* size: 552, cachelines: 9, members: 3 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 40 bytes */
};
class List<Derived_key> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Derived_key> *);

	void List(class List<Derived_key> *, const class List<Derived_key>  &);

	class List<Derived_key> & operator=(class List<Derived_key> *, const class List<Derived_key>  &);

	void List(class List<Derived_key> *, const class List<Derived_key>  &, MEM_ROOT *);

	bool push_back(class List<Derived_key> *, class Derived_key *);

	bool push_back(class List<Derived_key> *, class Derived_key *, MEM_ROOT *);

	bool push_front(class List<Derived_key> *, class Derived_key *);

	bool push_front(class List<Derived_key> *, class Derived_key *, MEM_ROOT *);

	class Derived_key * head(class List<Derived_key> *);

	class Derived_key * * head_ref(class List<Derived_key> *);

	class Derived_key * pop(class List<Derived_key> *);

	void concat(class List<Derived_key> *, class List<Derived_key> *);

	void disjoin(class List<Derived_key> *, class List<Derived_key> *);

	void prepand(class List<Derived_key> *, class List<Derived_key> *);

	void delete_elements(class List<Derived_key> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class List<TABLE_LIST> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<TABLE_LIST> *);

	void List(class List<TABLE_LIST> *, const class List<TABLE_LIST>  &);

	class List<TABLE_LIST> & operator=(class List<TABLE_LIST> *, const class List<TABLE_LIST>  &);

	void List(class List<TABLE_LIST> *, const class List<TABLE_LIST>  &, MEM_ROOT *);

	bool push_back(class List<TABLE_LIST> *, class TABLE_LIST *);

	bool push_back(class List<TABLE_LIST> *, class TABLE_LIST *, MEM_ROOT *);

	bool push_front(class List<TABLE_LIST> *, class TABLE_LIST *);

	bool push_front(class List<TABLE_LIST> *, class TABLE_LIST *, MEM_ROOT *);

	class TABLE_LIST * head(class List<TABLE_LIST> *);

	class TABLE_LIST * * head_ref(class List<TABLE_LIST> *);

	class TABLE_LIST * pop(class List<TABLE_LIST> *);

	void concat(class List<TABLE_LIST> *, class List<TABLE_LIST> *);

	void disjoin(class List<TABLE_LIST> *, class List<TABLE_LIST> *);

	void prepand(class List<TABLE_LIST> *, class List<TABLE_LIST> *);

	void delete_elements(class List<TABLE_LIST> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class st_select_lex_unit : public Sql_alloc {
	enum enum_clean_state {
		UC_DIRTY      = 0,
		UC_PART_CLEAN = 1,
		UC_CLEAN      = 2,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class st_select_lex_unit * next;                 /*     0     8 */
	class st_select_lex_unit * * prev;               /*     8     8 */
	SELECT_LEX *               master;               /*    16     8 */
	SELECT_LEX *               slave;                /*    24     8 */
	enum enum_parsing_context  explain_marker;       /*    32     4 */
	bool                       prepared;             /*    36     1 */
	bool                       optimized;            /*    37     1 */
	bool                       executed;             /*    38     1 */

	/* XXX 1 byte hole, try to pack */

	struct TABLE_LIST          result_table_list;    /*    40  1408 */
	/* --- cacheline 22 boundary (1408 bytes) was 40 bytes ago --- */
	class Query_result_union * union_result;         /*  1448     8 */
	class TABLE *              table;                /*  1456     8 */
	class Query_result *       m_query_result;       /*  1464     8 */
	/* --- cacheline 23 boundary (1472 bytes) --- */
	uint8                      uncacheable;          /*  1472     1 */

	/* XXX 3 bytes hole, try to pack */
	void st_select_lex_unit(class st_select_lex_unit *, enum enum_parsing_context);

	bool is_simple(const class st_select_lex_unit  *);


	enum enum_clean_state      cleaned;              /*  1476     4 */
	class List<Item>          item_list;             /*  1480    24 */
	class List<Item>          types;                 /*  1504    24 */
	class st_select_lex * global_parameters(const class st_select_lex_unit  *);

	ha_rows                    select_limit_cnt;     /*  1528     8 */
	/* --- cacheline 24 boundary (1536 bytes) --- */
	ha_rows                    offset_limit_cnt;     /*  1536     8 */
	class Item_subselect *     item;                 /*  1544     8 */
	class THD *                thd;                  /*  1552     8 */
	class st_select_lex *      fake_select_lex;      /*  1560     8 */
	class st_select_lex *      saved_fake_select_lex; /*  1568     8 */
	class st_select_lex *      union_distinct;       /*  1576     8 */
	bool is_mergeable(const class st_select_lex_unit  *);

	class st_select_lex * outer_select(const class st_select_lex_unit  *);

	class st_select_lex * first_select(const class st_select_lex_unit  *);

	class st_select_lex_unit * next_unit(const class st_select_lex_unit  *);

	class Query_result * query_result(const class st_select_lex_unit  *);

	void set_query_result(class st_select_lex_unit *, class Query_result *);

	bool prepare(class st_select_lex_unit *, class THD *, class Query_result *, ulonglong, ulonglong);

	bool optimize(class st_select_lex_unit *, class THD *);

	bool execute(class st_select_lex_unit *, class THD *);

	bool explain(class st_select_lex_unit *, class THD *);

	bool cleanup(class st_select_lex_unit *, bool);

	void unclean(class st_select_lex_unit *);

	void reinit_exec_mechanism(class st_select_lex_unit *);

	void print(class st_select_lex_unit *, class String *, enum enum_query_type);

	bool accept(class st_select_lex_unit *, class Select_lex_visitor *);

	bool add_fake_select_lex(class st_select_lex_unit *, class THD *);

	bool prepare_fake_select_lex(class st_select_lex_unit *, class THD *);

	void set_prepared(class st_select_lex_unit *);

	void set_optimized(class st_select_lex_unit *);

	void set_executed(class st_select_lex_unit *);

	void reset_executed(class st_select_lex_unit *);

	bool is_prepared(const class st_select_lex_unit  *);

	bool is_optimized(const class st_select_lex_unit  *);

	bool is_executed(const class st_select_lex_unit  *);

	bool change_query_result(class st_select_lex_unit *, class Query_result_interceptor *, class Query_result_interceptor *);

	void set_limit(class st_select_lex_unit *, class st_select_lex *);

	void set_thd(class st_select_lex_unit *, class THD *);

	bool is_union(const class st_select_lex_unit  *);

	bool union_needs_tmp_table(class st_select_lex_unit *);

	void include_down(class st_select_lex_unit *, class LEX *, class st_select_lex *);

	void include_chain(class st_select_lex_unit *, class LEX *, class st_select_lex *);

	void exclude_level(class st_select_lex_unit *);

	void exclude_tree(class st_select_lex_unit *);

	void renumber_selects(class st_select_lex_unit *, class LEX *);

	class List<Item> * get_unit_column_types(class st_select_lex_unit *);

	class List<Item> * get_field_list(class st_select_lex_unit *);

	enum enum_parsing_context get_explain_marker(const class st_select_lex_unit  *);

	void set_explain_marker(class st_select_lex_unit *, enum enum_parsing_context);

	void set_explain_marker_from(class st_select_lex_unit *, const class st_select_lex_unit  *);

	void assert_not_fully_clean(class st_select_lex_unit *);

	void invalidate(class st_select_lex_unit *);


	/* size: 1584, cachelines: 25, members: 24 */
	/* sum members: 1580, holes: 2, sum holes: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 48 bytes */
};
class Opt_hints_table : public Opt_hints {
public:

	/* class Opt_hints           <ancestor>; */      /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class Mem_root_array<Opt_hints_key*, true> keyinfo_array; /*    80    32 */
	void Opt_hints_table(class Opt_hints_table *, const LEX_CSTRING  *, class Opt_hints_qb *, MEM_ROOT *);

	virtual void append_name(class Opt_hints_table *, class THD *, class String *);

	void adjust_key_hints(class Opt_hints_table *, class TABLE *);

	/* vtable has 1 entries: {
	   [2] = append_name((null)), 
	} */
	/* size: 112, cachelines: 2, members: 2 */
	/* last cacheline: 48 bytes */

	/* BRAIN FART ALERT! 112 bytes != 32 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 640 bits */
};
class List<String> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<String> *);

	void List(class List<String> *, const class List<String>  &);

	class List<String> & operator=(class List<String> *, const class List<String>  &);

	void List(class List<String> *, const class List<String>  &, MEM_ROOT *);

	bool push_back(class List<String> *, class String *);

	bool push_back(class List<String> *, class String *, MEM_ROOT *);

	bool push_front(class List<String> *, class String *);

	bool push_front(class List<String> *, class String *, MEM_ROOT *);

	class String * head(class List<String> *);

	class String * * head_ref(class List<String> *);

	class String * pop(class List<String> *);

	void concat(class List<String> *, class List<String> *);

	void disjoin(class List<String> *, class List<String> *);

	void prepand(class List<String> *, class List<String> *);

	void delete_elements(class List<String> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Temp_table_param : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	/* XXX 8 bytes hole, try to pack */

	class List<Item>          copy_funcs;            /*     8    24 */
	class Copy_field *         copy_field;           /*    32     8 */
	class Copy_field *         copy_field_end;       /*    40     8 */
	uchar *                    group_buff;           /*    48     8 */
	Func_ptr_array *           items_to_copy;        /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	MI_COLUMNDEF *             recinfo;              /*    64     8 */
	MI_COLUMNDEF *             start_recinfo;        /*    72     8 */
	KEY *                      keyinfo;              /*    80     8 */
	ha_rows                    end_write_records;    /*    88     8 */
	uint                       field_count;          /*    96     4 */
	uint                       func_count;           /*   100     4 */
	uint                       sum_func_count;       /*   104     4 */
	uint                       hidden_field_count;   /*   108     4 */
	uint                       group_parts;          /*   112     4 */
	uint                       group_length;         /*   116     4 */
	uint                       group_null_parts;     /*   120     4 */
	uint                       quick_group;          /*   124     4 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint                       outer_sum_func_count; /*   128     4 */
	bool                       using_outer_summary_function; /*   132     1 */

	/* XXX 3 bytes hole, try to pack */

	CHARSET_INFO *             table_charset;        /*   136     8 */
	bool                       schema_table;         /*   144     1 */
	bool                       precomputed_group_by; /*   145     1 */
	bool                       force_copy_fields;    /*   146     1 */
	bool                       skip_create_table;    /*   147     1 */
	bool                       bit_fields_as_long;   /*   148     1 */
	bool                       can_use_pk_for_unique; /*   149     1 */
	void Temp_table_param(class Temp_table_param *);

	void ~Temp_table_param(class Temp_table_param *, int);

	void cleanup(class Temp_table_param *);


	/* size: 152, cachelines: 3, members: 27 */
	/* sum members: 139, holes: 2, sum holes: 11 */
	/* padding: 2 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
struct st_nested_join {
	void st_nested_join(class st_nested_join *);

	class List<TABLE_LIST>    join_list;             /*     0    24 */
	table_map                  used_tables;          /*    24     8 */
	table_map                  not_null_tables;      /*    32     8 */
	plan_idx                   first_nested;         /*    40     1 */
	bool                       natural_join_processed; /*    41     1 */

	/* XXX 2 bytes hole, try to pack */

	uint                       nj_total;             /*    44     4 */
	uint                       nj_counter;           /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	nested_join_map            nj_map;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	table_map                  sj_depends_on;        /*    64     8 */
	table_map                  sj_corr_tables;       /*    72     8 */
	uint                       query_block_id;       /*    80     4 */
	uint                       sj_enabled_strategies; /*    84     4 */
	class List<Item>          sj_outer_exprs;        /*    88    24 */
	class List<Item>          sj_inner_exprs;        /*   112    24 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	struct Semijoin_mat_optimize sjm;                /*   136   128 */

	/* size: 264, cachelines: 5, members: 15 */
	/* sum members: 258, holes: 2, sum holes: 6 */
	/* last cacheline: 8 bytes */
};
class View_creation_ctx : public Default_object_creation_ctx, public Sql_alloc {
public:

	/* class Default_object_creation_ctx <ancestor>; */ /*     0     0 */
	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	class View_creation_ctx * create(class THD *);

	class View_creation_ctx * create(class THD *, class TABLE_LIST *);

	void View_creation_ctx(class View_creation_ctx *, class THD *);

	virtual void ~View_creation_ctx(class View_creation_ctx *, int);


	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 24 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
struct Semijoin_mat_optimize {
	class st_position *        positions;            /*     0     8 */
	bool                       lookup_allowed;       /*     8     1 */
	bool                       scan_allowed;         /*     9     1 */

	/* XXX 6 bytes hole, try to pack */

	double                     expected_rowcount;    /*    16     8 */
	class Cost_estimate       materialization_cost;  /*    24    32 */
	class Cost_estimate       lookup_cost;           /*    56    32 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	class Cost_estimate       scan_cost;             /*    88    32 */
	class Item_field * *       mat_fields;           /*   120     8 */

	/* size: 128, cachelines: 2, members: 8 */
	/* sum members: 122, holes: 1, sum holes: 6 */
};
class Generated_column : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class Item *               expr_item;            /*     0     8 */
	LEX_STRING                 expr_str;             /*     8    16 */
	class Item *               item_free_list;       /*    24     8 */
	MY_BITMAP                  base_columns_map;     /*    32    32 */
	void Generated_column(class Generated_column *);

	void ~Generated_column(class Generated_column *, int);

	enum_field_types get_real_type(const class Generated_column  *);

	void set_field_type(class Generated_column *, enum_field_types);

	bool get_field_stored(const class Generated_column  *);

	void set_field_stored(class Generated_column *, bool);

	bool register_base_columns(class Generated_column *, class TABLE *);

	uint non_virtual_base_columns(const class Generated_column  *);

	void dup_expr_str(class Generated_column *, MEM_ROOT *, const char  *, size_t);

	/* --- cacheline 1 boundary (64 bytes) --- */
	enum_field_types           field_type;           /*    64     4 */
	bool                       stored_in_db;         /*    68     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       num_non_virtual_base_cols; /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	MEM_ROOT *                 m_expr_str_mem_root;  /*    80     8 */
	bool                       permanent_changes_completed; /*    88     1 */

	/* size: 96, cachelines: 2, members: 10 */
	/* sum members: 82, holes: 2, sum holes: 7 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 32 bytes */
};
class Create_field : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	const char  *              field_name;           /*     0     8 */
	const char  *              change;               /*     8     8 */
	const char  *              after;                /*    16     8 */
	LEX_STRING                 comment;              /*    24    16 */
	class Item *               def;                  /*    40     8 */
	enum enum_field_types      sql_type;             /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     length;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	size_t                     char_length;          /*    64     8 */
	uint                       decimals;             /*    72     4 */
	uint                       flags;                /*    76     4 */
	size_t                     pack_length;          /*    80     8 */
	size_t                     key_length;           /*    88     8 */
	enum utype                 unireg_check;         /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	TYPELIB *                  interval;             /*   104     8 */
	TYPELIB *                  save_interval;        /*   112     8 */
	class List<String>        interval_list;         /*   120    24 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	const CHARSET_INFO  *      charset;              /*   144     8 */
	enum geometry_type         geom_type;            /*   152     4 */

	/* XXX 4 bytes hole, try to pack */

	class Field *              field;                /*   160     8 */
	uint8                      row;                  /*   168     1 */
	uint8                      col;                  /*   169     1 */
	uint8                      sc_length;            /*   170     1 */
	uint8                      interval_id;          /*   171     1 */
	uint                       offset;               /*   172     4 */
	uint                       pack_flag;            /*   176     4 */

	/* XXX 4 bytes hole, try to pack */

	LEX_CSTRING                zip_dict_name;        /*   184    16 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	class Generated_column *   gcol_info;            /*   200     8 */
	bool                       stored_in_db;         /*   208     1 */
	void Create_field(class Create_field *);

	void Create_field(class Create_field *, class Field *, class Field *);

	class Create_field * clone(const class Create_field  *, MEM_ROOT *);

	bool is_gcol(const class Create_field  *);

	bool is_virtual_gcol(const class Create_field  *);

	void create_length_to_internal_length(class Create_field *);

	void init_for_tmp_table(class Create_field *, enum_field_types, uint32, uint32, bool, bool, uint);

	bool init(class Create_field *, class THD *, const char  *, enum_field_types, const char  *, const char  *, uint, class Item *, class Item *, LEX_STRING *, const char  *, class List<String> *, const CHARSET_INFO  *, uint, const LEX_CSTRING  *, class Generated_column *);

	enum ha_storage_media field_storage_type(const class Create_field  *);

	enum column_format_type column_format(const class Create_field  *);

	void set_column_format(class Create_field *, enum column_format_type);


	/* size: 216, cachelines: 4, members: 29 */
	/* sum members: 193, holes: 4, sum holes: 16 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
class Send_field : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	const char  *              db_name;              /*     0     8 */
	const char  *              table_name;           /*     8     8 */
	const char  *              org_table_name;       /*    16     8 */
	const char  *              col_name;             /*    24     8 */
	const char  *              org_col_name;         /*    32     8 */
	ulong                      length;               /*    40     8 */
	uint                       charsetnr;            /*    48     4 */
	uint                       flags;                /*    52     4 */
	uint                       decimals;             /*    56     4 */
	enum_field_types           type;                 /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       field;                /*    64     1 */
	void Send_field(class Send_field *);


	/* size: 72, cachelines: 2, members: 12 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 8 bytes */
};
class Copy_field : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	typedef void (Copy_func)(class Copy_field *);

	Copy_func * get_copy_func(class Copy_field *, class Field *, class Field *);


	uchar *                    from_ptr;             /*     0     8 */
	uchar *                    to_ptr;               /*     8     8 */
	uchar *                    from_null_ptr;        /*    16     8 */
	uchar *                    to_null_ptr;          /*    24     8 */
	my_bool *                  null_row;             /*    32     8 */
	uint                       from_bit;             /*    40     4 */
	uint                       to_bit;               /*    44     4 */
	class String              tmp;                   /*    48    32 */

	/* XXX last struct has 3 bytes of padding */
	void Copy_field(class Copy_field *);

	void ~Copy_field(class Copy_field *, int);

	void set(class Copy_field *, class Field *, class Field *, bool);

	void set(class Copy_field *, uchar *, class Field *);


	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	void                       (*m_do_copy)(class Copy_field *); /*    80     8 */
	void                       (*m_do_copy2)(class Copy_field *); /*    88     8 */
	uint                       m_from_length;        /*    96     4 */
	uint                       m_to_length;          /*   100     4 */
	class Field *              m_from_field;         /*   104     8 */
	class Field *              m_to_field;           /*   112     8 */
	void check_and_set_temporary_null(class Copy_field *);

	void invoke_do_copy(class Copy_field *, class Copy_field *);

	void invoke_do_copy2(class Copy_field *, class Copy_field *);

	class Field * from_field(class Copy_field *);

	class Field * to_field(class Copy_field *);

	uint from_length(const class Copy_field  *);

	uint to_length(const class Copy_field  *);


	/* size: 120, cachelines: 2, members: 15 */
	/* paddings: 2, sum paddings: 4 */
	/* last cacheline: 56 bytes */
};
class Dependency_tracker_ctx {
public:

	void Dependency_tracker_ctx(class Dependency_tracker_ctx *);

	void set_last_session_sequence_number(class Dependency_tracker_ctx *, int64);

	int64 get_last_session_sequence_number(class Dependency_tracker_ctx *);

	int64                      m_last_session_sequence_number; /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Rpl_thd_context {
	class Session_consistency_gtids_ctx m_session_gtids_ctx; /*     0     0 */

	/* XXX 40 bytes hole, try to pack */

	class Dependency_tracker_ctx m_dependency_tracker_ctx; /*    40     8 */
	enum enum_rpl_channel_type rpl_channel_type;     /*    48     4 */
	void Rpl_thd_context(class Rpl_thd_context *, const class Rpl_thd_context  &);

	class Rpl_thd_context & operator=(class Rpl_thd_context *, const class Rpl_thd_context  &);

public:

	void Rpl_thd_context(class Rpl_thd_context *);

	class Session_consistency_gtids_ctx & session_gtids_ctx(class Rpl_thd_context *);

	class Dependency_tracker_ctx & dependency_tracker_ctx(class Rpl_thd_context *);

	enum enum_rpl_channel_type get_rpl_channel_type(class Rpl_thd_context *);

	void set_rpl_channel_type(class Rpl_thd_context *, enum enum_rpl_channel_type);

	void ~Rpl_thd_context(class Rpl_thd_context *, int);


	/* size: 56, cachelines: 1, members: 3 */
	/* sum members: 12, holes: 1, sum holes: 40 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
class Checkable_rwlock {
public:

	void Checkable_rwlock(class Checkable_rwlock *, PSI_rwlock_key);

	void ~Checkable_rwlock(class Checkable_rwlock *, int);

	void rdlock(class Checkable_rwlock *);

	void wrlock(class Checkable_rwlock *);

	void unlock(class Checkable_rwlock *);

	bool is_wrlock(class Checkable_rwlock *);

	void assert_some_lock(const class Checkable_rwlock  *);

	void assert_some_rdlock(const class Checkable_rwlock  *);

	void assert_some_wrlock(const class Checkable_rwlock  *);

	void assert_no_wrlock(const class Checkable_rwlock  *);

	void assert_no_rdlock(const class Checkable_rwlock  *);

	void assert_no_lock(const class Checkable_rwlock  *);

	bool                       is_write_lock;        /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	mysql_rwlock_t             rwlock;               /*     8    64 */

	/* size: 72, cachelines: 2, members: 2 */
	/* sum members: 65, holes: 1, sum holes: 7 */
	/* last cacheline: 8 bytes */
};
class Sid_map {
	struct Node {
		rpl_sidno                  sidno;                /*     0     4 */
		rpl_sid                    sid;                  /*     4    16 */

		/* size: 20, cachelines: 1, members: 2 */
		/* last cacheline: 20 bytes */
	};

public:

	void Sid_map(class Sid_map *, class Checkable_rwlock *);

	void ~Sid_map(class Sid_map *, int);

	rpl_sidno add_sid(class Sid_map *, const rpl_sid  &);

	rpl_sidno sid_to_sidno(const class Sid_map  *, const rpl_sid  &);

	const rpl_sid  & sidno_to_sid(const class Sid_map  *, rpl_sidno, bool);

	rpl_sidno get_sorted_sidno(const class Sid_map  *, rpl_sidno);

	rpl_sidno get_max_sidno(const class Sid_map  *);

	class Checkable_rwlock * get_sid_lock(const class Sid_map  *);

	enum enum_return_status copy(class Sid_map *, class Sid_map *);

	enum enum_return_status add_node(class Sid_map *, rpl_sidno, const rpl_sid  &);

	class Checkable_rwlock *   sid_lock;             /*     0     8 */
	class Prealloced_array<Sid_map::Node*, 8, true> _sidno_to_sid __attribute__((__aligned__(8))); /*     8    96 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	HASH                       _sid_to_sidno;        /*   104   112 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	class Prealloced_array<int, 8, true> _sorted __attribute__((__aligned__(8))); /*   216    64 */

	/* XXX last struct has 4 bytes of padding */

	/* size: 280, cachelines: 5, members: 4 */
	/* paddings: 2, sum paddings: 8 */
	/* forced alignments: 2 */
	/* last cacheline: 24 bytes */
} __attribute__((__aligned__(8)));
struct my_aligned_storage<64, 8> {
	union {
		char                       data[64];             /*     0    64 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[64];             /*     0    64 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0    64 */

	/* size: 64, cachelines: 1, members: 1 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class Prealloced_array<Sid_map::Node*, 8, true> {
	class Node * * cast_rawbuff(class Prealloced_array<Sid_map::Node*, 8, true> *);

public:

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8, true> *, const class Prealloced_array<Sid_map::Node*, 8, true>  &);

	void Prealloced_array(class Prealloced_array<Sid_map::Node*, 8, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Node * const * const_iterator;

	class Prealloced_array<Sid_map::Node*, 8, true> & operator=(class Prealloced_array<Sid_map::Node*, 8, true> *, const class Prealloced_array<Sid_map::Node*, 8, true>  &);

	void ~Prealloced_array(class Prealloced_array<Sid_map::Node*, 8, true> *, int);

	size_t capacity(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	size_t element_size(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	bool empty(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	size_t size(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	class Node * & at(class Prealloced_array<Sid_map::Node*, 8, true> *, size_t);

	class Node * const & at(const class Prealloced_array<Sid_map::Node*, 8, true>  *, size_t);

	class Node * & operator[](class Prealloced_array<Sid_map::Node*, 8, true> *, size_t);

	class Node * const & operator[](const class Prealloced_array<Sid_map::Node*, 8, true>  *, size_t);

	class Node * & back(class Prealloced_array<Sid_map::Node*, 8, true> *);

	class Node * const & back(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	class Node * & front(class Prealloced_array<Sid_map::Node*, 8, true> *);

	class Node * const & front(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	typedef class Node * * iterator;

	iterator begin(class Prealloced_array<Sid_map::Node*, 8, true> *);

	iterator end(class Prealloced_array<Sid_map::Node*, 8, true> *);

	const_iterator begin(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	const_iterator end(const class Prealloced_array<Sid_map::Node*, 8, true>  *);

	bool reserve(class Prealloced_array<Sid_map::Node*, 8, true> *, size_t);

	bool push_back(class Prealloced_array<Sid_map::Node*, 8, true> *, class Node * const &);

	void pop_back(class Prealloced_array<Sid_map::Node*, 8, true> *);

	iterator insert(class Prealloced_array<Sid_map::Node*, 8, true> *, iterator, const value_type  &);

	typedef class Node * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<Sid_map::Node**, bool> insert_unique(class Prealloced_array<Sid_map::Node*, 8, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Sid_map::Node*, 8, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Sid_map::Node*, 8, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<Sid_map::Node*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<Sid_map::Node*, 8, true> *, size_t);

	void erase_at_end(class Prealloced_array<Sid_map::Node*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<Sid_map::Node*, 8, true> *, iterator, iterator);

	void swap(class Prealloced_array<Sid_map::Node*, 8, true> *, class Prealloced_array<Sid_map::Node*, 8, true> &);

	void shrink_to_fit(class Prealloced_array<Sid_map::Node*, 8, true> *);

	void resize(class Prealloced_array<Sid_map::Node*, 8, true> *, size_t, class Node * const &);

	void clear(class Prealloced_array<Sid_map::Node*, 8, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<64, 8> m_buff __attribute__((__aligned__(8))); /*    16    64 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class Node * *             m_array_ptr;          /*    80     8 */
	PSI_memory_key             m_psi_key;            /*    88     4 */

	/* size: 96, cachelines: 2, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
struct my_aligned_storage<32, 8> {
	union {
		char                       data[32];             /*     0    32 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[32];             /*     0    32 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0    32 */

	/* size: 32, cachelines: 1, members: 1 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<int, 8, true> {
	int * cast_rawbuff(class Prealloced_array<int, 8, true> *);

public:

	void Prealloced_array(class Prealloced_array<int, 8, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<int, 8, true> *, const class Prealloced_array<int, 8, true>  &);

	void Prealloced_array(class Prealloced_array<int, 8, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const int  * const_iterator;

	class Prealloced_array<int, 8, true> & operator=(class Prealloced_array<int, 8, true> *, const class Prealloced_array<int, 8, true>  &);

	void ~Prealloced_array(class Prealloced_array<int, 8, true> *, int);

	size_t capacity(const class Prealloced_array<int, 8, true>  *);

	size_t element_size(const class Prealloced_array<int, 8, true>  *);

	bool empty(const class Prealloced_array<int, 8, true>  *);

	size_t size(const class Prealloced_array<int, 8, true>  *);

	int & at(class Prealloced_array<int, 8, true> *, size_t);

	const int  & at(const class Prealloced_array<int, 8, true>  *, size_t);

	int & operator[](class Prealloced_array<int, 8, true> *, size_t);

	const int  & operator[](const class Prealloced_array<int, 8, true>  *, size_t);

	int & back(class Prealloced_array<int, 8, true> *);

	const int  & back(const class Prealloced_array<int, 8, true>  *);

	int & front(class Prealloced_array<int, 8, true> *);

	const int  & front(const class Prealloced_array<int, 8, true>  *);

	typedef int * iterator;

	iterator begin(class Prealloced_array<int, 8, true> *);

	iterator end(class Prealloced_array<int, 8, true> *);

	const_iterator begin(const class Prealloced_array<int, 8, true>  *);

	const_iterator end(const class Prealloced_array<int, 8, true>  *);

	bool reserve(class Prealloced_array<int, 8, true> *, size_t);

	bool push_back(class Prealloced_array<int, 8, true> *, const int  &);

	void pop_back(class Prealloced_array<int, 8, true> *);

	iterator insert(class Prealloced_array<int, 8, true> *, iterator, const value_type  &);

	typedef int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<int*, bool> insert_unique(class Prealloced_array<int, 8, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<int, 8, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<int, 8, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<int, 8, true> *, iterator);

	iterator erase(class Prealloced_array<int, 8, true> *, size_t);

	void erase_at_end(class Prealloced_array<int, 8, true> *, iterator);

	iterator erase(class Prealloced_array<int, 8, true> *, iterator, iterator);

	void swap(class Prealloced_array<int, 8, true> *, class Prealloced_array<int, 8, true> &);

	void shrink_to_fit(class Prealloced_array<int, 8, true> *);

	void resize(class Prealloced_array<int, 8, true> *, size_t, const int  &);

	void clear(class Prealloced_array<int, 8, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<32, 8> m_buff __attribute__((__aligned__(8))); /*    16    32 */
	int *                      m_array_ptr;          /*    48     8 */
	PSI_memory_key             m_psi_key;            /*    56     4 */

	/* size: 64, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class Mutex_cond_array {
	struct Mutex_cond {
		mysql_mutex_t              mutex;                /*     0    48 */
		mysql_cond_t               cond;                 /*    48    56 */

		/* size: 104, cachelines: 2, members: 2 */
		/* last cacheline: 40 bytes */
	};

public:

	void Mutex_cond_array(class Mutex_cond_array *, class Checkable_rwlock *);

	void ~Mutex_cond_array(class Mutex_cond_array *, int);

	void lock(const class Mutex_cond_array  *, int);

	void unlock(const class Mutex_cond_array  *, int);

	void broadcast(const class Mutex_cond_array  *, int);

	void assert_owner(const class Mutex_cond_array  *, int);

	void assert_not_owner(const class Mutex_cond_array  *, int);

	bool wait(const class Mutex_cond_array  *, const class THD  *, int, class timespec *);

	void enter_cond(const class Mutex_cond_array  *, class THD *, int, PSI_stage_info *, PSI_stage_info *);

	int get_max_index(const class Mutex_cond_array  *);

	enum enum_return_status ensure_index(class Mutex_cond_array *, int);

	bool is_thd_killed(const class Mutex_cond_array  *, const class THD  *);

	class Mutex_cond * get_mutex_cond(const class Mutex_cond_array  *, int);

	class Checkable_rwlock *   global_lock;          /*     0     8 */
	class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> m_array __attribute__((__aligned__(8))); /*     8    96 */

	/* XXX last struct has 4 bytes of padding */

	/* size: 104, cachelines: 2, members: 2 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 40 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> {
	class Mutex_cond * * cast_rawbuff(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

public:

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  &);

	void Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Mutex_cond * const * const_iterator;

	class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> & operator=(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  &);

	void ~Prealloced_array(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, int);

	size_t capacity(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	size_t element_size(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	bool empty(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	size_t size(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	class Mutex_cond * & at(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, size_t);

	class Mutex_cond * const & at(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *, size_t);

	class Mutex_cond * & operator[](class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, size_t);

	class Mutex_cond * const & operator[](const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *, size_t);

	class Mutex_cond * & back(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

	class Mutex_cond * const & back(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	class Mutex_cond * & front(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

	class Mutex_cond * const & front(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	typedef class Mutex_cond * * iterator;

	iterator begin(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

	iterator end(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

	const_iterator begin(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	const_iterator end(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *);

	bool reserve(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, size_t);

	bool push_back(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, class Mutex_cond * const &);

	void pop_back(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

	iterator insert(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, iterator, const value_type  &);

	typedef class Mutex_cond * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<Mutex_cond_array::Mutex_cond**, bool> insert_unique(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, size_t);

	void erase_at_end(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, iterator, iterator);

	void swap(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> &);

	void shrink_to_fit(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

	void resize(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *, size_t, class Mutex_cond * const &);

	void clear(class Prealloced_array<Mutex_cond_array::Mutex_cond*, 8, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<64, 8> m_buff __attribute__((__aligned__(8))); /*    16    64 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class Mutex_cond * *       m_array_ptr;          /*    80     8 */
	PSI_memory_key             m_psi_key;            /*    88     4 */

	/* size: 96, cachelines: 2, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
struct Gtid {
	rpl_sidno                  sidno;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	rpl_gno                    gno;                  /*     8     8 */
	void clear(class Gtid *);

	void set(class Gtid *, rpl_sidno, rpl_gno);

	bool is_empty(const class Gtid  *);


	/* Bitfield combined with previous fields */

	static const int                  MAX_TEXT_LENGTH = 56; /*     0     0 */
	bool is_valid(const char  *);

	int to_string(const class Gtid  *, const rpl_sid  &, char *);

	int to_string(const class Gtid  *, const class Sid_map  *, char *, bool);

	bool equals(const class Gtid  *, const class Gtid  &);

	enum enum_return_status parse(class Gtid *, class Sid_map *, const char  *);

	void dbug_print(const class Gtid  *, const class Sid_map  *, const char  *, bool);


	/* size: 16, cachelines: 1, members: 2, static members: 1 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
class Gtid_set {
	struct String_format {
		const char  *              begin;                /*     0     8 */
		const char  *              end;                  /*     8     8 */
		const char  *              sid_gno_separator;    /*    16     8 */
		const char  *              gno_start_end_separator; /*    24     8 */
		const char  *              gno_gno_separator;    /*    32     8 */
		const char  *              gno_sid_separator;    /*    40     8 */
		const char  *              empty_set_string;     /*    48     8 */
		const int                  begin_length;         /*    56     4 */
		const int                  end_length;           /*    60     4 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		const int                  sid_gno_separator_length; /*    64     4 */
		const int                  gno_start_end_separator_length; /*    68     4 */
		const int                  gno_gno_separator_length; /*    72     4 */
		const int                  gno_sid_separator_length; /*    76     4 */
		const int                  empty_set_string_length; /*    80     4 */

		/* size: 88, cachelines: 2, members: 14 */
		/* padding: 4 */
		/* last cacheline: 24 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	struct Interval {
		rpl_gno                    start;                /*     0     8 */
		rpl_gno                    end;                  /*     8     8 */
		bool equals(const class Interval  *, const class Interval  &);

		class Interval *           next;                 /*    16     8 */

		/* size: 24, cachelines: 1, members: 3 */
		/* last cacheline: 24 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> {
	public:

		void Interval_iterator_base(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *, const class Gtid_set  *, rpl_sidno);

		void Interval_iterator_base(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *, const class Gtid_set  *);

		void init(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *, const class Gtid_set  *, rpl_sidno);

		void next(class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> *);

		const class Interval  * get(const class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*>  *);

	protected:

		const class Interval  * *  p;                    /*     0     8 */

		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Const_interval_iterator : public Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> {
	public:

		/* class Interval_iterator_base<const Gtid_set*, const Gtid_set::Interval*> <ancestor>; */ /*     0     8 */
		void Const_interval_iterator(class Const_interval_iterator *, const class Gtid_set  *, rpl_sidno);

		void Const_interval_iterator(class Const_interval_iterator *, const class Gtid_set  *);


		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */

		/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
	};

	class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> {
	public:

		void Interval_iterator_base(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *, class Gtid_set *, rpl_sidno);

		void Interval_iterator_base(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *, class Gtid_set *);

		void init(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *, class Gtid_set *, rpl_sidno);

		void next(class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> *);

		class Interval * get(const class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*>  *);

	protected:

		class Interval * *         p;                    /*     0     8 */

		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	class Interval_iterator : public Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> {
	public:

		/* class Interval_iterator_base<Gtid_set*, Gtid_set::Interval*> <ancestor>; */ /*     0     8 */
		void Interval_iterator(class Interval_iterator *, class Gtid_set *, rpl_sidno);

		void Interval_iterator(class Interval_iterator *, class Gtid_set *);

		void set(class Interval_iterator *, class Interval *);

		void insert(class Interval_iterator *, class Interval *);

		void remove(class Interval_iterator *, class Gtid_set *);


		/* size: 8, cachelines: 1, members: 1 */
		/* last cacheline: 8 bytes */

		/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
	};

	struct Interval_chunk {
		class Interval_chunk *     next;                 /*     0     8 */
		struct Interval            intervals[1];         /*     8    24 */

		/* size: 32, cachelines: 1, members: 2 */
		/* last cacheline: 32 bytes */
	};

	class Free_intervals_lock {
	public:

		void Free_intervals_lock(class Free_intervals_lock *, class Gtid_set *);

		void lock_if_not_locked(class Free_intervals_lock *);

		void unlock_if_locked(class Free_intervals_lock *);

		void ~Free_intervals_lock(class Free_intervals_lock *, int);

		class Gtid_set *           gtid_set;             /*     0     8 */
		bool                       locked;               /*     8     1 */

		/* size: 16, cachelines: 1, members: 2 */
		/* padding: 7 */
		/* last cacheline: 16 bytes */
	};

public:

	static PSI_mutex_key              key_gtid_executed_free_intervals_mutex; /*     0     0 */
	void Gtid_set(class Gtid_set *, class Sid_map *, class Checkable_rwlock *);

	void Gtid_set(class Gtid_set *, class Sid_map *, const char  *, enum enum_return_status *, class Checkable_rwlock *);

	void init(class Gtid_set *);

	void ~Gtid_set(class Gtid_set *, int);

	void clear(class Gtid_set *);

	void _add_gtid(class Gtid_set *, rpl_sidno, rpl_gno);

	void _remove_gtid(class Gtid_set *, rpl_sidno, rpl_gno);

	void _add_gtid(class Gtid_set *, const class Gtid  &);

	void _remove_gtid(class Gtid_set *, const class Gtid  &);

	enum enum_return_status add_gtid_set(class Gtid_set *, const class Gtid_set  *);

	void remove_gtid_set(class Gtid_set *, const class Gtid_set  *);

	void remove_intervals_for_sidno(class Gtid_set *, class Gtid_set *, rpl_sidno);

	enum enum_return_status add_gtid_text(class Gtid_set *, const char  *, bool *);

	enum enum_return_status add_gtid_encoding(class Gtid_set *, const uchar  *, size_t, size_t *);

	bool contains_gtid(const class Gtid_set  *, rpl_sidno, rpl_gno);

	bool contains_gtid(const class Gtid_set  *, const class Gtid  &);

	rpl_gno get_last_gno(const class Gtid_set  *, rpl_sidno);

	rpl_sidno get_max_sidno(const class Gtid_set  *);

	enum enum_return_status ensure_sidno(class Gtid_set *, rpl_sidno);

	bool is_subset(const class Gtid_set  *, const class Gtid_set  *);

	bool is_subset_not_equals(const class Gtid_set  *, const class Gtid_set  *);

	bool is_subset_for_sid(const class Gtid_set  *, const class Gtid_set  *, rpl_sidno, rpl_sidno);

	bool is_intersection_nonempty(const class Gtid_set  *, const class Gtid_set  *);

	enum enum_return_status intersection(class Gtid_set *, const class Gtid_set  *, class Gtid_set *);

	bool is_empty(const class Gtid_set  *);

	bool contains_sidno(const class Gtid_set  *, rpl_sidno);

	bool is_valid(const char  *);

	size_t get_string_length(const class Gtid_set  *, const class String_format  *);

	size_t to_string(const class Gtid_set  *, char *, bool, const class String_format  *);

	long int to_string(const class Gtid_set  *, char * *, bool, const class String_format  *);

	void dbug_print(const class Gtid_set  *, const char  *, bool, const class String_format  *);

	void get_gtid_intervals(const class Gtid_set  *, class list<Gtid_interval, std::allocator<Gtid_interval> > *);

	static const struct String_format default_string_format; /*     0     0 */
	static const struct String_format sql_string_format; /*     0     0 */
	static const struct String_format commented_string_format; /*     0     0 */
	class Sid_map * get_sid_map(const class Gtid_set  *);

	void add_interval_memory(class Gtid_set *, int, class Interval *);

	void encode(const class Gtid_set  *, uchar *);

	size_t get_encoded_length(const class Gtid_set  *);

	static const int                  CHUNK_GROW_SIZE = 8; /*     0     0 */
	bool sidno_equals(const class Gtid_set  *, rpl_sidno, const class Gtid_set  *, rpl_sidno);

	bool equals(const class Gtid_set  *, const class Gtid_set  *);

	int get_n_intervals(const class Gtid_set  *, rpl_sidno);

	int get_n_intervals(const class Gtid_set  *);

	void create_new_chunk(class Gtid_set *, int);

	void get_free_interval(class Gtid_set *, class Interval * *);

	void put_free_interval(class Gtid_set *, class Interval *);

	void add_interval_memory_lock_taken(class Gtid_set *, int, class Interval *);

	class Checkable_rwlock *   sid_lock;             /*     0     8 */
	mysql_mutex_t              free_intervals_mutex; /*     8    48 */
	void assert_free_intervals_locked(class Gtid_set *);

	void add_gno_interval(class Gtid_set *, class Interval_iterator *, rpl_gno, rpl_gno, class Free_intervals_lock *);

	void remove_gno_interval(class Gtid_set *, class Interval_iterator *, rpl_gno, rpl_gno, class Free_intervals_lock *);

	void add_gno_intervals(class Gtid_set *, rpl_sidno, class Const_interval_iterator, class Free_intervals_lock *);

	void remove_gno_intervals(class Gtid_set *, rpl_sidno, class Const_interval_iterator, class Free_intervals_lock *);

	bool is_interval_subset(class Const_interval_iterator *, class Const_interval_iterator *);

	bool is_interval_intersection_nonempty(class Const_interval_iterator *, class Const_interval_iterator *);

	class Sid_map *            sid_map;              /*    56     8 */
	class Prealloced_array<Gtid_set::Interval*, 8, true> m_intervals __attribute__((__aligned__(8))); /*    64    96 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	class Interval *           free_intervals;       /*   160     8 */
	class Interval_chunk *     chunks;               /*   168     8 */
	bool                       has_cached_string_length; /*   176     1 */

	/* XXX 7 bytes hole, try to pack */

	size_t                     cached_string_length; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	const class String_format  * cached_string_format; /*   192     8 */

	/* size: 200, cachelines: 4, members: 9, static members: 5 */
	/* sum members: 193, holes: 1, sum holes: 7 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 8 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<Gtid_set::Interval*, 8, true> {
	class Interval * * cast_rawbuff(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

public:

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8, true> *, const class Prealloced_array<Gtid_set::Interval*, 8, true>  &);

	void Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Interval * const * const_iterator;

	class Prealloced_array<Gtid_set::Interval*, 8, true> & operator=(class Prealloced_array<Gtid_set::Interval*, 8, true> *, const class Prealloced_array<Gtid_set::Interval*, 8, true>  &);

	void ~Prealloced_array(class Prealloced_array<Gtid_set::Interval*, 8, true> *, int);

	size_t capacity(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	size_t element_size(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	bool empty(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	size_t size(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	class Interval * & at(class Prealloced_array<Gtid_set::Interval*, 8, true> *, size_t);

	class Interval * const & at(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *, size_t);

	class Interval * & operator[](class Prealloced_array<Gtid_set::Interval*, 8, true> *, size_t);

	class Interval * const & operator[](const class Prealloced_array<Gtid_set::Interval*, 8, true>  *, size_t);

	class Interval * & back(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

	class Interval * const & back(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	class Interval * & front(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

	class Interval * const & front(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	typedef class Interval * * iterator;

	iterator begin(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

	iterator end(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

	const_iterator begin(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	const_iterator end(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *);

	bool reserve(class Prealloced_array<Gtid_set::Interval*, 8, true> *, size_t);

	bool push_back(class Prealloced_array<Gtid_set::Interval*, 8, true> *, class Interval * const &);

	void pop_back(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

	iterator insert(class Prealloced_array<Gtid_set::Interval*, 8, true> *, iterator, const value_type  &);

	typedef class Interval * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<Gtid_set::Interval**, bool> insert_unique(class Prealloced_array<Gtid_set::Interval*, 8, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Gtid_set::Interval*, 8, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Gtid_set::Interval*, 8, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<Gtid_set::Interval*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<Gtid_set::Interval*, 8, true> *, size_t);

	void erase_at_end(class Prealloced_array<Gtid_set::Interval*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<Gtid_set::Interval*, 8, true> *, iterator, iterator);

	void swap(class Prealloced_array<Gtid_set::Interval*, 8, true> *, class Prealloced_array<Gtid_set::Interval*, 8, true> &);

	void shrink_to_fit(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

	void resize(class Prealloced_array<Gtid_set::Interval*, 8, true> *, size_t, class Interval * const &);

	void clear(class Prealloced_array<Gtid_set::Interval*, 8, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<64, 8> m_buff __attribute__((__aligned__(8))); /*    16    64 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class Interval * *         m_array_ptr;          /*    80     8 */
	PSI_memory_key             m_psi_key;            /*    88     4 */

	/* size: 96, cachelines: 2, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
struct Gtid_set_or_null {
	class Gtid_set *           gtid_set;             /*     0     8 */
	bool                       is_non_null;          /*     8     1 */
	class Gtid_set * get_gtid_set(const class Gtid_set_or_null  *);

	class Gtid_set * set_non_null(class Gtid_set_or_null *, class Sid_map *);

	void set_null(class Gtid_set_or_null *);


	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
class Owned_gtids {
public:

	void Owned_gtids(class Owned_gtids *, class Checkable_rwlock *);

	void ~Owned_gtids(class Owned_gtids *, int);

	enum enum_return_status add_gtid_owner(class Owned_gtids *, const class Gtid  &, my_thread_id);

	void get_gtids(const class Owned_gtids  *, class Gtid_set &);

	void remove_gtid(class Owned_gtids *, const class Gtid  &, my_thread_id);

	enum enum_return_status ensure_sidno(class Owned_gtids *, rpl_sidno);

	bool is_intersection_nonempty(const class Owned_gtids  *, const class Gtid_set  *);

	bool is_empty(const class Owned_gtids  *);

	rpl_sidno get_max_sidno(const class Owned_gtids  *);

	int to_string(const class Owned_gtids  *, char *);

	size_t get_max_string_length(const class Owned_gtids  *);

	bool thread_owns_anything(const class Owned_gtids  *, my_thread_id);

	void dbug_print(const class Owned_gtids  *, const char  *);

	bool is_owned_by(const class Owned_gtids  *, const class Gtid  &, my_thread_id);

	class Checkable_rwlock *   sid_lock;             /*     0     8 */
	HASH * get_hash(const class Owned_gtids  *, rpl_sidno);

	bool contains_gtid(const class Owned_gtids  *, const class Gtid  &);

	class Prealloced_array<st_hash*, 8, true> sidno_to_hash __attribute__((__aligned__(8))); /*     8    96 */

	/* XXX last struct has 4 bytes of padding */

	/* size: 104, cachelines: 2, members: 2 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 40 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<st_hash*, 8, true> {
	class st_hash * * cast_rawbuff(class Prealloced_array<st_hash*, 8, true> *);

public:

	void Prealloced_array(class Prealloced_array<st_hash*, 8, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<st_hash*, 8, true> *, const class Prealloced_array<st_hash*, 8, true>  &);

	void Prealloced_array(class Prealloced_array<st_hash*, 8, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class st_hash * const * const_iterator;

	class Prealloced_array<st_hash*, 8, true> & operator=(class Prealloced_array<st_hash*, 8, true> *, const class Prealloced_array<st_hash*, 8, true>  &);

	void ~Prealloced_array(class Prealloced_array<st_hash*, 8, true> *, int);

	size_t capacity(const class Prealloced_array<st_hash*, 8, true>  *);

	size_t element_size(const class Prealloced_array<st_hash*, 8, true>  *);

	bool empty(const class Prealloced_array<st_hash*, 8, true>  *);

	size_t size(const class Prealloced_array<st_hash*, 8, true>  *);

	class st_hash * & at(class Prealloced_array<st_hash*, 8, true> *, size_t);

	class st_hash * const & at(const class Prealloced_array<st_hash*, 8, true>  *, size_t);

	class st_hash * & operator[](class Prealloced_array<st_hash*, 8, true> *, size_t);

	class st_hash * const & operator[](const class Prealloced_array<st_hash*, 8, true>  *, size_t);

	class st_hash * & back(class Prealloced_array<st_hash*, 8, true> *);

	class st_hash * const & back(const class Prealloced_array<st_hash*, 8, true>  *);

	class st_hash * & front(class Prealloced_array<st_hash*, 8, true> *);

	class st_hash * const & front(const class Prealloced_array<st_hash*, 8, true>  *);

	typedef class st_hash * * iterator;

	iterator begin(class Prealloced_array<st_hash*, 8, true> *);

	iterator end(class Prealloced_array<st_hash*, 8, true> *);

	const_iterator begin(const class Prealloced_array<st_hash*, 8, true>  *);

	const_iterator end(const class Prealloced_array<st_hash*, 8, true>  *);

	bool reserve(class Prealloced_array<st_hash*, 8, true> *, size_t);

	bool push_back(class Prealloced_array<st_hash*, 8, true> *, class st_hash * const &);

	void pop_back(class Prealloced_array<st_hash*, 8, true> *);

	iterator insert(class Prealloced_array<st_hash*, 8, true> *, iterator, const value_type  &);

	typedef class st_hash * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<st_hash**, bool> insert_unique(class Prealloced_array<st_hash*, 8, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<st_hash*, 8, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<st_hash*, 8, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<st_hash*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<st_hash*, 8, true> *, size_t);

	void erase_at_end(class Prealloced_array<st_hash*, 8, true> *, iterator);

	iterator erase(class Prealloced_array<st_hash*, 8, true> *, iterator, iterator);

	void swap(class Prealloced_array<st_hash*, 8, true> *, class Prealloced_array<st_hash*, 8, true> &);

	void shrink_to_fit(class Prealloced_array<st_hash*, 8, true> *);

	void resize(class Prealloced_array<st_hash*, 8, true> *, size_t, class st_hash * const &);

	void clear(class Prealloced_array<st_hash*, 8, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<64, 8> m_buff __attribute__((__aligned__(8))); /*    16    64 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	class st_hash * *          m_array_ptr;          /*    80     8 */
	PSI_memory_key             m_psi_key;            /*    88     4 */

	/* size: 96, cachelines: 2, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
struct my_aligned_storage<8, 8> {
	union {
		char                       data[8];              /*     0     8 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[8];              /*     0     8 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* forced alignments: 1 */
	/* last cacheline: 8 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<bool, 8, true> {
	bool * cast_rawbuff(class Prealloced_array<bool, 8, true> *);

public:

	void Prealloced_array(class Prealloced_array<bool, 8, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<bool, 8, true> *, const class Prealloced_array<bool, 8, true>  &);

	void Prealloced_array(class Prealloced_array<bool, 8, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const bool  * const_iterator;

	class Prealloced_array<bool, 8, true> & operator=(class Prealloced_array<bool, 8, true> *, const class Prealloced_array<bool, 8, true>  &);

	void ~Prealloced_array(class Prealloced_array<bool, 8, true> *, int);

	size_t capacity(const class Prealloced_array<bool, 8, true>  *);

	size_t element_size(const class Prealloced_array<bool, 8, true>  *);

	bool empty(const class Prealloced_array<bool, 8, true>  *);

	size_t size(const class Prealloced_array<bool, 8, true>  *);

	bool & at(class Prealloced_array<bool, 8, true> *, size_t);

	const bool  & at(const class Prealloced_array<bool, 8, true>  *, size_t);

	bool & operator[](class Prealloced_array<bool, 8, true> *, size_t);

	const bool  & operator[](const class Prealloced_array<bool, 8, true>  *, size_t);

	bool & back(class Prealloced_array<bool, 8, true> *);

	const bool  & back(const class Prealloced_array<bool, 8, true>  *);

	bool & front(class Prealloced_array<bool, 8, true> *);

	const bool  & front(const class Prealloced_array<bool, 8, true>  *);

	typedef bool * iterator;

	iterator begin(class Prealloced_array<bool, 8, true> *);

	iterator end(class Prealloced_array<bool, 8, true> *);

	const_iterator begin(const class Prealloced_array<bool, 8, true>  *);

	const_iterator end(const class Prealloced_array<bool, 8, true>  *);

	bool reserve(class Prealloced_array<bool, 8, true> *, size_t);

	bool push_back(class Prealloced_array<bool, 8, true> *, const bool  &);

	void pop_back(class Prealloced_array<bool, 8, true> *);

	iterator insert(class Prealloced_array<bool, 8, true> *, iterator, const value_type  &);

	typedef bool value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<bool*, bool> insert_unique(class Prealloced_array<bool, 8, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<bool, 8, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<bool, 8, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<bool, 8, true> *, iterator);

	iterator erase(class Prealloced_array<bool, 8, true> *, size_t);

	void erase_at_end(class Prealloced_array<bool, 8, true> *, iterator);

	iterator erase(class Prealloced_array<bool, 8, true> *, iterator, iterator);

	void swap(class Prealloced_array<bool, 8, true> *, class Prealloced_array<bool, 8, true> &);

	void shrink_to_fit(class Prealloced_array<bool, 8, true> *);

	void resize(class Prealloced_array<bool, 8, true> *, size_t, const bool  &);

	void clear(class Prealloced_array<bool, 8, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<8, 8> m_buff __attribute__((__aligned__(8))); /*    16     8 */
	bool *                     m_array_ptr;          /*    24     8 */
	PSI_memory_key             m_psi_key;            /*    32     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 40 bytes */
} __attribute__((__aligned__(8)));
class Gtid_state {
public:

	void Gtid_state(class Gtid_state *, class Checkable_rwlock *, class Sid_map *);

	int init(class Gtid_state *);

	int clear(class Gtid_state *, class THD *);

	bool is_executed(const class Gtid_state  *, const class Gtid  &);

	bool is_owned(const class Gtid_state  *, const class Gtid  &);

	enum enum_return_status acquire_ownership(class Gtid_state *, class THD *, const class Gtid  &);

	void update_commit_group(class Gtid_state *, class THD *);

	void update_on_commit(class Gtid_state *, class THD *);

	void update_on_rollback(class Gtid_state *, class THD *);

	void acquire_anonymous_ownership(class Gtid_state *);

	void release_anonymous_ownership(class Gtid_state *);

	int32 get_anonymous_ownership_count(class Gtid_state *);

	void begin_automatic_gtid_violating_transaction(class Gtid_state *);

	void end_automatic_gtid_violating_transaction(class Gtid_state *);

	int32 get_automatic_gtid_violating_transaction_count(class Gtid_state *);

	void begin_anonymous_gtid_violating_transaction(class Gtid_state *);

	void end_anonymous_gtid_violating_transaction(class Gtid_state *);

	void end_gtid_violating_transaction(class Gtid_state *, class THD *);

	int32 get_anonymous_gtid_violating_transaction_count(class Gtid_state *);

	void begin_gtid_wait(class Gtid_state *, enum enum_gtid_mode_lock);

	void end_gtid_wait(class Gtid_state *);

	int32 get_gtid_wait_count(class Gtid_state *);

	rpl_gno get_automatic_gno(const class Gtid_state  *, rpl_sidno);

	rpl_gno                    next_free_gno;        /*     0     8 */
	rpl_gno get_last_executed_gno(const class Gtid_state  *, rpl_sidno);

	enum enum_return_status generate_automatic_gtid(class Gtid_state *, class THD *, rpl_sidno, rpl_gno, rpl_sidno *);

	void lock_sidno(class Gtid_state *, rpl_sidno);

	void unlock_sidno(class Gtid_state *, rpl_sidno);

	void broadcast_sidno(class Gtid_state *, rpl_sidno);

	void assert_sidno_lock_owner(class Gtid_state *, rpl_sidno);

	bool wait_for_sidno(class Gtid_state *, class THD *, rpl_sidno, class timespec *);

	bool wait_for_gtid(class Gtid_state *, class THD *, const class Gtid  &, class timespec *);

	bool wait_for_gtid_set(class Gtid_state *, class THD *, class Gtid_set *, double);

	void lock_sidnos(class Gtid_state *, const class Gtid_set  *);

	void unlock_sidnos(class Gtid_state *, const class Gtid_set  *);

	void broadcast_sidnos(class Gtid_state *, const class Gtid_set  *);

	enum enum_return_status ensure_sidno(class Gtid_state *);

	enum enum_return_status add_lost_gtids(class Gtid_state *, const class Gtid_set  *);

	const class Gtid_set  * get_lost_gtids(const class Gtid_state  *);

	const class Gtid_set  * get_executed_gtids(const class Gtid_state  *);

	const class Gtid_set  * get_gtids_only_in_table(const class Gtid_state  *);

	const class Gtid_set  * get_previous_gtids_logged(const class Gtid_state  *);

	const class Owned_gtids  * get_owned_gtids(const class Gtid_state  *);

	rpl_sidno get_server_sidno(const class Gtid_state  *);

	const rpl_sid  & get_server_sid(const class Gtid_state  *);

	void dbug_print(const class Gtid_state  *, const char  *);

	int save(class Gtid_state *, class THD *);

	int save(class Gtid_state *, const class Gtid_set  *);

	int save_gtids_of_last_binlog_into_table(class Gtid_state *, bool);

	int read_gtid_executed_from_table(class Gtid_state *);

	int compress(class Gtid_state *, class THD *);

	int warn_or_err_on_modify_gtid_table(class Gtid_state *, class THD *, class TABLE_LIST *);

	void get_snapshot_gtid_executed(class Gtid_state *, string &);

	void update_gtids_impl(class Gtid_state *, class THD *, bool);

	void unlock_owned_sidnos(class Gtid_state *, const class THD  *);

	void broadcast_owned_sidnos(class Gtid_state *, const class THD  *);

	class Checkable_rwlock *   sid_lock;             /*     8     8 */
	class Sid_map *            sid_map;              /*    16     8 */
	class Mutex_cond_array    sid_locks __attribute__((__aligned__(8))); /*    24   104 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	class Gtid_set            lost_gtids __attribute__((__aligned__(8))); /*   128   200 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	class Gtid_set            executed_gtids __attribute__((__aligned__(8))); /*   328   200 */
	/* --- cacheline 8 boundary (512 bytes) was 16 bytes ago --- */
	class Gtid_set            gtids_only_in_table __attribute__((__aligned__(8))); /*   528   200 */
	/* --- cacheline 11 boundary (704 bytes) was 24 bytes ago --- */
	class Gtid_set            previous_gtids_logged __attribute__((__aligned__(8))); /*   728   200 */
	/* --- cacheline 14 boundary (896 bytes) was 32 bytes ago --- */
	class Owned_gtids         owned_gtids __attribute__((__aligned__(8))); /*   928   104 */
	/* --- cacheline 16 boundary (1024 bytes) was 8 bytes ago --- */
	rpl_sidno                  server_sidno;         /*  1032     4 */
	class Atomic_int32        anonymous_gtid_count;  /*  1036     4 */
	class Atomic_int32        automatic_gtid_violation_count; /*  1040     4 */
	class Atomic_int32        anonymous_gtid_violation_count; /*  1044     4 */
	class Atomic_int32        gtid_wait_count;       /*  1048     4 */

	/* XXX 4 bytes hole, try to pack */
	bool update_gtids_impl_check_skip_gtid_rollback(class Gtid_state *, class THD *);

	bool update_gtids_impl_do_nothing(class Gtid_state *, class THD *);

	bool update_gtids_impl_begin(class Gtid_state *, class THD *);

	void update_gtids_impl_own_gtid_set(class Gtid_state *, class THD *, bool);

	void update_gtids_impl_lock_sidno(class Gtid_state *, rpl_sidno);

	void update_gtids_impl_lock_sidnos(class Gtid_state *, class THD *);

	void update_gtids_impl_own_gtid(class Gtid_state *, class THD *, bool);

	void update_gtids_impl_broadcast_and_unlock_sidno(class Gtid_state *, rpl_sidno);

	void update_gtids_impl_broadcast_and_unlock_sidnos(class Gtid_state *);

	void update_gtids_impl_own_anonymous(class Gtid_state *, class THD *, bool *);

	void update_gtids_impl_own_nothing(class Gtid_state *, class THD *);

	void update_gtids_impl_end(class Gtid_state *, class THD *, bool);


	class Prealloced_array<bool, 8, true> commit_group_sidnos __attribute__((__aligned__(8))); /*  1056    40 */

	/* XXX last struct has 4 bytes of padding */
	enum enum_return_status ensure_commit_group_sidnos(class Gtid_state *, rpl_sidno);


	/* size: 1096, cachelines: 18, members: 15 */
	/* sum members: 1092, holes: 1, sum holes: 4 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 7, forced holes: 1, sum forced holes: 4 */
	/* last cacheline: 8 bytes */
} __attribute__((__aligned__(8)));
struct Gtid_specification {
	enum enum_group_type       type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct Gtid                gtid;                 /*     8    16 */
	void set(class Gtid_specification *, rpl_sidno, rpl_gno);

	void set(class Gtid_specification *, const class Gtid  &);

	void set_automatic(class Gtid_specification *);

	void set_anonymous(class Gtid_specification *);

	void set_not_yet_determined(class Gtid_specification *);

	void set_undefined(class Gtid_specification *);

	bool equals(const class Gtid_specification  *, const class Gtid_specification  &);

	bool equals(const class Gtid_specification  *, const class Gtid  &);

	enum enum_return_status parse(class Gtid_specification *, class Sid_map *, const char  *);

	bool is_valid(const char  *);


	/* Bitfield combined with previous fields */

	static const int                  MAX_TEXT_LENGTH = 56; /*     0     0 */
	int to_string(const class Gtid_specification  *, const class Sid_map  *, char *, bool);

	int to_string(const class Gtid_specification  *, const rpl_sid  *, char *);

	void dbug_print(const class Gtid_specification  *, const char  *, bool);


	/* size: 24, cachelines: 1, members: 2, static members: 1 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class Session_tracker {
	class State_tracker *      m_trackers[5];        /*     0    40 */
	void Session_tracker(class Session_tracker *, const class Session_tracker  &);

	class Session_tracker & operator=(class Session_tracker *, const class Session_tracker  &);

public:

	void Session_tracker(class Session_tracker *);

	void ~Session_tracker(class Session_tracker *, int);

	void init(class Session_tracker *, const CHARSET_INFO  *);

	void enable(class Session_tracker *, class THD *);

	bool server_boot_verify(class Session_tracker *, const CHARSET_INFO  *, LEX_STRING);

	class State_tracker * get_tracker(const class Session_tracker  *, enum enum_session_tracker);

	bool enabled_any(class Session_tracker *);

	bool changed_any(class Session_tracker *);

	void store(class Session_tracker *, class THD *, class String &);

	void deinit(class Session_tracker *);

	void claim_memory_ownership(class Session_tracker *);


	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
class State_tracker {
public:

	void State_tracker(class State_tracker *, const class State_tracker  &);

	int ()(void) * *           _vptr.State_tracker;  /*     0     8 */
protected:

	bool                       m_enabled;            /*     8     1 */
	bool                       m_changed;            /*     9     1 */
public:

	void State_tracker(class State_tracker *);

	virtual void ~State_tracker(class State_tracker *, int);

	bool is_enabled(const class State_tracker  *);

	bool is_changed(const class State_tracker  *);

	virtual bool enable(class State_tracker *, class THD *);

	virtual bool check(class State_tracker *, class THD *, class set_var *);

	virtual bool update(class State_tracker *, class THD *);

	virtual bool store(class State_tracker *, class THD *, class String &);

	virtual void mark_as_changed(class State_tracker *, class THD *, LEX_CSTRING *);

	virtual void claim_memory_ownership(class State_tracker *);

	/* vtable has 6 entries: {
	   [2] = enable((null)), 
	   [3] = check((null)), 
	   [4] = update((null)), 
	   [5] = store((null)), 
	   [6] = mark_as_changed((null)), 
	   [7] = claim_memory_ownership((null)), 
	} */
	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct sql_digest_state {
	int                        m_last_id_index;      /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	sql_digest_storage         m_digest_storage;     /*     8    56 */
	void reset(class sql_digest_state *, unsigned char *, uint);

	bool is_empty(class sql_digest_state *);

	void sql_digest_state(class sql_digest_state *);


	/* size: 64, cachelines: 1, members: 2 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct Symbol_location {
	const char  *              start;                /*     0     8 */
	const char  *              end;                  /*     8     8 */
	bool is_empty(const class Symbol_location  *);

	size_t length(const class Symbol_location  *);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct YYLTYPE {
	struct Symbol_location     cpp;                  /*     0    16 */
	struct Symbol_location     raw;                  /*    16    16 */
	bool is_empty(const class YYLTYPE  *);


	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
struct Parse_context {
	const class THD *          thd;                  /*     0     8 */
	MEM_ROOT *                 mem_root;             /*     8     8 */
	class st_select_lex *      select;               /*    16     8 */
	void Parse_context(class Parse_context *, class THD *, class st_select_lex *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct mysql_parser_service_st {
	class THD *                (*mysql_current_session)(void); /*     0     8 */
	class THD *                (*mysql_open_session)(void); /*     8     8 */
	void                       (*mysql_start_thread)(class THD *, void * (*)(void *), void *, class st_my_thread_handle *); /*    16     8 */
	void                       (*mysql_join_thread)(class st_my_thread_handle *); /*    24     8 */
	void                       (*mysql_set_current_database)(class THD *, MYSQL_LEX_STRING); /*    32     8 */
	int                        (*mysql_parse)(class THD *, MYSQL_LEX_STRING, unsigned char, sql_condition_handler_function, void *); /*    40     8 */
	int                        (*mysql_get_statement_type)(class THD *); /*    48     8 */
	int                        (*mysql_get_statement_digest)(class THD *, unsigned char *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        (*mysql_get_number_params)(class THD *); /*    64     8 */
	int                        (*mysql_extract_prepared_params)(class THD *, int *); /*    72     8 */
	int                        (*mysql_visit_tree)(class THD *, parse_node_visit_function, unsigned char *); /*    80     8 */
	MYSQL_LEX_STRING           (*mysql_item_string)(MYSQL_ITEM); /*    88     8 */
	void                       (*mysql_free_string)(MYSQL_LEX_STRING); /*    96     8 */
	MYSQL_LEX_STRING           (*mysql_get_query)(class THD *); /*   104     8 */
	MYSQL_LEX_STRING           (*mysql_get_normalized_query)(class THD *); /*   112     8 */

	/* size: 120, cachelines: 2, members: 15 */
	/* last cacheline: 56 bytes */
};
class Bounds_checked_array<Item*> {
public:

	void Bounds_checked_array(class Bounds_checked_array<Item*> *);

	void Bounds_checked_array(class Bounds_checked_array<Item*> *, class Item * *, size_t);

	void reset(class Bounds_checked_array<Item*> *);

	void reset(class Bounds_checked_array<Item*> *, class Item * *, size_t);

	void resize(class Bounds_checked_array<Item*> *, size_t);

	class Item * & operator[](class Bounds_checked_array<Item*> *, size_t);

	class Item * const & operator[](const class Bounds_checked_array<Item*>  *, size_t);

	typedef class Item * * iterator;

	iterator begin(class Bounds_checked_array<Item*> *);

	iterator end(class Bounds_checked_array<Item*> *);

	typedef class Item * const * const_iterator;

	const_iterator begin(const class Bounds_checked_array<Item*>  *);

	const_iterator end(const class Bounds_checked_array<Item*>  *);

	size_t element_size(const class Bounds_checked_array<Item*>  *);

	size_t size(const class Bounds_checked_array<Item*>  *);

	bool is_null(const class Bounds_checked_array<Item*>  *);

	void pop_front(class Bounds_checked_array<Item*> *);

	class Item * * array(const class Bounds_checked_array<Item*>  *);

	bool operator==(const class Bounds_checked_array<Item*>  *, const class Bounds_checked_array<Item*>  &);

	bool operator!=(const class Bounds_checked_array<Item*>  *, const class Bounds_checked_array<Item*>  &);

	class Item * *             m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class DTCollation {
public:

	const CHARSET_INFO  *      collation;            /*     0     8 */
	enum Derivation            derivation;           /*     8     4 */
	uint                       repertoire;           /*    12     4 */
	void set_repertoire_from_charset(class DTCollation *, const CHARSET_INFO  *);

	void DTCollation(class DTCollation *);

	void DTCollation(class DTCollation *, const CHARSET_INFO  *, enum Derivation);

	void set(class DTCollation *, const class DTCollation  &);

	void set(class DTCollation *, const CHARSET_INFO  *, enum Derivation);

	void set(class DTCollation *, const CHARSET_INFO  *, enum Derivation, uint);

	void set_numeric(class DTCollation *);

	void set(class DTCollation *, const CHARSET_INFO  *);

	void set(class DTCollation *, enum Derivation);

	void set_repertoire(class DTCollation *, uint);

	bool aggregate(class DTCollation *, class DTCollation &, uint);

	bool set(class DTCollation *, class DTCollation &, class DTCollation &, uint);

	const char  * derivation_name(const class DTCollation  *);


	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
class Mark_field {
public:

	void Mark_field(class Mark_field *, class TABLE *, enum enum_mark_columns);

	void Mark_field(class Mark_field *, enum enum_mark_columns);

	const class TABLE *        table;                /*     0     8 */
	const enum enum_mark_columns mark;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
class Name_string : public Simple_cstring {
public:

	/* class Simple_cstring      <ancestor>; */      /*     0    16 */
	void set_or_copy(class Name_string *, const char  *, size_t, bool);

	void Name_string(class Name_string *);

	void Name_string(class Name_string *, const char  *, size_t);

	void Name_string(class Name_string *, LEX_STRING);

	void Name_string(class Name_string *, const char  *, size_t, bool);

	void Name_string(class Name_string *, LEX_STRING, bool);

	void copy(class Name_string *, const char  *, size_t, const CHARSET_INFO  *);

	void copy(class Name_string *, const char  *, size_t);

	void copy(class Name_string *, const char  *);

	void copy(class Name_string *, LEX_STRING);

	void copy(class Name_string *, const LEX_STRING  *);

	void copy(class Name_string *, class Name_string);

	bool eq(const class Name_string  *, const char  *);

	bool eq_safe(const class Name_string  *, const char  *);

	bool eq(const class Name_string  *, class Name_string);

	bool eq_safe(const class Name_string  *, class Name_string);


	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class Item_name_string : public Name_string {
	using ::copy;

	using ::copy;

	using ::copy;

	using ::copy;

	using ::copy;

	using ::copy;

public:

	/* class Name_string         <ancestor>; */      /*     0    16 */
	bool                       m_is_autogenerated;   /*    16     1 */
	void Item_name_string(class Item_name_string *);

	void Item_name_string(class Item_name_string *, class Name_string);

	void set_autogenerated(class Item_name_string *, bool);

	bool is_autogenerated(const class Item_name_string  *);

	void copy(class Item_name_string *, const char  *, size_t, const CHARSET_INFO  *, bool);


	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 1 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
struct Name_resolution_context : Sql_alloc {
	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class Name_resolution_context * outer_context;   /*     0     8 */
	class Name_resolution_context * next_context;    /*     8     8 */
	class TABLE_LIST *         table_list;           /*    16     8 */
	class TABLE_LIST *         first_name_resolution_table; /*    24     8 */
	class TABLE_LIST *         last_name_resolution_table; /*    32     8 */
	class st_select_lex *      select_lex;           /*    40     8 */
	bool                       view_error_handler;   /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	class TABLE_LIST *         view_error_handler_arg; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       resolve_in_select_list; /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	class Security_context *   security_ctx;         /*    72     8 */
	void Name_resolution_context(class Name_resolution_context *);

	void init(class Name_resolution_context *);

	void resolve_in_table_list_only(class Name_resolution_context *, class TABLE_LIST *);


	/* size: 80, cachelines: 2, members: 11 */
	/* sum members: 66, holes: 2, sum holes: 14 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 16 bytes */
};
class Bool3 {
	enum value {
		v_FALSE   = 0,
		v_UNKNOWN = 1,
		v_TRUE    = 2,
	};

public:

	const class Bool3  false3(void);

	const class Bool3  unknown3(void);

	const class Bool3  true3(void);

	bool is_true(const class Bool3  *);

	bool is_unknown(const class Bool3  *);

	bool is_false(const class Bool3  *);

	void Bool3(class Bool3 *, enum value);

	enum value                 m_val;                /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct SYMBOL {
	const char  *              name;                 /*     0     8 */
	const unsigned int         length;               /*     8     4 */
	const unsigned int         tok;                  /*    12     4 */
	int                        group;                /*    16     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct LEX_SYMBOL {
	const class SYMBOL  *      symbol;               /*     0     8 */
	char *                     str;                  /*     8     8 */
	unsigned int               length;               /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
class Key : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	void Key(class Key *, const class Key  &);


	int ()(void) * *           _vptr.Key;            /*     0     8 */
	enum keytype               type;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	KEY_CREATE_INFO            key_create_info;      /*    16    56 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	class List<Key_part_spec> columns;               /*    72    24 */
	LEX_STRING                 name;                 /*    96    16 */
	bool                       generated;            /*   112     1 */
	void Key(class Key *, enum keytype, const LEX_STRING  &, KEY_CREATE_INFO *, bool, class List<Key_part_spec> &);

	void Key(class Key *, enum keytype, const char  *, size_t, KEY_CREATE_INFO *, bool, class List<Key_part_spec> &);

	void Key(class Key *, const class Key  &, MEM_ROOT *);

	virtual void ~Key(class Key *, int);

	virtual class Key * clone(const class Key  *, MEM_ROOT *);

	/* vtable has 1 entries: {
	   [2] = clone((null)), 
	} */
	/* size: 120, cachelines: 2, members: 7 */
	/* sum members: 109, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 56 bytes */
};
struct user_resources {
	uint                       questions;            /*     0     4 */
	uint                       updates;              /*     4     4 */
	uint                       conn_per_hour;        /*     8     4 */
	uint                       user_conn;            /*    12     4 */
	uint                       specified_limits;     /*    16     4 */

	/* size: 20, cachelines: 1, members: 5 */
	/* last cacheline: 20 bytes */
};
struct user_conn {
	char *                     user;                 /*     0     8 */
	char *                     host;                 /*     8     8 */
	ulonglong                  reset_utime;          /*    16     8 */
	size_t                     len;                  /*    24     8 */
	uint                       connections;          /*    32     4 */
	uint                       conn_per_hour;        /*    36     4 */
	uint                       updates;              /*    40     4 */
	uint                       questions;            /*    44     4 */
	USER_RESOURCES             user_resources;       /*    48    20 */

	/* size: 72, cachelines: 2, members: 9 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
class Diagnostics_information : public Sql_alloc {
	enum Which_area {
		CURRENT_AREA = 0,
		STACKED_AREA = 1,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	void Diagnostics_information(class Diagnostics_information *, const class Diagnostics_information  &);

	void Diagnostics_information(class Diagnostics_information *);


	int ()(void) * *           _vptr.Diagnostics_information; /*     0     8 */
	void set_which_da(class Diagnostics_information *, enum Which_area);

	enum Which_area get_which_da(const class Diagnostics_information  *);

	virtual bool aggregate(class Diagnostics_information *, class THD *, const class Diagnostics_area  *);

protected:

	virtual void ~Diagnostics_information(class Diagnostics_information *, int);

	enum Which_area            m_area;               /*     8     4 */
	/* vtable has 1 entries: {
	   [0] = aggregate((null)), 
	} */
	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 16 bytes */
};
class Statement_information_item : public Diagnostics_information_item {
	enum Name {
		NUMBER    = 0,
		ROW_COUNT = 1,
	};

public:

	/* class Diagnostics_information_item <ancestor>; */ /*     0    16 */
	void Statement_information_item(class Statement_information_item *, enum Name, class Item *);

	class Item * get_value(class Statement_information_item *, class THD *, const class Diagnostics_area  *);

	enum Name                  m_name;               /*    16     4 */
	virtual void ~Statement_information_item(class Statement_information_item *, int);


	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 4 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class Condition_information_item : public Diagnostics_information_item {
	enum Name {
		CLASS_ORIGIN       = 0,
		SUBCLASS_ORIGIN    = 1,
		CONSTRAINT_CATALOG = 2,
		CONSTRAINT_SCHEMA  = 3,
		CONSTRAINT_NAME    = 4,
		CATALOG_NAME       = 5,
		SCHEMA_NAME        = 6,
		TABLE_NAME         = 7,
		COLUMN_NAME        = 8,
		CURSOR_NAME        = 9,
		MESSAGE_TEXT       = 10,
		MYSQL_ERRNO        = 11,
		RETURNED_SQLSTATE  = 12,
	};

public:

	/* class Diagnostics_information_item <ancestor>; */ /*     0    16 */
	void Condition_information_item(class Condition_information_item *, enum Name, class Item *);

	class Item * get_value(class Condition_information_item *, class THD *, const class Sql_condition  *);

	enum Name                  m_name;               /*    16     4 */
	class Item * make_utf8_string_item(class Condition_information_item *, class THD *, const class String  *);

	virtual void ~Condition_information_item(class Condition_information_item *, int);


	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 4 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class sp_variable : public Sql_alloc {
	enum enum_mode {
		MODE_IN    = 0,
		MODE_OUT   = 1,
		MODE_INOUT = 2,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	LEX_STRING                 name;                 /*     0    16 */
	enum enum_field_types      type;                 /*    16     4 */
	enum enum_mode             mode;                 /*    20     4 */
	uint                       offset;               /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	class Item *               default_value;        /*    32     8 */
	class Create_field        field_def;             /*    40   216 */

	/* XXX last struct has 7 bytes of padding */
	void sp_variable(class sp_variable *, LEX_STRING, enum_field_types, enum enum_mode, uint);


	/* size: 256, cachelines: 4, members: 7 */
	/* sum members: 252, holes: 1, sum holes: 4 */
	/* paddings: 2, sum paddings: 8 */
};
class sp_label : public Sql_alloc {
	enum enum_type {
		IMPLICIT  = 0,
		BEGIN     = 1,
		ITERATION = 2,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	LEX_STRING                 name;                 /*     0    16 */
	uint                       ip;                   /*    16     4 */
	enum enum_type             type;                 /*    20     4 */
	class sp_pcontext *        ctx;                  /*    24     8 */
	void sp_label(class sp_label *, LEX_STRING, uint, enum enum_type, class sp_pcontext *);


	/* size: 32, cachelines: 1, members: 5 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 32 bytes */
};
class sp_pcontext : public Sql_alloc {
	enum enum_scope {
		REGULAR_SCOPE = 0,
		HANDLER_SCOPE = 1,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	void sp_pcontext(class sp_pcontext *, class THD *);

	void ~sp_pcontext(class sp_pcontext *, int);

	class sp_pcontext * push_context(class sp_pcontext *, class THD *, enum enum_scope);

	class sp_pcontext * pop_context(class sp_pcontext *);

	class sp_pcontext * parent_context(const class sp_pcontext  *);

	int get_level(const class sp_pcontext  *);

	size_t diff_handlers(const class sp_pcontext  *, const class sp_pcontext  *, bool);

	size_t diff_cursors(const class sp_pcontext  *, const class sp_pcontext  *, bool);

	uint max_var_index(const class sp_pcontext  *);

	uint current_var_count(const class sp_pcontext  *);

	uint context_var_count(const class sp_pcontext  *);

	uint var_context2runtime(const class sp_pcontext  *, uint);

	class sp_variable * add_variable(class sp_pcontext *, class THD *, LEX_STRING, enum enum_field_types, enum enum_mode);

	void retrieve_field_definitions(const class sp_pcontext  *, class List<Create_field> *);

	class sp_variable * find_variable(const class sp_pcontext  *, LEX_STRING, bool);

	class sp_variable * find_variable(const class sp_pcontext  *, uint);

	void declare_var_boundary(class sp_pcontext *, uint);

	int get_num_case_exprs(const class sp_pcontext  *);

	int push_case_expr_id(class sp_pcontext *);

	void pop_case_expr_id(class sp_pcontext *);

	int get_current_case_expr_id(const class sp_pcontext  *);

	class sp_label * push_label(class sp_pcontext *, class THD *, LEX_STRING, uint);

	class sp_label * find_label(class sp_pcontext *, LEX_STRING);

	class sp_label * last_label(class sp_pcontext *);

	class sp_label * pop_label(class sp_pcontext *);

	bool add_condition(class sp_pcontext *, class THD *, LEX_STRING, class sp_condition_value *);

	class sp_condition_value * find_condition(const class sp_pcontext  *, LEX_STRING, bool);

	class sp_handler * add_handler(class sp_pcontext *, class THD *, enum enum_type);

	bool check_duplicate_handler(const class sp_pcontext  *, const class sp_condition_value  *);

	class sp_handler * find_handler(const class sp_pcontext  *, const char  *, uint, enum enum_severity_level);

	bool add_cursor(class sp_pcontext *, LEX_STRING);

	bool find_cursor(const class sp_pcontext  *, LEX_STRING, uint *, bool);

	const LEX_STRING  * find_cursor(const class sp_pcontext  *, uint);

	uint max_cursor_index(const class sp_pcontext  *);

	uint current_cursor_count(const class sp_pcontext  *);

	void sp_pcontext(class sp_pcontext *, class THD *, class sp_pcontext *, enum enum_scope);

	void init(class sp_pcontext *, uint, uint, int);

	void sp_pcontext(class sp_pcontext *, const class sp_pcontext  &);

	void operator=(class sp_pcontext *, class sp_pcontext &);


	int                        m_level;              /*     0     4 */
	uint                       m_max_var_index;      /*     4     4 */
	uint                       m_max_cursor_index;   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	class sp_pcontext *        m_parent;             /*    16     8 */
	uint                       m_var_offset;         /*    24     4 */
	uint                       m_cursor_offset;      /*    28     4 */
	uint                       m_pboundary;          /*    32     4 */
	int                        m_num_case_exprs;     /*    36     4 */
	class Mem_root_array<sp_variable*, true> m_vars; /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	class Mem_root_array<int, true> m_case_expr_ids; /*    72    32 */
	class Mem_root_array<sp_condition*, true> m_conditions; /*   104    32 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	class Mem_root_array<st_mysql_lex_string, true> m_cursors; /*   136    32 */
	class Mem_root_array<sp_handler*, true> m_handlers; /*   168    32 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	class List<sp_label>      m_labels;              /*   200    24 */
	class Mem_root_array<sp_pcontext*, true> m_children; /*   224    32 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	enum enum_scope            m_scope;              /*   256     4 */

	/* size: 264, cachelines: 5, members: 17 */
	/* sum members: 256, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 8 bytes */
};
class sp_condition_value : public Sql_alloc {
	enum enum_type {
		ERROR_CODE = 0,
		SQLSTATE   = 1,
		WARNING    = 2,
		NOT_FOUND  = 3,
		EXCEPTION  = 4,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	enum enum_type             type;                 /*     0     4 */
	char                       sql_state[6];         /*     4     6 */

	/* XXX 2 bytes hole, try to pack */

	uint                       mysqlerr;             /*    12     4 */
	void sp_condition_value(class sp_condition_value *, uint);

	void sp_condition_value(class sp_condition_value *, const char  *);

	void sp_condition_value(class sp_condition_value *, enum enum_type);

	void print(const class sp_condition_value  *, class String *);

	bool equals(const class sp_condition_value  *, const class sp_condition_value  *);


	/* size: 16, cachelines: 1, members: 4 */
	/* sum members: 14, holes: 1, sum holes: 2 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 16 bytes */
};
class sp_condition : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	LEX_STRING                 name;                 /*     0    16 */
	class sp_condition_value * value;                /*    16     8 */
	void sp_condition(class sp_condition *, LEX_STRING, class sp_condition_value *);


	/* size: 24, cachelines: 1, members: 3 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
class sp_handler : public Sql_alloc {
	enum enum_type {
		EXIT     = 0,
		CONTINUE = 1,
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	enum enum_type             type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class sp_pcontext *        scope;                /*     8     8 */
	class List<const sp_condition_value> condition_values; /*    16    24 */
	void sp_handler(class sp_handler *, enum enum_type, class sp_pcontext *);

	void print_conditions(const class sp_handler  *, class String *);

	void print(const class sp_handler  *, class String *);


	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 40 bytes */
};
class List<const sp_condition_value> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<const sp_condition_value> *);

	void List(class List<const sp_condition_value> *, const class List<const sp_condition_value>  &);

	class List<const sp_condition_value> & operator=(class List<const sp_condition_value> *, const class List<const sp_condition_value>  &);

	void List(class List<const sp_condition_value> *, const class List<const sp_condition_value>  &, MEM_ROOT *);

	bool push_back(class List<const sp_condition_value> *, const class sp_condition_value  *);

	bool push_back(class List<const sp_condition_value> *, const class sp_condition_value  *, MEM_ROOT *);

	bool push_front(class List<const sp_condition_value> *, const class sp_condition_value  *);

	bool push_front(class List<const sp_condition_value> *, const class sp_condition_value  *, MEM_ROOT *);

	const class sp_condition_value  * head(class List<const sp_condition_value> *);

	const class sp_condition_value  * * head_ref(class List<const sp_condition_value> *);

	const class sp_condition_value  * pop(class List<const sp_condition_value> *);

	void concat(class List<const sp_condition_value> *, class List<const sp_condition_value> *);

	void disjoin(class List<const sp_condition_value> *, class List<const sp_condition_value> *);

	void prepand(class List<const sp_condition_value> *, class List<const sp_condition_value> *);

	void delete_elements(class List<const sp_condition_value> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Mem_root_array_YY<sp_variable*, true> {
public:

	void init(class Mem_root_array_YY<sp_variable*, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<sp_variable*, true> *, MEM_ROOT *);

	class sp_variable * & at(class Mem_root_array_YY<sp_variable*, true> *, size_t);

	class sp_variable * const & at(const class Mem_root_array_YY<sp_variable*, true>  *, size_t);

	class sp_variable * & operator[](class Mem_root_array_YY<sp_variable*, true> *, size_t);

	class sp_variable * const & operator[](const class Mem_root_array_YY<sp_variable*, true>  *, size_t);

	class sp_variable * & back(class Mem_root_array_YY<sp_variable*, true> *);

	class sp_variable * const & back(const class Mem_root_array_YY<sp_variable*, true>  *);

	class sp_variable * * begin(class Mem_root_array_YY<sp_variable*, true> *);

	class sp_variable * const * begin(const class Mem_root_array_YY<sp_variable*, true>  *);

	class sp_variable * * end(class Mem_root_array_YY<sp_variable*, true> *);

	class sp_variable * const * end(const class Mem_root_array_YY<sp_variable*, true>  *);

	void clear(class Mem_root_array_YY<sp_variable*, true> *);

	void chop(class Mem_root_array_YY<sp_variable*, true> *, size_t);

	bool reserve(class Mem_root_array_YY<sp_variable*, true> *, size_t);

	bool push_back(class Mem_root_array_YY<sp_variable*, true> *, class sp_variable * const &);

	void pop_back(class Mem_root_array_YY<sp_variable*, true> *);

	void resize(class Mem_root_array_YY<sp_variable*, true> *, size_t, const value_type  &);

	typedef class sp_variable * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<sp_variable*, true>  *);

	size_t element_size(const class Mem_root_array_YY<sp_variable*, true>  *);

	bool empty(const class Mem_root_array_YY<sp_variable*, true>  *);

	size_t size(const class Mem_root_array_YY<sp_variable*, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class sp_variable * *      m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<sp_variable*, true> : public Mem_root_array_YY<sp_variable*, true> {
public:

	/* class Mem_root_array_YY<sp_variable*, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<sp_variable*, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<sp_variable*, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef class sp_variable * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<sp_variable*, true> *, int);

	void Mem_root_array(class Mem_root_array<sp_variable*, true> *, const class Mem_root_array<sp_variable*, true>  &);

	class Mem_root_array<sp_variable*, true> & operator=(class Mem_root_array<sp_variable*, true> *, const class Mem_root_array<sp_variable*, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Mem_root_array_YY<int, true> {
public:

	void init(class Mem_root_array_YY<int, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<int, true> *, MEM_ROOT *);

	int & at(class Mem_root_array_YY<int, true> *, size_t);

	const int  & at(const class Mem_root_array_YY<int, true>  *, size_t);

	int & operator[](class Mem_root_array_YY<int, true> *, size_t);

	const int  & operator[](const class Mem_root_array_YY<int, true>  *, size_t);

	int & back(class Mem_root_array_YY<int, true> *);

	const int  & back(const class Mem_root_array_YY<int, true>  *);

	int * begin(class Mem_root_array_YY<int, true> *);

	const int  * begin(const class Mem_root_array_YY<int, true>  *);

	int * end(class Mem_root_array_YY<int, true> *);

	const int  * end(const class Mem_root_array_YY<int, true>  *);

	void clear(class Mem_root_array_YY<int, true> *);

	void chop(class Mem_root_array_YY<int, true> *, size_t);

	bool reserve(class Mem_root_array_YY<int, true> *, size_t);

	bool push_back(class Mem_root_array_YY<int, true> *, const int  &);

	void pop_back(class Mem_root_array_YY<int, true> *);

	void resize(class Mem_root_array_YY<int, true> *, size_t, const value_type  &);

	typedef int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<int, true>  *);

	size_t element_size(const class Mem_root_array_YY<int, true>  *);

	bool empty(const class Mem_root_array_YY<int, true>  *);

	size_t size(const class Mem_root_array_YY<int, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	int *                      m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<int, true> : public Mem_root_array_YY<int, true> {
public:

	/* class Mem_root_array_YY<int, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<int, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<int, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<int, true> *, int);

	void Mem_root_array(class Mem_root_array<int, true> *, const class Mem_root_array<int, true>  &);

	class Mem_root_array<int, true> & operator=(class Mem_root_array<int, true> *, const class Mem_root_array<int, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Mem_root_array_YY<sp_condition*, true> {
public:

	void init(class Mem_root_array_YY<sp_condition*, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<sp_condition*, true> *, MEM_ROOT *);

	class sp_condition * & at(class Mem_root_array_YY<sp_condition*, true> *, size_t);

	class sp_condition * const & at(const class Mem_root_array_YY<sp_condition*, true>  *, size_t);

	class sp_condition * & operator[](class Mem_root_array_YY<sp_condition*, true> *, size_t);

	class sp_condition * const & operator[](const class Mem_root_array_YY<sp_condition*, true>  *, size_t);

	class sp_condition * & back(class Mem_root_array_YY<sp_condition*, true> *);

	class sp_condition * const & back(const class Mem_root_array_YY<sp_condition*, true>  *);

	class sp_condition * * begin(class Mem_root_array_YY<sp_condition*, true> *);

	class sp_condition * const * begin(const class Mem_root_array_YY<sp_condition*, true>  *);

	class sp_condition * * end(class Mem_root_array_YY<sp_condition*, true> *);

	class sp_condition * const * end(const class Mem_root_array_YY<sp_condition*, true>  *);

	void clear(class Mem_root_array_YY<sp_condition*, true> *);

	void chop(class Mem_root_array_YY<sp_condition*, true> *, size_t);

	bool reserve(class Mem_root_array_YY<sp_condition*, true> *, size_t);

	bool push_back(class Mem_root_array_YY<sp_condition*, true> *, class sp_condition * const &);

	void pop_back(class Mem_root_array_YY<sp_condition*, true> *);

	void resize(class Mem_root_array_YY<sp_condition*, true> *, size_t, const value_type  &);

	typedef class sp_condition * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<sp_condition*, true>  *);

	size_t element_size(const class Mem_root_array_YY<sp_condition*, true>  *);

	bool empty(const class Mem_root_array_YY<sp_condition*, true>  *);

	size_t size(const class Mem_root_array_YY<sp_condition*, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class sp_condition * *     m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<sp_condition*, true> : public Mem_root_array_YY<sp_condition*, true> {
public:

	/* class Mem_root_array_YY<sp_condition*, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<sp_condition*, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<sp_condition*, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef class sp_condition * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<sp_condition*, true> *, int);

	void Mem_root_array(class Mem_root_array<sp_condition*, true> *, const class Mem_root_array<sp_condition*, true>  &);

	class Mem_root_array<sp_condition*, true> & operator=(class Mem_root_array<sp_condition*, true> *, const class Mem_root_array<sp_condition*, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Mem_root_array_YY<st_mysql_lex_string, true> {
public:

	void init(class Mem_root_array_YY<st_mysql_lex_string, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<st_mysql_lex_string, true> *, MEM_ROOT *);

	class st_mysql_lex_string & at(class Mem_root_array_YY<st_mysql_lex_string, true> *, size_t);

	const class st_mysql_lex_string  & at(const class Mem_root_array_YY<st_mysql_lex_string, true>  *, size_t);

	class st_mysql_lex_string & operator[](class Mem_root_array_YY<st_mysql_lex_string, true> *, size_t);

	const class st_mysql_lex_string  & operator[](const class Mem_root_array_YY<st_mysql_lex_string, true>  *, size_t);

	class st_mysql_lex_string & back(class Mem_root_array_YY<st_mysql_lex_string, true> *);

	const class st_mysql_lex_string  & back(const class Mem_root_array_YY<st_mysql_lex_string, true>  *);

	class st_mysql_lex_string * begin(class Mem_root_array_YY<st_mysql_lex_string, true> *);

	const class st_mysql_lex_string  * begin(const class Mem_root_array_YY<st_mysql_lex_string, true>  *);

	class st_mysql_lex_string * end(class Mem_root_array_YY<st_mysql_lex_string, true> *);

	const class st_mysql_lex_string  * end(const class Mem_root_array_YY<st_mysql_lex_string, true>  *);

	void clear(class Mem_root_array_YY<st_mysql_lex_string, true> *);

	void chop(class Mem_root_array_YY<st_mysql_lex_string, true> *, size_t);

	bool reserve(class Mem_root_array_YY<st_mysql_lex_string, true> *, size_t);

	bool push_back(class Mem_root_array_YY<st_mysql_lex_string, true> *, const class st_mysql_lex_string  &);

	void pop_back(class Mem_root_array_YY<st_mysql_lex_string, true> *);

	void resize(class Mem_root_array_YY<st_mysql_lex_string, true> *, size_t, const value_type  &);

	typedef struct st_mysql_lex_string value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<st_mysql_lex_string, true>  *);

	size_t element_size(const class Mem_root_array_YY<st_mysql_lex_string, true>  *);

	bool empty(const class Mem_root_array_YY<st_mysql_lex_string, true>  *);

	size_t size(const class Mem_root_array_YY<st_mysql_lex_string, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class st_mysql_lex_string * m_array;             /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<st_mysql_lex_string, true> : public Mem_root_array_YY<st_mysql_lex_string, true> {
public:

	/* class Mem_root_array_YY<st_mysql_lex_string, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<st_mysql_lex_string, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<st_mysql_lex_string, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef struct st_mysql_lex_string value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<st_mysql_lex_string, true> *, int);

	void Mem_root_array(class Mem_root_array<st_mysql_lex_string, true> *, const class Mem_root_array<st_mysql_lex_string, true>  &);

	class Mem_root_array<st_mysql_lex_string, true> & operator=(class Mem_root_array<st_mysql_lex_string, true> *, const class Mem_root_array<st_mysql_lex_string, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Mem_root_array_YY<sp_handler*, true> {
public:

	void init(class Mem_root_array_YY<sp_handler*, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<sp_handler*, true> *, MEM_ROOT *);

	class sp_handler * & at(class Mem_root_array_YY<sp_handler*, true> *, size_t);

	class sp_handler * const & at(const class Mem_root_array_YY<sp_handler*, true>  *, size_t);

	class sp_handler * & operator[](class Mem_root_array_YY<sp_handler*, true> *, size_t);

	class sp_handler * const & operator[](const class Mem_root_array_YY<sp_handler*, true>  *, size_t);

	class sp_handler * & back(class Mem_root_array_YY<sp_handler*, true> *);

	class sp_handler * const & back(const class Mem_root_array_YY<sp_handler*, true>  *);

	class sp_handler * * begin(class Mem_root_array_YY<sp_handler*, true> *);

	class sp_handler * const * begin(const class Mem_root_array_YY<sp_handler*, true>  *);

	class sp_handler * * end(class Mem_root_array_YY<sp_handler*, true> *);

	class sp_handler * const * end(const class Mem_root_array_YY<sp_handler*, true>  *);

	void clear(class Mem_root_array_YY<sp_handler*, true> *);

	void chop(class Mem_root_array_YY<sp_handler*, true> *, size_t);

	bool reserve(class Mem_root_array_YY<sp_handler*, true> *, size_t);

	bool push_back(class Mem_root_array_YY<sp_handler*, true> *, class sp_handler * const &);

	void pop_back(class Mem_root_array_YY<sp_handler*, true> *);

	void resize(class Mem_root_array_YY<sp_handler*, true> *, size_t, const value_type  &);

	typedef class sp_handler * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<sp_handler*, true>  *);

	size_t element_size(const class Mem_root_array_YY<sp_handler*, true>  *);

	bool empty(const class Mem_root_array_YY<sp_handler*, true>  *);

	size_t size(const class Mem_root_array_YY<sp_handler*, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class sp_handler * *       m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<sp_handler*, true> : public Mem_root_array_YY<sp_handler*, true> {
public:

	/* class Mem_root_array_YY<sp_handler*, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<sp_handler*, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<sp_handler*, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef class sp_handler * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<sp_handler*, true> *, int);

	void Mem_root_array(class Mem_root_array<sp_handler*, true> *, const class Mem_root_array<sp_handler*, true>  &);

	class Mem_root_array<sp_handler*, true> & operator=(class Mem_root_array<sp_handler*, true> *, const class Mem_root_array<sp_handler*, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class List<sp_label> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<sp_label> *);

	void List(class List<sp_label> *, const class List<sp_label>  &);

	class List<sp_label> & operator=(class List<sp_label> *, const class List<sp_label>  &);

	void List(class List<sp_label> *, const class List<sp_label>  &, MEM_ROOT *);

	bool push_back(class List<sp_label> *, class sp_label *);

	bool push_back(class List<sp_label> *, class sp_label *, MEM_ROOT *);

	bool push_front(class List<sp_label> *, class sp_label *);

	bool push_front(class List<sp_label> *, class sp_label *, MEM_ROOT *);

	class sp_label * head(class List<sp_label> *);

	class sp_label * * head_ref(class List<sp_label> *);

	class sp_label * pop(class List<sp_label> *);

	void concat(class List<sp_label> *, class List<sp_label> *);

	void disjoin(class List<sp_label> *, class List<sp_label> *);

	void prepand(class List<sp_label> *, class List<sp_label> *);

	void delete_elements(class List<sp_label> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Mem_root_array_YY<sp_pcontext*, true> {
public:

	void init(class Mem_root_array_YY<sp_pcontext*, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<sp_pcontext*, true> *, MEM_ROOT *);

	class sp_pcontext * & at(class Mem_root_array_YY<sp_pcontext*, true> *, size_t);

	class sp_pcontext * const & at(const class Mem_root_array_YY<sp_pcontext*, true>  *, size_t);

	class sp_pcontext * & operator[](class Mem_root_array_YY<sp_pcontext*, true> *, size_t);

	class sp_pcontext * const & operator[](const class Mem_root_array_YY<sp_pcontext*, true>  *, size_t);

	class sp_pcontext * & back(class Mem_root_array_YY<sp_pcontext*, true> *);

	class sp_pcontext * const & back(const class Mem_root_array_YY<sp_pcontext*, true>  *);

	class sp_pcontext * * begin(class Mem_root_array_YY<sp_pcontext*, true> *);

	class sp_pcontext * const * begin(const class Mem_root_array_YY<sp_pcontext*, true>  *);

	class sp_pcontext * * end(class Mem_root_array_YY<sp_pcontext*, true> *);

	class sp_pcontext * const * end(const class Mem_root_array_YY<sp_pcontext*, true>  *);

	void clear(class Mem_root_array_YY<sp_pcontext*, true> *);

	void chop(class Mem_root_array_YY<sp_pcontext*, true> *, size_t);

	bool reserve(class Mem_root_array_YY<sp_pcontext*, true> *, size_t);

	bool push_back(class Mem_root_array_YY<sp_pcontext*, true> *, class sp_pcontext * const &);

	void pop_back(class Mem_root_array_YY<sp_pcontext*, true> *);

	void resize(class Mem_root_array_YY<sp_pcontext*, true> *, size_t, const value_type  &);

	typedef class sp_pcontext * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<sp_pcontext*, true>  *);

	size_t element_size(const class Mem_root_array_YY<sp_pcontext*, true>  *);

	bool empty(const class Mem_root_array_YY<sp_pcontext*, true>  *);

	size_t size(const class Mem_root_array_YY<sp_pcontext*, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class sp_pcontext * *      m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array<sp_pcontext*, true> : public Mem_root_array_YY<sp_pcontext*, true> {
public:

	/* class Mem_root_array_YY<sp_pcontext*, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<sp_pcontext*, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<sp_pcontext*, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef class sp_pcontext * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<sp_pcontext*, true> *, int);

	void Mem_root_array(class Mem_root_array<sp_pcontext*, true> *, const class Mem_root_array<sp_pcontext*, true>  &);

	class Mem_root_array<sp_pcontext*, true> & operator=(class Mem_root_array<sp_pcontext*, true> *, const class Mem_root_array<sp_pcontext*, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Set_signal_information : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	void Set_signal_information(class Set_signal_information *);

	void ~Set_signal_information(class Set_signal_information *, int);

	bool set_item(class Set_signal_information *, enum enum_condition_item_name, class Item *);


	class Item *               m_item[12];           /*     0    96 */

	/* size: 96, cachelines: 2, members: 2 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 32 bytes */
};
struct srv_session_service_st {
	int                        (*init_session_thread)(const void  *); /*     0     8 */
	void                       (*deinit_session_thread)(void); /*     8     8 */
	MYSQL_SESSION              (*open_session)(srv_session_error_cb, void *); /*    16     8 */
	int                        (*detach_session)(MYSQL_SESSION); /*    24     8 */
	int                        (*close_session)(MYSQL_SESSION); /*    32     8 */
	int                        (*server_is_available)(void); /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct srv_session_info_service_st {
	class THD *                (*get_thd)(MYSQL_SESSION); /*     0     8 */
	my_thread_id               (*get_session_id)(MYSQL_SESSION); /*     8     8 */
	LEX_CSTRING                (*get_current_db)(MYSQL_SESSION); /*    16     8 */
	uint16_t                   (*get_client_port)(MYSQL_SESSION); /*    24     8 */
	int                        (*set_client_port)(MYSQL_SESSION, uint16_t); /*    32     8 */
	int                        (*set_connection_type)(MYSQL_SESSION, enum enum_vio_type); /*    40     8 */
	int                        (*killed)(MYSQL_SESSION); /*    48     8 */
	unsigned int               (*session_count)(void); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned int               (*thread_count)(const void  *); /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* last cacheline: 8 bytes */
};
struct st_send_field {
	const char  *              db_name;              /*     0     8 */
	const char  *              table_name;           /*     8     8 */
	const char  *              org_table_name;       /*    16     8 */
	const char  *              col_name;             /*    24     8 */
	const char  *              org_col_name;         /*    32     8 */
	long unsigned int          length;               /*    40     8 */
	unsigned int               charsetnr;            /*    48     4 */
	unsigned int               flags;                /*    52     4 */
	unsigned int               decimals;             /*    56     4 */
	enum_field_types           type;                 /*    60     4 */

	/* size: 64, cachelines: 1, members: 10 */
};
struct st_command_service_cbs {
	int                        (*start_result_metadata)(void *, uint, uint, const CHARSET_INFO  *); /*     0     8 */
	int                        (*field_metadata)(void *, class st_send_field *, const CHARSET_INFO  *); /*     8     8 */
	int                        (*end_result_metadata)(void *, uint, uint); /*    16     8 */
	int                        (*start_row)(void *); /*    24     8 */
	int                        (*end_row)(void *);   /*    32     8 */
	void                       (*abort_row)(void *); /*    40     8 */
	ulong                      (*get_client_capabilities)(void *); /*    48     8 */
	int                        (*get_null)(void *);  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        (*get_integer)(void *, longlong); /*    64     8 */
	int                        (*get_longlong)(void *, longlong, uint); /*    72     8 */
	int                        (*get_decimal)(void *, const decimal_t  *); /*    80     8 */
	int                        (*get_double)(void *, double, uint32_t); /*    88     8 */
	int                        (*get_date)(void *, const MYSQL_TIME  *); /*    96     8 */
	int                        (*get_time)(void *, const MYSQL_TIME  *, uint); /*   104     8 */
	int                        (*get_datetime)(void *, const MYSQL_TIME  *, uint); /*   112     8 */
	int                        (*get_string)(void *, const char  *, size_t, const CHARSET_INFO  *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void                       (*handle_ok)(void *, uint, uint, ulonglong, ulonglong, const char  *); /*   128     8 */
	void                       (*handle_error)(void *, uint, const char  *, const char  *); /*   136     8 */
	void                       (*shutdown)(void *, int); /*   144     8 */

	/* size: 152, cachelines: 3, members: 19 */
	/* last cacheline: 24 bytes */
};
struct command_service_st {
	int                        (*run_command)(MYSQL_SESSION, enum enum_server_command, const union COM_DATA  *, const CHARSET_INFO  *, const class st_command_service_cbs  *, enum cs_text_or_binary, void *); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct thd_alloc_service_st {
	void *                     (*thd_alloc_func)(class THD *, size_t); /*     0     8 */
	void *                     (*thd_calloc_func)(class THD *, size_t); /*     8     8 */
	char *                     (*thd_strdup_func)(class THD *, const char  *); /*    16     8 */
	char *                     (*thd_strmake_func)(class THD *, const char  *, size_t); /*    24     8 */
	void *                     (*thd_memdup_func)(class THD *, const void  *, size_t); /*    32     8 */
	MYSQL_LEX_STRING *         (*thd_make_lex_string_func)(class THD *, MYSQL_LEX_STRING *, const char  *, size_t, int); /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct thd_wait_service_st {
	void                       (*thd_wait_begin_func)(class THD *, int); /*     0     8 */
	void                       (*thd_wait_end_func)(class THD *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct my_thread_scheduler_service {
	int                        (*connection_handler_set)(class Connection_handler_functions *, class THD_event_functions *); /*     0     8 */
	int                        (*connection_handler_reset)(void); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct THD_event_functions {
	void                       (*thd_wait_begin)(class THD *, int); /*     0     8 */
	void                       (*thd_wait_end)(class THD *); /*     8     8 */
	void                       (*post_kill_notification)(class THD *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct my_plugin_log_service {
	int                        (*my_plugin_log_message)(MYSQL_PLUGIN *, enum plugin_log_level, const char  *, ...); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct mysql_string_service_st {
	int                        (*mysql_string_convert_to_char_ptr_type)(mysql_string_handle, const char  *, char *, unsigned int, int *); /*     0     8 */
	mysql_string_iterator_handle (*mysql_string_get_iterator_type)(mysql_string_handle); /*     8     8 */
	int                        (*mysql_string_iterator_next_type)(mysql_string_iterator_handle); /*    16     8 */
	int                        (*mysql_string_iterator_isupper_type)(mysql_string_iterator_handle); /*    24     8 */
	int                        (*mysql_string_iterator_islower_type)(mysql_string_iterator_handle); /*    32     8 */
	int                        (*mysql_string_iterator_isdigit_type)(mysql_string_iterator_handle); /*    40     8 */
	mysql_string_handle        (*mysql_string_to_lowercase_type)(mysql_string_handle); /*    48     8 */
	void                       (*mysql_string_free_type)(mysql_string_handle); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*mysql_string_iterator_free_type)(mysql_string_iterator_handle); /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* last cacheline: 8 bytes */
};
struct mysql_password_policy_service_st {
	int                        (*my_validate_password_policy_func)(const char  *, unsigned int); /*     0     8 */
	int                        (*my_calculate_password_strength_func)(const char  *, unsigned int); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct st_transaction_termination_ctx {
	long unsigned int          m_thread_id;          /*     0     8 */
	unsigned int               m_flags;              /*     8     4 */
	char                       m_rollback_transaction; /*    12     1 */
	char                       m_generated_gtid;     /*    13     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        m_sidno;              /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	long long int              m_gno;                /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* sum members: 26, holes: 2, sum holes: 6 */
	/* last cacheline: 32 bytes */
};
struct rpl_transaction_ctx_service_st {
	int                        (*set_transaction_ctx)(Transaction_termination_ctx); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct st_trans_write_set {
	unsigned int               m_flags;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int          write_set_size;       /*     8     8 */
	long long unsigned int *   write_set;            /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct transaction_write_set_service_st {
	Transaction_write_set *    (*get_transaction_write_set)(long unsigned int); /*     0     8 */
	void                       (*require_full_write_set)(int); /*     8     8 */
	void                       (*set_write_set_memory_size_limit)(long long int); /*    16     8 */
	void                       (*update_write_set_memory_size_limit)(long long int); /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct security_context_service_st {
	my_svc_bool                (*thd_get_security_context)(class THD *, class Security_context * *); /*     0     8 */
	my_svc_bool                (*thd_set_security_context)(class THD *, class Security_context *); /*     8     8 */
	my_svc_bool                (*security_context_create)(class Security_context * *); /*    16     8 */
	my_svc_bool                (*security_context_destroy)(class Security_context *); /*    24     8 */
	my_svc_bool                (*security_context_copy)(class Security_context *, class Security_context * *); /*    32     8 */
	my_svc_bool                (*security_context_lookup)(class Security_context *, const char  *, const char  *, const char  *, const char  *); /*    40     8 */
	my_svc_bool                (*security_context_get_option)(class Security_context *, const char  *, void *); /*    48     8 */
	my_svc_bool                (*security_context_set_option)(class Security_context *, const char  *, void *); /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct mysql_locking_service_st {
	int                        (*mysql_acquire_locks)(class THD *, const char  *, const char  * *, size_t, enum enum_locking_service_lock_type, long unsigned int); /*     0     8 */
	int                        (*mysql_release_locks)(class THD *, const char  *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct mysql_keyring_service_st {
	int                        (*my_key_store_func)(const char  *, const char  *, const char  *, const void  *, size_t); /*     0     8 */
	int                        (*my_key_fetch_func)(const char  *, char * *, const char  *, void * *, size_t *); /*     8     8 */
	int                        (*my_key_remove_func)(const char  *, const char  *); /*    16     8 */
	int                        (*my_key_generate_func)(const char  *, const char  *, const char  *, size_t); /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct st_mysql_xid {
	long int                   formatID;             /*     0     8 */
	long int                   gtrid_length;         /*     8     8 */
	long int                   bqual_length;         /*    16     8 */
	char                       data[128];            /*    24   128 */

	/* size: 152, cachelines: 3, members: 4 */
	/* last cacheline: 24 bytes */
};
class XID_STATE {
	enum xa_states {
		XA_NOTR          = 0,
		XA_ACTIVE        = 1,
		XA_IDLE          = 2,
		XA_PREPARED      = 3,
		XA_ROLLBACK_ONLY = 4,
	};

	static const char  *              xa_state_names[0]; /*     0     0 */
	XID                        m_xid;                /*     0   152 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	enum xa_states             xa_state;             /*   152     4 */
	bool                       in_recovery;          /*   156     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       rm_error;             /*   160     4 */
	bool                       m_is_binlogged;       /*   164     1 */
public:

	void XID_STATE(class XID_STATE *);

	void set_state(class XID_STATE *, enum xa_states);

	enum xa_states get_state(class XID_STATE *);

	bool has_state(const class XID_STATE  *, enum xa_states);

	const char  * state_name(const class XID_STATE  *);

	const XID  * get_xid(const class XID_STATE  *);

	XID * get_xid(class XID_STATE *);

	bool has_same_xid(const class XID_STATE  *, const XID  *);

	void set_query_id(class XID_STATE *, query_id_t);

	void set_error(class XID_STATE *, class THD *);

	void reset_error(class XID_STATE *);

	void cleanup(class XID_STATE *);

	void reset(class XID_STATE *);

	void start_normal_xa(class XID_STATE *, const XID  *);

	void start_recovery_xa(class XID_STATE *, const XID  *, bool);

	bool is_in_recovery(const class XID_STATE  *);

	bool is_binlogged(const class XID_STATE  *);

	void set_binlogged(class XID_STATE *);

	void unset_binlogged(class XID_STATE *);

	void store_xid_info(const class XID_STATE  *, class Protocol *, bool);

	bool xa_trans_rolled_back(class XID_STATE *);

	bool check_xa_idle_or_prepared(const class XID_STATE  *, bool);

	bool check_has_uncommitted_xa(const class XID_STATE  *);

	bool check_in_xa(const class XID_STATE  *, bool);


	/* size: 168, cachelines: 3, members: 5, static members: 1 */
	/* sum members: 162, holes: 1, sum holes: 3 */
	/* padding: 3 */
	/* last cacheline: 40 bytes */
};
class Opt_hints_map : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	class Bitmap<64>          hints;                 /*     0     8 */
	class Bitmap<64>          hints_specified;       /*     8     8 */
	my_bool is_specified(const class Opt_hints_map  *, enum opt_hints_enum);

	void set_switch(class Opt_hints_map *, enum opt_hints_enum, bool);

	bool switch_on(const class Opt_hints_map  *, enum opt_hints_enum);


	/* size: 16, cachelines: 1, members: 3 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 16 bytes */
};
class Mem_root_array_YY<Opt_hints*, true> {
public:

	void init(class Mem_root_array_YY<Opt_hints*, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<Opt_hints*, true> *, MEM_ROOT *);

	class Opt_hints * & at(class Mem_root_array_YY<Opt_hints*, true> *, size_t);

	class Opt_hints * const & at(const class Mem_root_array_YY<Opt_hints*, true>  *, size_t);

	class Opt_hints * & operator[](class Mem_root_array_YY<Opt_hints*, true> *, size_t);

	class Opt_hints * const & operator[](const class Mem_root_array_YY<Opt_hints*, true>  *, size_t);

	class Opt_hints * & back(class Mem_root_array_YY<Opt_hints*, true> *);

	class Opt_hints * const & back(const class Mem_root_array_YY<Opt_hints*, true>  *);

	class Opt_hints * * begin(class Mem_root_array_YY<Opt_hints*, true> *);

	class Opt_hints * const * begin(const class Mem_root_array_YY<Opt_hints*, true>  *);

	class Opt_hints * * end(class Mem_root_array_YY<Opt_hints*, true> *);

	class Opt_hints * const * end(const class Mem_root_array_YY<Opt_hints*, true>  *);

	void clear(class Mem_root_array_YY<Opt_hints*, true> *);

	void chop(class Mem_root_array_YY<Opt_hints*, true> *, size_t);

	bool reserve(class Mem_root_array_YY<Opt_hints*, true> *, size_t);

	bool push_back(class Mem_root_array_YY<Opt_hints*, true> *, class Opt_hints * const &);

	void pop_back(class Mem_root_array_YY<Opt_hints*, true> *);

	void resize(class Mem_root_array_YY<Opt_hints*, true> *, size_t, const value_type  &);

	typedef class Opt_hints * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<Opt_hints*, true>  *);

	size_t element_size(const class Mem_root_array_YY<Opt_hints*, true>  *);

	bool empty(const class Mem_root_array_YY<Opt_hints*, true>  *);

	size_t size(const class Mem_root_array_YY<Opt_hints*, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class Opt_hints * *        m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Opt_hints : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	void ~Opt_hints(class Opt_hints *, int);

	void Opt_hints(class Opt_hints *, const class Opt_hints  &);


	int ()(void) * *           _vptr.Opt_hints;      /*     0     8 */
	const LEX_CSTRING  *       name;                 /*     8     8 */
	class Opt_hints *          parent;               /*    16     8 */
	class Opt_hints_map       hints_map;             /*    24    16 */
	class Mem_root_array<Opt_hints*, true> child_array; /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	bool                       resolved;             /*    72     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       resolved_children;    /*    76     4 */
	void Opt_hints(class Opt_hints *, const LEX_CSTRING  *, class Opt_hints *, MEM_ROOT *);

	bool is_specified(const class Opt_hints  *, enum opt_hints_enum);

	bool set_switch(class Opt_hints *, bool, enum opt_hints_enum, bool);

	bool get_switch(const class Opt_hints  *, enum opt_hints_enum);

	virtual const LEX_CSTRING  * get_name(const class Opt_hints  *);

	void set_name(class Opt_hints *, const LEX_CSTRING  *);

	class Opt_hints * get_parent(const class Opt_hints  *);

	void set_resolved(class Opt_hints *);

	bool is_resolved(const class Opt_hints  *);

	void incr_resolved_children(class Opt_hints *);

	class Mem_root_array<Opt_hints*, true> * child_array_ptr(class Opt_hints *);

	bool is_all_resolved(const class Opt_hints  *);

	void register_child(class Opt_hints *, class Opt_hints *);

	virtual class PT_hint * get_complex_hints(class Opt_hints *, enum opt_hints_enum);

	class Opt_hints * find_by_name(const class Opt_hints  *, const LEX_CSTRING  *, const CHARSET_INFO  *);

	void print(class Opt_hints *, class THD *, class String *, enum enum_query_type);

	void check_unresolved(class Opt_hints *, class THD *);

	virtual void append_name(class Opt_hints *, class THD *, class String *);

	void append_hint_type(class Opt_hints *, class String *, enum opt_hints_enum);

	void print_warn_unresolved(class Opt_hints *, class THD *);

	/* vtable has 3 entries: {
	   [0] = get_name((null)), 
	   [1] = get_complex_hints((null)), 
	   [2] = append_name((null)), 
	} */
	/* size: 80, cachelines: 2, members: 8 */
	/* sum members: 77, holes: 1, sum holes: 3 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 16 bytes */
};
class Mem_root_array<Opt_hints*, true> : public Mem_root_array_YY<Opt_hints*, true> {
public:

	/* class Mem_root_array_YY<Opt_hints*, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<Opt_hints*, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<Opt_hints*, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef class Opt_hints * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<Opt_hints*, true> *, int);

	void Mem_root_array(class Mem_root_array<Opt_hints*, true> *, const class Mem_root_array<Opt_hints*, true>  &);

	class Mem_root_array<Opt_hints*, true> & operator=(class Mem_root_array<Opt_hints*, true> *, const class Mem_root_array<Opt_hints*, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Mem_root_array_YY<Opt_hints_key*, true> {
public:

	void init(class Mem_root_array_YY<Opt_hints_key*, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<Opt_hints_key*, true> *, MEM_ROOT *);

	class Opt_hints_key * & at(class Mem_root_array_YY<Opt_hints_key*, true> *, size_t);

	class Opt_hints_key * const & at(const class Mem_root_array_YY<Opt_hints_key*, true>  *, size_t);

	class Opt_hints_key * & operator[](class Mem_root_array_YY<Opt_hints_key*, true> *, size_t);

	class Opt_hints_key * const & operator[](const class Mem_root_array_YY<Opt_hints_key*, true>  *, size_t);

	class Opt_hints_key * & back(class Mem_root_array_YY<Opt_hints_key*, true> *);

	class Opt_hints_key * const & back(const class Mem_root_array_YY<Opt_hints_key*, true>  *);

	class Opt_hints_key * * begin(class Mem_root_array_YY<Opt_hints_key*, true> *);

	class Opt_hints_key * const * begin(const class Mem_root_array_YY<Opt_hints_key*, true>  *);

	class Opt_hints_key * * end(class Mem_root_array_YY<Opt_hints_key*, true> *);

	class Opt_hints_key * const * end(const class Mem_root_array_YY<Opt_hints_key*, true>  *);

	void clear(class Mem_root_array_YY<Opt_hints_key*, true> *);

	void chop(class Mem_root_array_YY<Opt_hints_key*, true> *, size_t);

	bool reserve(class Mem_root_array_YY<Opt_hints_key*, true> *, size_t);

	bool push_back(class Mem_root_array_YY<Opt_hints_key*, true> *, class Opt_hints_key * const &);

	void pop_back(class Mem_root_array_YY<Opt_hints_key*, true> *);

	void resize(class Mem_root_array_YY<Opt_hints_key*, true> *, size_t, const value_type  &);

	typedef class Opt_hints_key * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<Opt_hints_key*, true>  *);

	size_t element_size(const class Mem_root_array_YY<Opt_hints_key*, true>  *);

	bool empty(const class Mem_root_array_YY<Opt_hints_key*, true>  *);

	size_t size(const class Mem_root_array_YY<Opt_hints_key*, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class Opt_hints_key * *    m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Opt_hints_key : public Opt_hints {
public:

	/* class Opt_hints           <ancestor>; */      /*     0    80 */
	void Opt_hints_key(class Opt_hints_key *, const LEX_CSTRING  *, class Opt_hints_table *, MEM_ROOT *);

	virtual void append_name(class Opt_hints_key *, class THD *, class String *);

	/* vtable has 1 entries: {
	   [2] = append_name((null)), 
	} */
	/* size: 80, cachelines: 2, members: 1 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 80 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 640 bits */
};
class Mem_root_array<Opt_hints_key*, true> : public Mem_root_array_YY<Opt_hints_key*, true> {
public:

	/* class Mem_root_array_YY<Opt_hints_key*, true> <ancestor>; */ /*     0    32 */
	void Mem_root_array(class Mem_root_array<Opt_hints_key*, true> *, MEM_ROOT *);

	void Mem_root_array(class Mem_root_array<Opt_hints_key*, true> *, MEM_ROOT *, size_t, const value_type  &);

	typedef class Opt_hints_key * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	void ~Mem_root_array(class Mem_root_array<Opt_hints_key*, true> *, int);

	void Mem_root_array(class Mem_root_array<Opt_hints_key*, true> *, const class Mem_root_array<Opt_hints_key*, true>  &);

	class Mem_root_array<Opt_hints_key*, true> & operator=(class Mem_root_array<Opt_hints_key*, true> *, const class Mem_root_array<Opt_hints_key*, true>  &);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
struct Hint_param_table {
	LEX_CSTRING                table;                /*     0    16 */
	LEX_CSTRING                opt_query_block;      /*    16    16 */

	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array_YY<st_mysql_const_lex_string, true> {
public:

	void init(class Mem_root_array_YY<st_mysql_const_lex_string, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<st_mysql_const_lex_string, true> *, MEM_ROOT *);

	class st_mysql_const_lex_string & at(class Mem_root_array_YY<st_mysql_const_lex_string, true> *, size_t);

	const class st_mysql_const_lex_string  & at(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *, size_t);

	class st_mysql_const_lex_string & operator[](class Mem_root_array_YY<st_mysql_const_lex_string, true> *, size_t);

	const class st_mysql_const_lex_string  & operator[](const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *, size_t);

	class st_mysql_const_lex_string & back(class Mem_root_array_YY<st_mysql_const_lex_string, true> *);

	const class st_mysql_const_lex_string  & back(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *);

	class st_mysql_const_lex_string * begin(class Mem_root_array_YY<st_mysql_const_lex_string, true> *);

	const class st_mysql_const_lex_string  * begin(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *);

	class st_mysql_const_lex_string * end(class Mem_root_array_YY<st_mysql_const_lex_string, true> *);

	const class st_mysql_const_lex_string  * end(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *);

	void clear(class Mem_root_array_YY<st_mysql_const_lex_string, true> *);

	void chop(class Mem_root_array_YY<st_mysql_const_lex_string, true> *, size_t);

	bool reserve(class Mem_root_array_YY<st_mysql_const_lex_string, true> *, size_t);

	bool push_back(class Mem_root_array_YY<st_mysql_const_lex_string, true> *, const class st_mysql_const_lex_string  &);

	void pop_back(class Mem_root_array_YY<st_mysql_const_lex_string, true> *);

	void resize(class Mem_root_array_YY<st_mysql_const_lex_string, true> *, size_t, const value_type  &);

	typedef struct st_mysql_const_lex_string value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *);

	size_t element_size(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *);

	bool empty(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *);

	size_t size(const class Mem_root_array_YY<st_mysql_const_lex_string, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class st_mysql_const_lex_string * m_array;       /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array_YY<Hint_param_table, true> {
public:

	void init(class Mem_root_array_YY<Hint_param_table, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<Hint_param_table, true> *, MEM_ROOT *);

	class Hint_param_table & at(class Mem_root_array_YY<Hint_param_table, true> *, size_t);

	const class Hint_param_table  & at(const class Mem_root_array_YY<Hint_param_table, true>  *, size_t);

	class Hint_param_table & operator[](class Mem_root_array_YY<Hint_param_table, true> *, size_t);

	const class Hint_param_table  & operator[](const class Mem_root_array_YY<Hint_param_table, true>  *, size_t);

	class Hint_param_table & back(class Mem_root_array_YY<Hint_param_table, true> *);

	const class Hint_param_table  & back(const class Mem_root_array_YY<Hint_param_table, true>  *);

	class Hint_param_table * begin(class Mem_root_array_YY<Hint_param_table, true> *);

	const class Hint_param_table  * begin(const class Mem_root_array_YY<Hint_param_table, true>  *);

	class Hint_param_table * end(class Mem_root_array_YY<Hint_param_table, true> *);

	const class Hint_param_table  * end(const class Mem_root_array_YY<Hint_param_table, true>  *);

	void clear(class Mem_root_array_YY<Hint_param_table, true> *);

	void chop(class Mem_root_array_YY<Hint_param_table, true> *, size_t);

	bool reserve(class Mem_root_array_YY<Hint_param_table, true> *, size_t);

	bool push_back(class Mem_root_array_YY<Hint_param_table, true> *, const class Hint_param_table  &);

	void pop_back(class Mem_root_array_YY<Hint_param_table, true> *);

	void resize(class Mem_root_array_YY<Hint_param_table, true> *, size_t, const value_type  &);

	typedef struct Hint_param_table value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<Hint_param_table, true>  *);

	size_t element_size(const class Mem_root_array_YY<Hint_param_table, true>  *);

	bool empty(const class Mem_root_array_YY<Hint_param_table, true>  *);

	size_t size(const class Mem_root_array_YY<Hint_param_table, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class Hint_param_table *   m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct st_udf_func {
	LEX_STRING                 name;                 /*     0    16 */
	enum Item_result           returns;              /*    16     4 */
	enum Item_udftype          type;                 /*    20     4 */
	char *                     dl;                   /*    24     8 */
	void *                     dlhandle;             /*    32     8 */
	Udf_func_any               func;                 /*    40     8 */
	Udf_func_init              func_init;            /*    48     8 */
	Udf_func_deinit            func_deinit;          /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Udf_func_clear             func_clear;           /*    64     8 */
	Udf_func_add               func_add;             /*    72     8 */
	ulong                      usage_count;          /*    80     8 */

	/* size: 88, cachelines: 2, members: 11 */
	/* last cacheline: 24 bytes */
};
class udf_handler : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
protected:


	udf_func *                 u_d;                  /*     0     8 */
	class String *             buffers;              /*     8     8 */
	UDF_ARGS                   f_args;               /*    16    64 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	UDF_INIT                   initid;               /*    80    40 */
	char *                     num_buffer;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uchar                      error;                /*   128     1 */
	uchar                      is_null;              /*   129     1 */
	bool                       initialized;          /*   130     1 */

	/* XXX 5 bytes hole, try to pack */

	class Item * *             args;                 /*   136     8 */
public:

	table_map                  used_tables_cache;    /*   144     8 */
	bool                       const_item_cache;     /*   152     1 */
	bool                       not_original;         /*   153     1 */
	void udf_handler(class udf_handler *, udf_func *);

	void ~udf_handler(class udf_handler *, int);

	const char  * name(const class udf_handler  *);

	enum Item_result result_type(const class udf_handler  *);

	bool get_arguments(class udf_handler *);

	bool fix_fields(class udf_handler *, class THD *, class Item_result_field *, uint, class Item * *);

	void cleanup(class udf_handler *);

	double val(class udf_handler *, my_bool *);

	longlong val_int(class udf_handler *, my_bool *);

	class my_decimal * val_decimal(class udf_handler *, my_bool *, class my_decimal *);

	void clear(class udf_handler *);

	void add(class udf_handler *, my_bool *);

	class String * val_str(class udf_handler *, class String *, class String *);


	/* size: 160, cachelines: 3, members: 13 */
	/* sum members: 149, holes: 1, sum holes: 5 */
	/* padding: 6 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 32 bytes */
};
struct sys_var_with_base {
	class sys_var *            var;                  /*     0     8 */
	LEX_STRING                 base_name;            /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
union YYSTYPE {
	enum opt_hints_enum        hint_type;          /*     0     4 */
	LEX_CSTRING                hint_string;        /*     0    16 */
	class PT_hint *            hint;               /*     0     8 */
	class PT_hint_list *       hint_list;          /*     0     8 */
	Hint_param_index_list      hint_param_index_list; /*     0    32 */
	struct Hint_param_table    hint_param_table;   /*     0    32 */
	Hint_param_table_list      hint_param_table_list; /*     0    32 */
	int                        num;                /*     0     4 */
	ulong                      ulong_num;          /*     0     8 */
	ulonglong                  ulonglong_number;   /*     0     8 */
	longlong                   longlong_number;    /*     0     8 */
	LEX_STRING                 lex_str;            /*     0    16 */
	LEX_CSTRING                lex_cstr;           /*     0    16 */
	LEX_STRING *               lex_str_ptr;        /*     0     8 */
	struct LEX_SYMBOL          symbol;             /*     0    24 */
	class Table_ident *        table;              /*     0     8 */
	char *                     simple_string;      /*     0     8 */
	class Item *               item;               /*     0     8 */
	class Item_num *           item_num;           /*     0     8 */
	class List<Item> *         item_list;          /*     0     8 */
	class List<String> *       string_list;        /*     0     8 */
	class String *             string;             /*     0     8 */
	class Key_part_spec *      key_part;           /*     0     8 */
	class TABLE_LIST *         table_list;         /*     0     8 */
	udf_func *                 udf;                /*     0     8 */
	LEX_USER *                 lex_user;           /*     0     8 */
	struct sys_var_with_base   variable;           /*     0    24 */
	enum enum_var_type         var_type;           /*     0     4 */
	enum keytype               key_type;           /*     0     4 */
	enum ha_key_alg            key_alg;            /*     0     4 */
	class handlerton *         db_type;            /*     0     8 */
	enum row_type              row_type;           /*     0     4 */
	enum ha_rkey_function      ha_rkey_mode;       /*     0     4 */
	enum enum_ha_read_modes    ha_read_mode;       /*     0     4 */
	enum enum_tx_isolation     tx_isolation;       /*     0     4 */
	const char  *              c_str;              /*     0     8 */
	struct {
		const CHARSET_INFO  * charset;         /*     0     8 */
		ulong              type_flags;         /*     8     8 */
	} charset_with_flags;                          /*     0    16 */
	struct {
		const char  *      length;             /*     0     8 */
		const char  *      dec;                /*     8     8 */
	} precision;                                   /*     0    16 */
	struct Cast_type           cast_type;          /*     0    40 */
	enum Item_udftype          udf_type;           /*     0     4 */
	const CHARSET_INFO  *      charset;            /*     0     8 */
	enum thr_lock_type         lock_type;          /*     0     4 */
	enum interval_type         interval;           /*     0     4 */
	enum interval_type         interval_time_st;   /*     0     4 */
	timestamp_type             date_time_type;     /*     0     4 */
	class st_select_lex *      select_lex;         /*     0     8 */
	chooser_compare_func_creator boolfunc2creator; /*     0     8 */
	class sp_condition_value * spcondvalue;        /*     0     8 */
	struct {
		int                vars;               /*     0     4 */
		int                conds;              /*     4     4 */
		int                hndlrs;             /*     8     4 */
		int                curs;               /*    12     4 */
	} spblock;                                     /*     0    16 */
	class sp_name *            spname;             /*     0     8 */
	class LEX *                lex;                /*     0     8 */
	class sp_head *            sphead;             /*     0     8 */
	class p_elem_val *         p_elem_value;       /*     0     8 */
	enum index_hint_type       index_hint;         /*     0     4 */
	enum enum_filetype         filetype;           /*     0     4 */
	enum fk_option             m_fk_option;        /*     0     4 */
	enum enum_yes_no_unknown   m_yes_no_unk;       /*     0     4 */
	enum enum_condition_item_name da_condition_item_name; /*     0     4 */
	enum Which_area            diag_area;          /*     0     4 */
	class Diagnostics_information * diag_info;     /*     0     8 */
	class Statement_information_item * stmt_info_item; /*     0     8 */
	enum Name                  stmt_info_item_name; /*     0     4 */
	class List<Statement_information_item> * stmt_info_list; /*     0     8 */
	class Condition_information_item * cond_info_item; /*     0     8 */
	enum Name                  cond_info_item_name; /*     0     4 */
	class List<Condition_information_item> * cond_info_list; /*     0     8 */
	bool                       is_not_empty;       /*     0     1 */
	class Set_signal_information * signal_item_list; /*     0     8 */
	enum enum_trigger_order_type trigger_action_order_type; /*     0     4 */
	struct {
		enum enum_trigger_order_type ordering_clause; /*     0     4 */

		/* XXX 4 bytes hole, try to pack */

		LEX_STRING         anchor_trigger_name; /*     8    16 */
	} trg_characteristics;                         /*     0    24 */
	class Index_hint *         key_usage_element;  /*     0     8 */
	class List<Index_hint> *   key_usage_list;     /*     0     8 */
	class PT_subselect *       subselect;          /*     0     8 */
	class PT_item_list *       item_list2;         /*     0     8 */
	class PT_order_expr *      order_expr;         /*     0     8 */
	class PT_order_list *      order_list;         /*     0     8 */
	struct Limit_options       limit_options;      /*     0    24 */
	struct Query_options       select_options;     /*     0    16 */
	class PT_limit_clause *    limit_clause;       /*     0     8 */
	class Parse_tree_node *    node;               /*     0     8 */
	class PT_select_part2_derived * select_part2_derived; /*     0     8 */
	enum olap_type             olap_type;          /*     0     4 */
	class PT_group *           group;              /*     0     8 */
	class PT_order *           order;              /*     0     8 */
	struct Proc_analyse_params procedure_analyse_params; /*     0     8 */
	class PT_procedure_analyse * procedure_analyse; /*     0     8 */
	struct Select_lock_type    select_lock_type;   /*     0    12 */
	class PT_union_order_or_limit * union_order_or_limit; /*     0     8 */
	class PT_table_expression * table_expression;  /*     0     8 */
	class PT_table_list *      table_list2;        /*     0     8 */
	class PT_join_table_list * join_table_list;    /*     0     8 */
	class PT_select_paren_derived * select_paren_derived; /*     0     8 */
	class PT_select_lex *      select_lex2;        /*     0     8 */
	class PT_internal_variable_name * internal_variable_name; /*     0     8 */
	class PT_option_value_following_option_type * option_value_following_option_type; /*     0     8 */
	class PT_option_value_no_option_type * option_value_no_option_type; /*     0     8 */
	class PT_option_value_list_head * option_value_list; /*     0     8 */
	class PT_start_option_value_list * start_option_value_list; /*     0     8 */
	class PT_transaction_access_mode * transaction_access_mode; /*     0     8 */
	class PT_isolation_level * isolation_level;    /*     0     8 */
	class PT_transaction_characteristics * transaction_characteristics; /*     0     8 */
	class PT_start_option_value_list_following_option_type * start_option_value_list_following_option_type; /*     0     8 */
	class PT_set *             set;                /*     0     8 */
	class PT_union_list *      union_list;         /*     0     8 */
	struct Line_separators     line_separators;    /*     0    16 */
	struct Field_separators    field_separators;   /*     0    32 */
	class PT_into_destination * into_destination;  /*     0     8 */
	class PT_select_var *      select_var_ident;   /*     0     8 */
	class PT_select_var_list * select_var_list;    /*     0     8 */
	class PT_select_options_and_item_list * select_options_and_item_list; /*     0     8 */
	class PT_select_part2 *    select_part2;       /*     0     8 */
	class PT_table_reference_list * table_reference_list; /*     0     8 */
	class PT_select_paren *    select_paren;       /*     0     8 */
	class PT_select_init *     select_init;        /*     0     8 */
	class PT_select_init2 *    select_init2;       /*     0     8 */
	class PT_select *          select;             /*     0     8 */
	class Item_param *         param_marker;       /*     0     8 */
	class PTI_text_literal *   text_literal;       /*     0     8 */
	XID *                      xid;                /*     0     8 */
	enum xa_option_words       xa_option_type;     /*     0     4 */
	struct {
		class Item *       column;             /*     0     8 */
		class Item *       value;              /*     8     8 */
	} column_value_pair;                           /*     0    16 */
	struct {
		class PT_item_list * column_list;      /*     0     8 */
		class PT_item_list * value_list;       /*     8     8 */
	} column_value_list_pair;                      /*     0    16 */
	struct {
		class PT_item_list * column_list;      /*     0     8 */
		class PT_insert_values_list * row_value_list; /*     8     8 */
	} column_row_value_list_pair;                  /*     0    16 */
	struct {
		class PT_item_list * column_list;      /*     0     8 */
		class PT_insert_query_expression * insert_query_expression; /*     8     8 */
	} insert_from_subquery;                        /*     0    16 */
	class PT_create_select *   create_select;      /*     0     8 */
	class PT_insert_values_list * values_list;     /*     0     8 */
	class PT_insert_query_expression * insert_query_expression; /*     0     8 */
	class PT_statement *       statement;          /*     0     8 */
	class Table_ident *        table_ident;        /*     0     8 */
	class Mem_root_array_YY<Table_ident*, true> table_ident_list; /*     0    32 */
	enum delete_option_enum    opt_delete_option;  /*     0     4 */
	class PT_hint_list *       optimizer_hints;    /*     0     8 */
	enum alter_instance_action_enum alter_instance_action; /*     0     4 */
};
class Prealloced_array<long unsigned int, 2, true> {
	long unsigned int * cast_rawbuff(class Prealloced_array<long unsigned int, 2, true> *);

public:

	void Prealloced_array(class Prealloced_array<long unsigned int, 2, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<long unsigned int, 2, true> *, const class Prealloced_array<long unsigned int, 2, true>  &);

	void Prealloced_array(class Prealloced_array<long unsigned int, 2, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const long unsigned int  * const_iterator;

	class Prealloced_array<long unsigned int, 2, true> & operator=(class Prealloced_array<long unsigned int, 2, true> *, const class Prealloced_array<long unsigned int, 2, true>  &);

	void ~Prealloced_array(class Prealloced_array<long unsigned int, 2, true> *, int);

	size_t capacity(const class Prealloced_array<long unsigned int, 2, true>  *);

	size_t element_size(const class Prealloced_array<long unsigned int, 2, true>  *);

	bool empty(const class Prealloced_array<long unsigned int, 2, true>  *);

	size_t size(const class Prealloced_array<long unsigned int, 2, true>  *);

	long unsigned int & at(class Prealloced_array<long unsigned int, 2, true> *, size_t);

	const long unsigned int  & at(const class Prealloced_array<long unsigned int, 2, true>  *, size_t);

	long unsigned int & operator[](class Prealloced_array<long unsigned int, 2, true> *, size_t);

	const long unsigned int  & operator[](const class Prealloced_array<long unsigned int, 2, true>  *, size_t);

	long unsigned int & back(class Prealloced_array<long unsigned int, 2, true> *);

	const long unsigned int  & back(const class Prealloced_array<long unsigned int, 2, true>  *);

	long unsigned int & front(class Prealloced_array<long unsigned int, 2, true> *);

	const long unsigned int  & front(const class Prealloced_array<long unsigned int, 2, true>  *);

	typedef long unsigned int * iterator;

	iterator begin(class Prealloced_array<long unsigned int, 2, true> *);

	iterator end(class Prealloced_array<long unsigned int, 2, true> *);

	const_iterator begin(const class Prealloced_array<long unsigned int, 2, true>  *);

	const_iterator end(const class Prealloced_array<long unsigned int, 2, true>  *);

	bool reserve(class Prealloced_array<long unsigned int, 2, true> *, size_t);

	bool push_back(class Prealloced_array<long unsigned int, 2, true> *, const long unsigned int  &);

	void pop_back(class Prealloced_array<long unsigned int, 2, true> *);

	iterator insert(class Prealloced_array<long unsigned int, 2, true> *, iterator, const value_type  &);

	typedef long unsigned int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<long unsigned int*, bool> insert_unique(class Prealloced_array<long unsigned int, 2, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<long unsigned int, 2, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<long unsigned int, 2, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<long unsigned int, 2, true> *, iterator);

	iterator erase(class Prealloced_array<long unsigned int, 2, true> *, size_t);

	void erase_at_end(class Prealloced_array<long unsigned int, 2, true> *, iterator);

	iterator erase(class Prealloced_array<long unsigned int, 2, true> *, iterator, iterator);

	void swap(class Prealloced_array<long unsigned int, 2, true> *, class Prealloced_array<long unsigned int, 2, true> &);

	void shrink_to_fit(class Prealloced_array<long unsigned int, 2, true> *);

	void resize(class Prealloced_array<long unsigned int, 2, true> *, size_t, const long unsigned int  &);

	void clear(class Prealloced_array<long unsigned int, 2, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<16, 8> m_buff __attribute__((__aligned__(8))); /*    16    16 */
	long unsigned int *        m_array_ptr;          /*    32     8 */
	PSI_memory_key             m_psi_key;            /*    40     4 */

	/* size: 48, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
class Index_hint : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	enum index_hint_type       type;                 /*     0     4 */
	index_clause_map           clause;               /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	LEX_STRING                 key_name;             /*     8    16 */
	void Index_hint(class Index_hint *, const char  *, uint);

	void print(class Index_hint *, class THD *, class String *);


	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
class Query_result : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	void Query_result(class Query_result *, const class Query_result  &);


	int ()(void) * *           _vptr.Query_result;   /*     0     8 */
protected:

	class THD *                thd;                  /*     8     8 */
	SELECT_LEX_UNIT *          unit;                 /*    16     8 */
public:

	ha_rows                    estimated_rowcount;   /*    24     8 */
	void Query_result(class Query_result *);

	virtual void ~Query_result(class Query_result *, int);

	virtual bool change_query_result(class Query_result *, class Query_result *);

	virtual bool need_explain_interceptor(const class Query_result  *);

	virtual int prepare(class Query_result *, class List<Item> &, SELECT_LEX_UNIT *);

	virtual int prepare2(class Query_result *);

	virtual uint field_count(const class Query_result  *, class List<Item> &);

	virtual bool send_result_set_metadata(class Query_result *, class List<Item> &, uint);

	virtual bool send_data(class Query_result *, class List<Item> &);

	virtual bool initialize_tables(class Query_result *, class JOIN *);

	virtual void send_error(class Query_result *, uint, const char  *);

	virtual bool send_eof(class Query_result *);

	virtual bool check_simple_select(const class Query_result  *);

	virtual void abort_result_set(class Query_result *);

	virtual void cleanup(class Query_result *);

	void set_thd(class Query_result *, class THD *);

	void reset_offset_limit_cnt(class Query_result *);

	void begin_dataset(class Query_result *);

	/* vtable has 13 entries: {
	   [2] = change_query_result((null)), 
	   [3] = need_explain_interceptor((null)), 
	   [4] = prepare((null)), 
	   [5] = prepare2((null)), 
	   [6] = field_count((null)), 
	   [7] = send_result_set_metadata((null)), 
	   [8] = send_data((null)), 
	   [9] = initialize_tables((null)), 
	   [10] = send_error((null)), 
	   [11] = send_eof((null)), 
	   [12] = check_simple_select((null)), 
	   [13] = abort_result_set((null)), 
	   [14] = cleanup((null)), 
	} */
	/* size: 32, cachelines: 1, members: 5 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 32 bytes */
};
class Query_result_interceptor : public Query_result {
public:

	/* class Query_result        <ancestor>; */      /*     0    32 */
	void Query_result_interceptor(class Query_result_interceptor *, const class Query_result_interceptor  &);

	void Query_result_interceptor(class Query_result_interceptor *);

	virtual uint field_count(const class Query_result_interceptor  *, class List<Item> &);

	virtual bool send_result_set_metadata(class Query_result_interceptor *, class List<Item> &, uint);

	virtual void ~Query_result_interceptor(class Query_result_interceptor *, int);

	/* vtable has 2 entries: {
	   [6] = field_count((null)), 
	   [7] = send_result_set_metadata((null)), 
	} */
	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
struct Cast_type {
	enum Cast_target           target;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const CHARSET_INFO  *      charset;              /*     8     8 */
	ulong                      type_flags;           /*    16     8 */
	const char  *              length;               /*    24     8 */
	const char  *              dec;                  /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct Limit_options {
	class Item *               limit;                /*     0     8 */
	class Item *               opt_offset;           /*     8     8 */
	bool                       is_offset_first;      /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct Query_options {
	ulonglong                  query_spec_options;   /*     0     8 */
	enum e_sql_cache           sql_cache;            /*     8     4 */
	bool merge(class Query_options *, const class Query_options  &, const class Query_options  &);

	bool save_to(class Query_options *, class Parse_context *);


	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct Proc_analyse_params {
	uint                       max_tree_elements;    /*     0     4 */
	uint                       max_treemem;          /*     4     4 */

	/* Bitfield combined with previous fields */

	static const uint                 default_max_tree_elements = 256; /*     0     0 */
	static const uint                 default_max_treemem = 8192; /*     0     0 */

	/* size: 8, cachelines: 1, members: 2, static members: 2 */
	/* last cacheline: 8 bytes */
};
struct Select_lock_type {
	bool                       is_set;               /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	enum thr_lock_type         lock_type;            /*     4     4 */
	bool                       is_safe_to_cache_query; /*     8     1 */

	/* size: 12, cachelines: 1, members: 3 */
	/* sum members: 6, holes: 1, sum holes: 3 */
	/* padding: 3 */
	/* last cacheline: 12 bytes */
};
struct Line_separators {
	const class String  *      line_term;            /*     0     8 */
	const class String  *      line_start;           /*     8     8 */
	void cleanup(class Line_separators *);

	void merge_line_separators(class Line_separators *, const class Line_separators  &);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Field_separators {
	const class String  *      field_term;           /*     0     8 */
	const class String  *      escaped;              /*     8     8 */
	const class String  *      enclosed;             /*    16     8 */
	bool                       opt_enclosed;         /*    24     1 */
	void cleanup(class Field_separators *);

	void merge_field_separators(class Field_separators *, const class Field_separators  &);


	/* size: 32, cachelines: 1, members: 4 */
	/* padding: 7 */
	/* last cacheline: 32 bytes */
};
class Mem_root_array_YY<Table_ident*, true> {
public:

	void init(class Mem_root_array_YY<Table_ident*, true> *, MEM_ROOT *);

	void set_mem_root(class Mem_root_array_YY<Table_ident*, true> *, MEM_ROOT *);

	class Table_ident * & at(class Mem_root_array_YY<Table_ident*, true> *, size_t);

	class Table_ident * const & at(const class Mem_root_array_YY<Table_ident*, true>  *, size_t);

	class Table_ident * & operator[](class Mem_root_array_YY<Table_ident*, true> *, size_t);

	class Table_ident * const & operator[](const class Mem_root_array_YY<Table_ident*, true>  *, size_t);

	class Table_ident * & back(class Mem_root_array_YY<Table_ident*, true> *);

	class Table_ident * const & back(const class Mem_root_array_YY<Table_ident*, true>  *);

	class Table_ident * * begin(class Mem_root_array_YY<Table_ident*, true> *);

	class Table_ident * const * begin(const class Mem_root_array_YY<Table_ident*, true>  *);

	class Table_ident * * end(class Mem_root_array_YY<Table_ident*, true> *);

	class Table_ident * const * end(const class Mem_root_array_YY<Table_ident*, true>  *);

	void clear(class Mem_root_array_YY<Table_ident*, true> *);

	void chop(class Mem_root_array_YY<Table_ident*, true> *, size_t);

	bool reserve(class Mem_root_array_YY<Table_ident*, true> *, size_t);

	bool push_back(class Mem_root_array_YY<Table_ident*, true> *, class Table_ident * const &);

	void pop_back(class Mem_root_array_YY<Table_ident*, true> *);

	void resize(class Mem_root_array_YY<Table_ident*, true> *, size_t, const value_type  &);

	typedef class Table_ident * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	size_t capacity(const class Mem_root_array_YY<Table_ident*, true>  *);

	size_t element_size(const class Mem_root_array_YY<Table_ident*, true>  *);

	bool empty(const class Mem_root_array_YY<Table_ident*, true>  *);

	size_t size(const class Mem_root_array_YY<Table_ident*, true>  *);

	MEM_ROOT *                 m_root;               /*     0     8 */
	class Table_ident * *      m_array;              /*     8     8 */
	size_t                     m_size;               /*    16     8 */
	size_t                     m_capacity;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
class Table_ident : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	LEX_CSTRING                db;                   /*     0    16 */
	LEX_CSTRING                table;                /*    16    16 */
	SELECT_LEX_UNIT *          sel;                  /*    32     8 */
	void Table_ident(class Table_ident *, class THD *, const LEX_CSTRING  &, const LEX_CSTRING  &, bool);

	void Table_ident(class Table_ident *, const LEX_CSTRING  &, const LEX_CSTRING  &);

	void Table_ident(class Table_ident *, const LEX_CSTRING  &);

	void Table_ident(class Table_ident *, SELECT_LEX_UNIT *);

	bool is_derived_table(const class Table_ident  *);

	void change_db(class Table_ident *, const char  *);


	/* size: 40, cachelines: 1, members: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 40 bytes */
};
class Key_part_spec : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	LEX_STRING                 field_name;           /*     0    16 */
	uint                       length;               /*    16     4 */
	void Key_part_spec(class Key_part_spec *, const LEX_STRING  &, uint);

	void Key_part_spec(class Key_part_spec *, const char  *, size_t, uint);

	bool operator==(const class Key_part_spec  *, const class Key_part_spec  &);

	class Key_part_spec * clone(const class Key_part_spec  *, MEM_ROOT *);


	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
class sp_name : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	LEX_CSTRING                m_db;                 /*     0    16 */
	LEX_STRING                 m_name;               /*    16    16 */
	LEX_STRING                 m_qname;              /*    32    16 */
	bool                       m_explicit_name;      /*    48     1 */
	void sp_name(class sp_name *, const LEX_CSTRING  &, const LEX_STRING  &, bool);

	void sp_name(class sp_name *, const MDL_key  *, char *);

	void init_qname(class sp_name *, class THD *);


	/* size: 56, cachelines: 1, members: 5 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 56 bytes */
};
class PT_subselect : public PT_select_lex {
public:

	/* class PT_select_lex       <ancestor>; */      /*     0    16 */
	POS                        pos;                  /*    16    32 */
	class PT_select_lex *      query_expression_body; /*    48     8 */
	void PT_subselect(class PT_subselect *, const POS  &, class PT_select_lex *);

	virtual bool contextualize(class PT_subselect *, class Parse_context *);

	virtual void ~PT_subselect(class PT_subselect *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 56, cachelines: 1, members: 3 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 56 bytes != 40 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class PT_order_expr : public Parse_tree_node, public st_order {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	/* struct st_order            <ancestor>; */     /*     8    72 */

	/* XXX last struct has 7 bytes of padding */
	void PT_order_expr(class PT_order_expr *, class Item *, bool);

	virtual bool contextualize(class PT_order_expr *, class Parse_context *);

	virtual void ~PT_order_expr(class PT_order_expr *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 80, cachelines: 2, members: 2 */
	/* paddings: 1, sum paddings: 7 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 80 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 640 bits */
};
class PT_limit_clause : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	struct Limit_options       limit_options;        /*     8    24 */

	/* XXX last struct has 7 bytes of padding */
	void PT_limit_clause(class PT_limit_clause *, const class Limit_options  &);

	virtual bool contextualize(class PT_limit_clause *, class Parse_context *);

	virtual void ~PT_limit_clause(class PT_limit_clause *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 32, cachelines: 1, members: 2 */
	/* paddings: 1, sum paddings: 7 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 24 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class Parse_tree_node {
public:

	int ()(void) * *           _vptr.Parse_tree_node; /*     0     8 */
	void Parse_tree_node(class Parse_tree_node *, const class Parse_tree_node  &);

	void operator=(class Parse_tree_node *, const class Parse_tree_node  &);

	void * operator new(size_t, MEM_ROOT *);

	void operator delete(void *, size_t);

	void operator delete(void *, MEM_ROOT *);

protected:

	void Parse_tree_node(class Parse_tree_node *);

public:

	virtual void ~Parse_tree_node(class Parse_tree_node *, int);

	virtual bool contextualize(class Parse_tree_node *, class Parse_context *);

	virtual bool contextualize_(class Parse_tree_node *, class Parse_context *);

	void error(const class Parse_tree_node  *, class Parse_context *, const POS  &, const char  *);

	/* vtable has 2 entries: {
	   [2] = contextualize((null)), 
	   [3] = contextualize_((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class PT_select_part2_derived : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	ulonglong                  opt_query_spec_options; /*     8     8 */
	class PT_item_list *       select_item_list;     /*    16     8 */
	void PT_select_part2_derived(class PT_select_part2_derived *, ulonglong, class PT_item_list *);

	virtual bool contextualize(class PT_select_part2_derived *, class Parse_context *);

	virtual void ~PT_select_part2_derived(class PT_select_part2_derived *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 16 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_procedure_analyse : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	struct Proc_analyse_params params;               /*     8     8 */
	void PT_procedure_analyse(class PT_procedure_analyse *, const class Proc_analyse_params  &);

	virtual bool contextualize(class PT_procedure_analyse *, class Parse_context *);

	virtual void ~PT_procedure_analyse(class PT_procedure_analyse *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_union_order_or_limit : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class Parse_tree_node *    order_or_limit;       /*     8     8 */
	void PT_union_order_or_limit(class PT_union_order_or_limit *, class Parse_tree_node *);

	virtual bool contextualize(class PT_union_order_or_limit *, class Parse_context *);

	virtual void ~PT_union_order_or_limit(class PT_union_order_or_limit *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_table_expression : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class Parse_tree_node *    opt_from_clause;      /*     8     8 */
	class Item *               opt_where;            /*    16     8 */
	class PT_group *           opt_group;            /*    24     8 */
	class Item *               opt_having;           /*    32     8 */
	class PT_order *           opt_order;            /*    40     8 */
	class PT_limit_clause *    opt_limit;            /*    48     8 */
	class PT_procedure_analyse * opt_procedure_analyse; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct Select_lock_type    opt_select_lock_type; /*    64    12 */

	/* XXX last struct has 3 bytes of padding */
	void PT_table_expression(class PT_table_expression *, class Parse_tree_node *, class Item *, class PT_group *, class Item *, class PT_order *, class PT_limit_clause *, class PT_procedure_analyse *, const class Select_lock_type  &);

	virtual bool contextualize(class PT_table_expression *, class Parse_context *);

	virtual void ~PT_table_expression(class PT_table_expression *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 80, cachelines: 2, members: 9 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 3 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 80 bytes != 68 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_table_list : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_table_list(class PT_table_list *, const class PT_table_list  &);

	void PT_table_list(class PT_table_list *);

	class TABLE_LIST *         value;                /*     8     8 */
	virtual void ~PT_table_list(class PT_table_list *, int);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_join_table_list : public PT_table_list {
public:

	/* class PT_table_list       <ancestor>; */      /*     0    16 */
	POS                        pos;                  /*    16    32 */
	class PT_table_list *      derived_table_list;   /*    48     8 */
	void PT_join_table_list(class PT_join_table_list *, const POS  &, class PT_table_list *);

	virtual bool contextualize(class PT_join_table_list *, class Parse_context *);

	virtual void ~PT_join_table_list(class PT_join_table_list *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 56, cachelines: 1, members: 3 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 56 bytes != 40 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class PT_select_paren_derived : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class PT_hint_list *       opt_hint_list;        /*     8     8 */
	class PT_select_part2_derived * select_part2_derived; /*    16     8 */
	class PT_table_expression * table_expression;    /*    24     8 */
	void PT_select_paren_derived(class PT_select_paren_derived *, class PT_hint_list *, class PT_select_part2_derived *, class PT_table_expression *);

	virtual bool contextualize(class PT_select_paren_derived *, class Parse_context *);

	virtual void ~PT_select_paren_derived(class PT_select_paren_derived *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 24 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select_lex : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_select_lex(class PT_select_lex *, const class PT_select_lex  &);

	void PT_select_lex(class PT_select_lex *);

	SELECT_LEX *               value;                /*     8     8 */
	virtual void ~PT_select_lex(class PT_select_lex *, int);


	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_internal_variable_name : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_internal_variable_name(class PT_internal_variable_name *, const class PT_internal_variable_name  &);

	void PT_internal_variable_name(class PT_internal_variable_name *);

	struct sys_var_with_base   value;                /*     8    24 */
	virtual void ~PT_internal_variable_name(class PT_internal_variable_name *, int);


	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 24 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_option_value_following_option_type : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	POS                        pos;                  /*     8    32 */
	class PT_internal_variable_name * name;          /*    40     8 */
	class Item *               opt_expr;             /*    48     8 */
	void PT_option_value_following_option_type(class PT_option_value_following_option_type *, const POS  &, class PT_internal_variable_name *, class Item *);

	virtual bool contextualize(class PT_option_value_following_option_type *, class Parse_context *);

	virtual void ~PT_option_value_following_option_type(class PT_option_value_following_option_type *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 56, cachelines: 1, members: 4 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 56 bytes != 48 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_option_value_no_option_type : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_option_value_no_option_type(class PT_option_value_no_option_type *, const class PT_option_value_no_option_type  &);

	void PT_option_value_no_option_type(class PT_option_value_no_option_type *);

	virtual void ~PT_option_value_no_option_type(class PT_option_value_no_option_type *, int);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */

	/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_option_value_list_head : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_option_value_list_head(class PT_option_value_list_head *, const class PT_option_value_list_head  &);

	POS                        delimiter_pos;        /*     8    32 */
	class Parse_tree_node *    value;                /*    40     8 */
	POS                        value_pos;            /*    48    32 */
	void PT_option_value_list_head(class PT_option_value_list_head *, const POS  &, class Parse_tree_node *, const POS  &);

	virtual bool contextualize(class PT_option_value_list_head *, class Parse_context *);

	virtual void ~PT_option_value_list_head(class PT_option_value_list_head *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 80, cachelines: 2, members: 4 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 80 bytes != 72 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_start_option_value_list : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_start_option_value_list(class PT_start_option_value_list *, const class PT_start_option_value_list  &);

	void PT_start_option_value_list(class PT_start_option_value_list *);

	virtual void ~PT_start_option_value_list(class PT_start_option_value_list *, int);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */

	/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_transaction_access_mode : public PT_transaction_characteristic {
public:

	/* class PT_transaction_characteristic <ancestor>; */ /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void PT_transaction_access_mode(class PT_transaction_access_mode *, bool);

	virtual void ~PT_transaction_access_mode(class PT_transaction_access_mode *, int);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class PT_isolation_level : public PT_transaction_characteristic {
public:

	/* class PT_transaction_characteristic <ancestor>; */ /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void PT_isolation_level(class PT_isolation_level *, enum enum_tx_isolation);

	virtual void ~PT_isolation_level(class PT_isolation_level *, int);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class PT_transaction_characteristics : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class PT_transaction_characteristic * head;      /*     8     8 */
	class PT_transaction_characteristic * opt_tail;  /*    16     8 */
	void PT_transaction_characteristics(class PT_transaction_characteristics *, class PT_transaction_characteristic *, class PT_transaction_characteristic *);

	virtual bool contextualize(class PT_transaction_characteristics *, class Parse_context *);

	virtual void ~PT_transaction_characteristics(class PT_transaction_characteristics *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 16 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_start_option_value_list_following_option_type : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_start_option_value_list_following_option_type(class PT_start_option_value_list_following_option_type *, const class PT_start_option_value_list_following_option_type  &);

	void PT_start_option_value_list_following_option_type(class PT_start_option_value_list_following_option_type *);

	virtual void ~PT_start_option_value_list_following_option_type(class PT_start_option_value_list_following_option_type *, int);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */

	/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_set : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	POS                        set_pos;              /*     8    32 */
	POS                        set_statement_end_pos; /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	class PT_start_option_value_list * list;         /*    72     8 */
	bool                       is_set_statement;     /*    80     1 */
	void PT_set(class PT_set *, const POS  &, const POS  &, class PT_start_option_value_list *, bool);

	virtual bool contextualize(class PT_set *, class Parse_context *);

	virtual void ~PT_set(class PT_set *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 88, cachelines: 2, members: 5 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 88 bytes != 73 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_union_list : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	bool                       is_distinct;          /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	class PT_select_init *     select_init;          /*    16     8 */
	void PT_union_list(class PT_union_list *, bool, class PT_select_init *);

	virtual bool contextualize(class PT_union_list *, class Parse_context *);

	virtual void ~PT_union_list(class PT_union_list *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 9 (member bytes) + 0 (member bits) + 7 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_into_destination : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_into_destination(class PT_into_destination *, const class PT_into_destination  &);

	void PT_into_destination(class PT_into_destination *);

	virtual bool contextualize(class PT_into_destination *, class Parse_context *);

	virtual void ~PT_into_destination(class PT_into_destination *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */

	/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select_var : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_select_var(class PT_select_var *, const class PT_select_var  &);

	const LEX_STRING           name;                 /*     8    16 */
	void PT_select_var(class PT_select_var *, const LEX_STRING  &);

	virtual bool is_local(const class PT_select_var  *);

	virtual uint get_offset(const class PT_select_var  *);

	virtual void ~PT_select_var(class PT_select_var *, int);

	/* vtable has 2 entries: {
	   [4] = is_local((null)), 
	   [5] = get_offset((null)), 
	} */
	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 16 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select_options_and_item_list : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	struct Query_options       options;              /*     8    16 */

	/* XXX last struct has 4 bytes of padding */

	class PT_item_list *       item_list;            /*    24     8 */
	void PT_select_options_and_item_list(class PT_select_options_and_item_list *, const class Query_options  &, class PT_item_list *);

	virtual bool contextualize(class PT_select_options_and_item_list *, class Parse_context *);

	virtual void ~PT_select_options_and_item_list(class PT_select_options_and_item_list *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 32, cachelines: 1, members: 3 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 24 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select_part2 : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class PT_select_options_and_item_list * select_options_and_item_list; /*     8     8 */
	class PT_into_destination * opt_into1;           /*    16     8 */
	class PT_table_reference_list * from_clause;     /*    24     8 */
	class Item *               opt_where_clause;     /*    32     8 */
	class PT_group *           opt_group_clause;     /*    40     8 */
	class Item *               opt_having_clause;    /*    48     8 */
	class PT_order *           opt_order_clause;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class PT_limit_clause *    opt_limit_clause;     /*    64     8 */
	class PT_procedure_analyse * opt_procedure_analyse_clause; /*    72     8 */
	class PT_into_destination * opt_into2;           /*    80     8 */
	struct Select_lock_type    opt_select_lock_type; /*    88    12 */

	/* XXX last struct has 3 bytes of padding */
	void PT_select_part2(class PT_select_part2 *, class PT_select_options_and_item_list *, class PT_into_destination *, class PT_table_reference_list *, class Item *, class PT_group *, class Item *, class PT_order *, class PT_limit_clause *, class PT_procedure_analyse *, class PT_into_destination *, const class Select_lock_type  &);

	void PT_select_part2(class PT_select_part2 *, class PT_select_options_and_item_list *);

	virtual bool contextualize(class PT_select_part2 *, class Parse_context *);

	virtual void ~PT_select_part2(class PT_select_part2 *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 104, cachelines: 2, members: 12 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 3 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 104 bytes != 92 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_table_reference_list : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class PT_join_table_list * join_table_list;      /*     8     8 */
	void PT_table_reference_list(class PT_table_reference_list *, class PT_join_table_list *);

	virtual bool contextualize(class PT_table_reference_list *, class Parse_context *);

	virtual void ~PT_table_reference_list(class PT_table_reference_list *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select_paren : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class PT_hint_list *       opt_hint_list;        /*     8     8 */
	class PT_select_part2 *    select_part2;         /*    16     8 */
	void PT_select_paren(class PT_select_paren *, class PT_hint_list *, class PT_select_part2 *);

	virtual bool contextualize(class PT_select_paren *, class Parse_context *);

	virtual void ~PT_select_paren(class PT_select_paren *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 16 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select_init : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_select_init(class PT_select_init *, const class PT_select_init  &);

	void PT_select_init(class PT_select_init *);

	virtual void ~PT_select_init(class PT_select_init *, int);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */

	/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select_init2 : public PT_select_init {
public:

	/* class PT_select_init      <ancestor>; */      /*     0     8 */
	class PT_hint_list *       opt_hint_list;        /*     8     8 */
	class PT_select_part2 *    select_part2;         /*    16     8 */
	class PT_union_list *      opt_union_clause;     /*    24     8 */
	void PT_select_init2(class PT_select_init2 *, class PT_hint_list *, class PT_select_part2 *, class PT_union_list *);

	virtual bool contextualize(class PT_select_init2 *, class Parse_context *);

	virtual void ~PT_select_init2(class PT_select_init2 *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 24 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_select : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	class PT_select_init *     select_init;          /*     8     8 */
	enum enum_sql_command      sql_command;          /*    16     4 */
	void PT_select(class PT_select *, class PT_select_init *, enum enum_sql_command);

	virtual bool contextualize(class PT_select *, class Parse_context *);

	virtual void ~PT_select(class PT_select *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 12 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class PT_statement : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_statement(class PT_statement *, const class PT_statement  &);

	void PT_statement(class PT_statement *);

	virtual class Sql_cmd * make_cmd(class PT_statement *, class THD *);

	virtual void ~PT_statement(class PT_statement *, int);

	/* vtable has 1 entries: {
	   [4] = make_cmd((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */

	/* BRAIN FART ALERT! 8 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class Query_tables_list {
	enum enum_lock_tables_state {
		LTS_NOT_LOCKED = 0,
		LTS_LOCKED     = 1,
	};

	enum enum_binlog_stmt_unsafe {
		BINLOG_STMT_UNSAFE_LIMIT                                    = 0,
		BINLOG_STMT_UNSAFE_SYSTEM_TABLE                             = 1,
		BINLOG_STMT_UNSAFE_AUTOINC_COLUMNS                          = 2,
		BINLOG_STMT_UNSAFE_UDF                                      = 3,
		BINLOG_STMT_UNSAFE_SYSTEM_VARIABLE                          = 4,
		BINLOG_STMT_UNSAFE_SYSTEM_FUNCTION                          = 5,
		BINLOG_STMT_UNSAFE_NONTRANS_AFTER_TRANS                     = 6,
		BINLOG_STMT_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 7,
		BINLOG_STMT_UNSAFE_MIXED_STATEMENT                          = 8,
		BINLOG_STMT_UNSAFE_INSERT_IGNORE_SELECT                     = 9,
		BINLOG_STMT_UNSAFE_INSERT_SELECT_UPDATE                     = 10,
		BINLOG_STMT_UNSAFE_WRITE_AUTOINC_SELECT                     = 11,
		BINLOG_STMT_UNSAFE_REPLACE_SELECT                           = 12,
		BINLOG_STMT_UNSAFE_CREATE_IGNORE_SELECT                     = 13,
		BINLOG_STMT_UNSAFE_CREATE_REPLACE_SELECT                    = 14,
		BINLOG_STMT_UNSAFE_CREATE_SELECT_AUTOINC                    = 15,
		BINLOG_STMT_UNSAFE_UPDATE_IGNORE                            = 16,
		BINLOG_STMT_UNSAFE_INSERT_TWO_KEYS                          = 17,
		BINLOG_STMT_UNSAFE_AUTOINC_NOT_FIRST                        = 18,
		BINLOG_STMT_UNSAFE_FULLTEXT_PLUGIN                          = 19,
		BINLOG_STMT_UNSAFE_XA                                       = 20,
		BINLOG_STMT_UNSAFE_COUNT                                    = 21,
	};

	enum enum_stmt_accessed_table {
		STMT_READS_TRANS_TABLE           = 0,
		STMT_READS_NON_TRANS_TABLE       = 1,
		STMT_READS_TEMP_TRANS_TABLE      = 2,
		STMT_READS_TEMP_NON_TRANS_TABLE  = 3,
		STMT_WRITES_TRANS_TABLE          = 4,
		STMT_WRITES_NON_TRANS_TABLE      = 5,
		STMT_WRITES_TEMP_TRANS_TABLE     = 6,
		STMT_WRITES_TEMP_NON_TRANS_TABLE = 7,
		STMT_ACCESS_TABLE_COUNT          = 8,
	};

public:

	enum enum_sql_command      sql_command;          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class TABLE_LIST *         query_tables;         /*     8     8 */
	class TABLE_LIST * *       query_tables_last;    /*    16     8 */
	class TABLE_LIST * *       query_tables_own_last; /*    24     8 */
	HASH                       sroutines;            /*    32   112 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class SQL_I_List<Sroutine_hash_entry> sroutines_list; /*   144    24 */
	class Sroutine_hash_entry * * sroutines_list_own_last; /*   168     8 */
	uint                       sroutines_list_own_elements; /*   176     4 */
	enum enum_lock_tables_state lock_tables_state;   /*   180     4 */
	bool is_query_tables_locked(class Query_tables_list *);

	uint                       table_count;          /*   184     4 */
	void Query_tables_list(class Query_tables_list *);

	void ~Query_tables_list(class Query_tables_list *, int);

	void reset_query_tables_list(class Query_tables_list *, bool);

	void destroy_query_tables_list(class Query_tables_list *);

	void set_query_tables_list(class Query_tables_list *, class Query_tables_list *);

	void add_to_query_tables(class Query_tables_list *, class TABLE_LIST *);

	bool requires_prelocking(class Query_tables_list *);

	void mark_as_requiring_prelocking(class Query_tables_list *, class TABLE_LIST * *);

	class TABLE_LIST * first_not_own_table(class Query_tables_list *);

	void chop_off_not_own_tables(class Query_tables_list *);

	class TABLE_LIST * last_table(class Query_tables_list *);


	/* Bitfield combined with previous fields */

	static const int                  BINLOG_STMT_UNSAFE_ALL_FLAGS = 2097151; /*     0     0 */
	static const const int            binlog_stmt_unsafe_errcode[21]; /*     0     0 */
	bool is_stmt_unsafe(const class Query_tables_list  *, enum enum_binlog_stmt_unsafe);

	bool is_stmt_unsafe(const class Query_tables_list  *);

	bool is_stmt_unsafe(class Query_tables_list *, enum enum_binlog_stmt_unsafe);

	void set_stmt_unsafe(class Query_tables_list *, enum enum_binlog_stmt_unsafe);

	void set_stmt_unsafe_flags(class Query_tables_list *, uint32);

	uint32 get_stmt_unsafe_flags(const class Query_tables_list  *);

	void clear_stmt_unsafe(class Query_tables_list *);

	bool is_stmt_row_injection(const class Query_tables_list  *);

	void set_stmt_row_injection(class Query_tables_list *);

	void set_stmt_accessed_table(class Query_tables_list *, enum enum_stmt_accessed_table);

	bool stmt_accessed_table(class Query_tables_list *, enum enum_stmt_accessed_table);

	bool is_mixed_stmt_unsafe(class Query_tables_list *, bool, bool, bool, uint);

	bool uses_stored_routines(const class Query_tables_list  *);

	void set_using_match(class Query_tables_list *);

	bool get_using_match(class Query_tables_list *);

	uint32                     binlog_stmt_flags;    /*   188     4 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	uint32                     stmt_accessed_table_flag; /*   192     4 */
	bool                       using_match;          /*   196     1 */

	/* size: 200, cachelines: 4, members: 13, static members: 2 */
	/* sum members: 193, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
class SQL_I_List<Sroutine_hash_entry> : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	uint                       elements;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class Sroutine_hash_entry * first;               /*     8     8 */
	class Sroutine_hash_entry * * next;              /*    16     8 */
	void SQL_I_List(class SQL_I_List<Sroutine_hash_entry> *);

	void SQL_I_List(class SQL_I_List<Sroutine_hash_entry> *, const class SQL_I_List<Sroutine_hash_entry>  &);

	class SQL_I_List<Sroutine_hash_entry> & operator=(class SQL_I_List<Sroutine_hash_entry> *, const class SQL_I_List<Sroutine_hash_entry>  &);

	void empty(class SQL_I_List<Sroutine_hash_entry> *);

	void link_in_list(class SQL_I_List<Sroutine_hash_entry> *, class Sroutine_hash_entry *, class Sroutine_hash_entry * *);

	void save_and_clear(class SQL_I_List<Sroutine_hash_entry> *, class SQL_I_List<Sroutine_hash_entry> *);

	void push_front(class SQL_I_List<Sroutine_hash_entry> *, class SQL_I_List<Sroutine_hash_entry> *);

	void push_back(class SQL_I_List<Sroutine_hash_entry> *, class SQL_I_List<Sroutine_hash_entry> *);


	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 24 bytes */
};
class Lex_input_stream {
public:

	bool init(class Lex_input_stream *, class THD *, const char  *, size_t);

	void reset(class Lex_input_stream *, const char  *, size_t);

	void set_echo(class Lex_input_stream *, bool);

	void save_in_comment_state(class Lex_input_stream *);

	void restore_in_comment_state(class Lex_input_stream *);

	void skip_binary(class Lex_input_stream *, int);

	unsigned char yyGet(class Lex_input_stream *);

	unsigned char yyGetLast(class Lex_input_stream *);

	unsigned char yyPeek(class Lex_input_stream *);

	unsigned char yyPeekn(class Lex_input_stream *, int);

	void yyUnget(class Lex_input_stream *);

	void yySkip(class Lex_input_stream *);

	void yySkipn(class Lex_input_stream *, int);

	char * yyUnput(class Lex_input_stream *, char);

	char * cpp_inject(class Lex_input_stream *, char);

	bool eof(class Lex_input_stream *);

	bool eof(class Lex_input_stream *, int);

	const char  * get_buf(class Lex_input_stream *);

	const char  * get_cpp_buf(class Lex_input_stream *);

	const char  * get_end_of_query(class Lex_input_stream *);

	void start_token(class Lex_input_stream *);

	void restart_token(class Lex_input_stream *);

	const char  * get_tok_start(class Lex_input_stream *);

	const char  * get_cpp_tok_start(class Lex_input_stream *);

	const char  * get_tok_end(class Lex_input_stream *);

	const char  * get_cpp_tok_end(class Lex_input_stream *);

	const char  * get_ptr(class Lex_input_stream *);

	const char  * get_cpp_ptr(class Lex_input_stream *);

	uint yyLength(class Lex_input_stream *);

	const char  * get_body_utf8_str(class Lex_input_stream *);

	uint get_body_utf8_length(class Lex_input_stream *);

	void body_utf8_start(class Lex_input_stream *, class THD *, const char  *);

	void body_utf8_append(class Lex_input_stream *, const char  *);

	void body_utf8_append(class Lex_input_stream *, const char  *, const char  *);

	void body_utf8_append_literal(class Lex_input_stream *, class THD *, const LEX_STRING  *, const CHARSET_INFO  *, const char  *);

	uint get_lineno(class Lex_input_stream *, const char  *);

	class THD *                m_thd;                /*     0     8 */
	uint                       yylineno;             /*     8     4 */
	uint                       yytoklen;             /*    12     4 */
	LEX_YYSTYPE                yylval;               /*    16     8 */
	int                        lookahead_token;      /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	LEX_YYSTYPE                lookahead_yylval;     /*    32     8 */
	bool                       skip_digest;          /*    40     1 */

	/* XXX 7 bytes hole, try to pack */
	void add_digest_token(class Lex_input_stream *, uint, LEX_YYSTYPE);

	void reduce_digest_token(class Lex_input_stream *, uint, uint);


	const CHARSET_INFO  *      query_charset;        /*    48     8 */
	char *                     m_ptr;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	const char  *              m_tok_start;          /*    64     8 */
	const char  *              m_tok_end;            /*    72     8 */
	const char  *              m_end_of_query;       /*    80     8 */
	const char  *              m_buf;                /*    88     8 */
	size_t                     m_buf_length;         /*    96     8 */
	bool                       m_echo;               /*   104     1 */
	bool                       m_echo_saved;         /*   105     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     m_cpp_buf;            /*   112     8 */
	char *                     m_cpp_ptr;            /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	const char  *              m_cpp_tok_start;      /*   128     8 */
	const char  *              m_cpp_tok_end;        /*   136     8 */
	char *                     m_body_utf8;          /*   144     8 */
	char *                     m_body_utf8_ptr;      /*   152     8 */
	const char  *              m_cpp_utf8_processed_ptr; /*   160     8 */
	enum my_lex_states         next_state;           /*   168     1 */

	/* XXX 7 bytes hole, try to pack */

	const char  *              found_semicolon;      /*   176     8 */
	uchar                      tok_bitmap;           /*   184     1 */
	bool                       ignore_space;         /*   185     1 */
	bool                       stmt_prepare_mode;    /*   186     1 */
	bool                       multi_statements;     /*   187     1 */
	enum enum_comment_state    in_comment;           /*   188     4 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	enum enum_comment_state    in_comment_saved;     /*   192     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              m_cpp_text_start;     /*   200     8 */
	const char  *              m_cpp_text_end;       /*   208     8 */
	CHARSET_INFO *             m_underscore_cs;      /*   216     8 */
	sql_digest_state *         m_digest;             /*   224     8 */
	bool text_string_is_7bit(const class Lex_input_stream  *);


	/* size: 232, cachelines: 4, members: 35 */
	/* sum members: 204, holes: 5, sum holes: 28 */
	/* last cacheline: 40 bytes */
};
class List<Key_part_spec> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<Key_part_spec> *);

	void List(class List<Key_part_spec> *, const class List<Key_part_spec>  &);

	class List<Key_part_spec> & operator=(class List<Key_part_spec> *, const class List<Key_part_spec>  &);

	void List(class List<Key_part_spec> *, const class List<Key_part_spec>  &, MEM_ROOT *);

	bool push_back(class List<Key_part_spec> *, class Key_part_spec *);

	bool push_back(class List<Key_part_spec> *, class Key_part_spec *, MEM_ROOT *);

	bool push_front(class List<Key_part_spec> *, class Key_part_spec *);

	bool push_front(class List<Key_part_spec> *, class Key_part_spec *, MEM_ROOT *);

	class Key_part_spec * head(class List<Key_part_spec> *);

	class Key_part_spec * * head_ref(class List<Key_part_spec> *);

	class Key_part_spec * pop(class List<Key_part_spec> *);

	void concat(class List<Key_part_spec> *, class List<Key_part_spec> *);

	void disjoin(class List<Key_part_spec> *, class List<Key_part_spec> *);

	void prepand(class List<Key_part_spec> *, class List<Key_part_spec> *);

	void delete_elements(class List<Key_part_spec> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class Yacc_state {
public:

	void Yacc_state(class Yacc_state *);

	void reset(class Yacc_state *);

	void ~Yacc_state(class Yacc_state *, int);

	void reset_before_substatement(class Yacc_state *);

	uchar *                    yacc_yyss;            /*     0     8 */
	uchar *                    yacc_yyvs;            /*     8     8 */
	uchar *                    yacc_yyls;            /*    16     8 */
	enum thr_lock_type         m_lock_type;          /*    24     4 */
	enum enum_mdl_type         m_mdl_type;           /*    28     4 */
	enum ha_rkey_function      m_ha_rkey_mode;       /*    32     4 */

	/* size: 40, cachelines: 1, members: 6 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct Parser_input {
	bool                       m_compute_digest;     /*     0     1 */
	void Parser_input(class Parser_input *);


	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
class Parser_state {
public:

	void Parser_state(class Parser_state *);

	bool init(class Parser_state *, class THD *, const char  *, size_t);

	void reset(class Parser_state *, const char  *, size_t);

	void add_comment(class Parser_state *);

	bool has_comment(const class Parser_state  *);

	struct Parser_input        m_input;              /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	class Lex_input_stream    m_lip;                 /*     8   232 */
	/* --- cacheline 3 boundary (192 bytes) was 48 bytes ago --- */
	class Yacc_state          m_yacc;                /*   240    40 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	PSI_digest_locker *        m_digest_psi;         /*   280     8 */
	bool                       m_comment;            /*   288     1 */

	/* size: 296, cachelines: 5, members: 5 */
	/* sum members: 282, holes: 1, sum holes: 7 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 40 bytes */
};
class MY_LOCALE {
public:

	uint                       number;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              name;                 /*     8     8 */
	const char  *              description;          /*    16     8 */
	const bool                 is_ascii;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	TYPELIB *                  month_names;          /*    32     8 */
	TYPELIB *                  ab_month_names;       /*    40     8 */
	TYPELIB *                  day_names;            /*    48     8 */
	TYPELIB *                  ab_day_names;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint                       max_month_name_length; /*    64     4 */
	uint                       max_day_name_length;  /*    68     4 */
	uint                       decimal_point;        /*    72     4 */
	uint                       thousand_sep;         /*    76     4 */
	const char  *              grouping;             /*    80     8 */
	class MY_LOCALE_ERRMSGS *  errmsgs;              /*    88     8 */
	void MY_LOCALE(class MY_LOCALE *, uint, const char  *, const char  *, bool, TYPELIB *, TYPELIB *, TYPELIB *, TYPELIB *, uint, uint, uint, uint, const char  *, class MY_LOCALE_ERRMSGS *);


	/* size: 96, cachelines: 2, members: 14 */
	/* sum members: 85, holes: 2, sum holes: 11 */
	/* last cacheline: 32 bytes */
};
struct rusage {
	union {
		long int                   ru_maxrss;            /*     0     8 */
		__syscall_slong_t          __ru_maxrss_word;     /*     0     8 */
	};

	union {
		long int                   ru_ixrss;             /*     0     8 */
		__syscall_slong_t          __ru_ixrss_word;      /*     0     8 */
	};

	union {
		long int                   ru_idrss;             /*     0     8 */
		__syscall_slong_t          __ru_idrss_word;      /*     0     8 */
	};

	union {
		long int                   ru_isrss;             /*     0     8 */
		__syscall_slong_t          __ru_isrss_word;      /*     0     8 */
	};

	union {
		long int                   ru_minflt;            /*     0     8 */
		__syscall_slong_t          __ru_minflt_word;     /*     0     8 */
	};

	union {
		long int                   ru_majflt;            /*     0     8 */
		__syscall_slong_t          __ru_majflt_word;     /*     0     8 */
	};

	union {
		long int                   ru_nswap;             /*     0     8 */
		__syscall_slong_t          __ru_nswap_word;      /*     0     8 */
	};

	union {
		long int                   ru_inblock;           /*     0     8 */
		__syscall_slong_t          __ru_inblock_word;    /*     0     8 */
	};

	union {
		long int                   ru_oublock;           /*     0     8 */
		__syscall_slong_t          __ru_oublock_word;    /*     0     8 */
	};

	union {
		long int                   ru_msgsnd;            /*     0     8 */
		__syscall_slong_t          __ru_msgsnd_word;     /*     0     8 */
	};

	union {
		long int                   ru_msgrcv;            /*     0     8 */
		__syscall_slong_t          __ru_msgrcv_word;     /*     0     8 */
	};

	union {
		long int                   ru_nsignals;          /*     0     8 */
		__syscall_slong_t          __ru_nsignals_word;   /*     0     8 */
	};

	union {
		long int                   ru_nvcsw;             /*     0     8 */
		__syscall_slong_t          __ru_nvcsw_word;      /*     0     8 */
	};

	union {
		long int                   ru_nivcsw;            /*     0     8 */
		__syscall_slong_t          __ru_nivcsw_word;     /*     0     8 */
	};

	struct timeval             ru_utime;             /*     0    16 */
	struct timeval             ru_stime;             /*    16    16 */
	union {
		long int           ru_maxrss;            /*    32     8 */
		__syscall_slong_t  __ru_maxrss_word;     /*    32     8 */
	};                                               /*    32     8 */
	union {
		long int           ru_ixrss;             /*    40     8 */
		__syscall_slong_t  __ru_ixrss_word;      /*    40     8 */
	};                                               /*    40     8 */
	union {
		long int           ru_idrss;             /*    48     8 */
		__syscall_slong_t  __ru_idrss_word;      /*    48     8 */
	};                                               /*    48     8 */
	union {
		long int           ru_isrss;             /*    56     8 */
		__syscall_slong_t  __ru_isrss_word;      /*    56     8 */
	};                                               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	union {
		long int           ru_minflt;            /*    64     8 */
		__syscall_slong_t  __ru_minflt_word;     /*    64     8 */
	};                                               /*    64     8 */
	union {
		long int           ru_majflt;            /*    72     8 */
		__syscall_slong_t  __ru_majflt_word;     /*    72     8 */
	};                                               /*    72     8 */
	union {
		long int           ru_nswap;             /*    80     8 */
		__syscall_slong_t  __ru_nswap_word;      /*    80     8 */
	};                                               /*    80     8 */
	union {
		long int           ru_inblock;           /*    88     8 */
		__syscall_slong_t  __ru_inblock_word;    /*    88     8 */
	};                                               /*    88     8 */
	union {
		long int           ru_oublock;           /*    96     8 */
		__syscall_slong_t  __ru_oublock_word;    /*    96     8 */
	};                                               /*    96     8 */
	union {
		long int           ru_msgsnd;            /*   104     8 */
		__syscall_slong_t  __ru_msgsnd_word;     /*   104     8 */
	};                                               /*   104     8 */
	union {
		long int           ru_msgrcv;            /*   112     8 */
		__syscall_slong_t  __ru_msgrcv_word;     /*   112     8 */
	};                                               /*   112     8 */
	union {
		long int           ru_nsignals;          /*   120     8 */
		__syscall_slong_t  __ru_nsignals_word;   /*   120     8 */
	};                                               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	union {
		long int           ru_nvcsw;             /*   128     8 */
		__syscall_slong_t  __ru_nvcsw_word;      /*   128     8 */
	};                                               /*   128     8 */
	union {
		long int           ru_nivcsw;            /*   136     8 */
		__syscall_slong_t  __ru_nivcsw_word;     /*   136     8 */
	};                                               /*   136     8 */

	/* size: 144, cachelines: 3, members: 16 */
	/* last cacheline: 16 bytes */
};
class PROF_MEASUREMENT {
	class QUERY_PROFILE *      profile;              /*     0     8 */
	char *                     allocated_status_memory; /*     8     8 */
	void set_label(class PROF_MEASUREMENT *, const char  *, const char  *, const char  *, unsigned int);

	void clean_up(class PROF_MEASUREMENT *);

public:

	const char  *              status;               /*    16     8 */
	struct rusage              rusage;               /*    24   144 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	const char  *              function;             /*   168     8 */
	const char  *              file;                 /*   176     8 */
	unsigned int               line;                 /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	ulong                      m_seq;                /*   192     8 */
	double                     time_usecs;           /*   200     8 */
	double                     cpu_time_usecs;       /*   208     8 */
	void PROF_MEASUREMENT(class PROF_MEASUREMENT *);

	void PROF_MEASUREMENT(class PROF_MEASUREMENT *, class QUERY_PROFILE *, const char  *);

	void PROF_MEASUREMENT(class PROF_MEASUREMENT *, class QUERY_PROFILE *, const char  *, const char  *, const char  *, unsigned int);

	void ~PROF_MEASUREMENT(class PROF_MEASUREMENT *, int);

	void collect(class PROF_MEASUREMENT *);


	/* size: 216, cachelines: 4, members: 10 */
	/* sum members: 212, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class QUERY_PROFILE {
	class PROFILING *          profiling;            /*     0     8 */
	query_id_t                 profiling_query_id;   /*     8     8 */
	LEX_STRING                 m_query_source;       /*    16    16 */
	double                     m_start_time_usecs;   /*    32     8 */
	double                     m_end_time_usecs;     /*    40     8 */
	ulong                      m_seq_counter;        /*    48     8 */
	class Queue<PROF_MEASUREMENT> entries;           /*    56    24 */
	void QUERY_PROFILE(class QUERY_PROFILE *, class PROFILING *, const char  *);

	void ~QUERY_PROFILE(class QUERY_PROFILE *, int);

	void set_query_source(class QUERY_PROFILE *, const char  *, size_t);

	void new_status(class QUERY_PROFILE *, const char  *, const char  *, const char  *, unsigned int);

	void reset(class QUERY_PROFILE *);

	bool show(class QUERY_PROFILE *, uint);

public:

	class PROFILING * get_profiling(const class QUERY_PROFILE  *);


	/* size: 80, cachelines: 2, members: 7 */
	/* last cacheline: 16 bytes */
};
class Queue<PROF_MEASUREMENT> {
	struct queue_item {

		/* size: 0, cachelines: 0, members: 0 */
	};

	class queue_item *         first;                /*     0     8 */
	class queue_item *         last;                 /*     8     8 */
public:

	void Queue(class Queue<PROF_MEASUREMENT> *);

	void empty(class Queue<PROF_MEASUREMENT> *);

	ulong                      elements;             /*    16     8 */
	void push_back(class Queue<PROF_MEASUREMENT> *, class PROF_MEASUREMENT *);

	class PROF_MEASUREMENT * pop(class Queue<PROF_MEASUREMENT> *);

	bool is_empty(class Queue<PROF_MEASUREMENT> *);

	void * new_iterator(class Queue<PROF_MEASUREMENT> *);

	void * iterator_next(class Queue<PROF_MEASUREMENT> *, void *);

	class PROF_MEASUREMENT * iterator_value(class Queue<PROF_MEASUREMENT> *, void *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class PROFILING {
	query_id_t                 profile_id_counter;   /*     0     8 */
	class THD *                thd;                  /*     8     8 */
	bool                       keeping;              /*    16     1 */
	bool                       enabled;              /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	class QUERY_PROFILE *      current;              /*    24     8 */
	class QUERY_PROFILE *      last;                 /*    32     8 */
	class Queue<QUERY_PROFILE> history;              /*    40    24 */
	query_id_t next_profile_id(class PROFILING *);

public:

	void PROFILING(class PROFILING *);

	void ~PROFILING(class PROFILING *, int);

	void set_query_source(class PROFILING *, const char  *, size_t);

	void start_new_query(class PROFILING *, const char  *);

	void discard_current_query(class PROFILING *);

	void finish_current_query(class PROFILING *);

	void status_change(class PROFILING *, const char  *, const char  *, const char  *, unsigned int);

	void set_thd(class PROFILING *, class THD *);

	bool show_profiles(class PROFILING *);

	bool enabled_getrusage(const class PROFILING  *);

	int fill_statistics_info(class PROFILING *, class THD *, class TABLE_LIST *, class Item *);

	void cleanup(class PROFILING *);

	int print_current(const class PROFILING  *, IO_CACHE *);


	/* size: 64, cachelines: 1, members: 7 */
	/* sum members: 58, holes: 1, sum holes: 6 */
};
class Queue<QUERY_PROFILE> {
	struct queue_item {

		/* size: 0, cachelines: 0, members: 0 */
	};

	class queue_item *         first;                /*     0     8 */
	class queue_item *         last;                 /*     8     8 */
public:

	void Queue(class Queue<QUERY_PROFILE> *);

	void empty(class Queue<QUERY_PROFILE> *);

	ulong                      elements;             /*    16     8 */
	void push_back(class Queue<QUERY_PROFILE> *, class QUERY_PROFILE *);

	class QUERY_PROFILE * pop(class Queue<QUERY_PROFILE> *);

	bool is_empty(class Queue<QUERY_PROFILE> *);

	void * new_iterator(class Queue<QUERY_PROFILE> *);

	void * iterator_next(class Queue<QUERY_PROFILE> *, void *);

	class QUERY_PROFILE * iterator_value(class Queue<QUERY_PROFILE> *, void *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Session_sysvar_resource_manager {
	HASH                       m_sysvar_string_alloc_hash; /*     0   112 */
	uchar * find(class Session_sysvar_resource_manager *, void *, size_t);

public:

	void Session_sysvar_resource_manager(class Session_sysvar_resource_manager *);

	bool init(class Session_sysvar_resource_manager *, char * *, const CHARSET_INFO  *);

	bool update(class Session_sysvar_resource_manager *, char * *, char *, size_t);

	uchar * sysvars_mgr_get_key(const char  *, size_t *, my_bool);

	void claim_memory_ownership(class Session_sysvar_resource_manager *);

	void deinit(class Session_sysvar_resource_manager *);


	/* size: 112, cachelines: 2, members: 1 */
	/* last cacheline: 48 bytes */
};
struct st_changed_table_list {
	class st_changed_table_list * next;              /*     0     8 */
	char *                     key;                  /*     8     8 */
	uint32                     key_length;           /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct Query_cache_block_table {
	void Query_cache_block_table(class Query_cache_block_table *);

	size_t                     n;                    /*     0     8 */
	class Query_cache_block_table * next;            /*     8     8 */
	class Query_cache_block_table * prev;            /*    16     8 */
	class Query_cache_table *  parent;               /*    24     8 */
	class Query_cache_block * block(class Query_cache_block_table *);


	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct Query_cache_table {
	void Query_cache_table(class Query_cache_table *);

	char *                     tbl;                  /*     0     8 */
	uint32                     key_len;              /*     8     4 */
	uint8                      table_type;           /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	qc_engine_callback         callback_func;        /*    16     8 */
	ulonglong                  engine_data_buff;     /*    24     8 */
	int32                      m_cached_query_count; /*    32     4 */
	char * db(class Query_cache_table *);

	char * table(class Query_cache_table *);

	void table(class Query_cache_table *, char *);

	size_t key_length(class Query_cache_table *);

	void key_length(class Query_cache_table *, size_t);

	uint8 type(class Query_cache_table *);

	void type(class Query_cache_table *, uint8);

	qc_engine_callback callback(class Query_cache_table *);

	void callback(class Query_cache_table *, qc_engine_callback);

	ulonglong engine_data(class Query_cache_table *);

	void engine_data(class Query_cache_table *, ulonglong);

	uchar * data(class Query_cache_table *);


	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 33, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct Query_cache_block {
	enum block_type {
		FREE           = 0,
		QUERY          = 1,
		RESULT         = 2,
		RES_CONT       = 3,
		RES_BEG        = 4,
		RES_INCOMPLETE = 5,
		TABLE          = 6,
		INCOMPLETE     = 7,
	};

	void Query_cache_block(class Query_cache_block *);

	ulong                      length;               /*     0     8 */
	ulong                      used;                 /*     8     8 */
	class Query_cache_block *  pnext;                /*    16     8 */
	class Query_cache_block *  pprev;                /*    24     8 */
	class Query_cache_block *  next;                 /*    32     8 */
	class Query_cache_block *  prev;                 /*    40     8 */
	enum block_type            type;                 /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     n_tables;             /*    56     8 */
	my_bool is_free(class Query_cache_block *);

	void init(class Query_cache_block *, ulong);

	void destroy(class Query_cache_block *);

	uint headers_len(class Query_cache_block *);

	uchar * data(class Query_cache_block *);

	class Query_cache_query * query(class Query_cache_block *);

	class Query_cache_table * table(class Query_cache_block *);

	class Query_cache_result * result(class Query_cache_block *);

	class Query_cache_block_table * table(class Query_cache_block *, size_t);


	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct Query_cache_query {
	ulonglong                  current_found_rows;   /*     0     8 */
	mysql_rwlock_t             lock;                 /*     8    64 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	class Query_cache_block *  res;                  /*    72     8 */
	class Query_cache_tls *    wri;                  /*    80     8 */
	ulong                      len;                  /*    88     8 */
	uint8                      tbls_type;            /*    96     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               last_pkt_nr;          /*   100     4 */
	void Query_cache_query(class Query_cache_query *);

	void init_n_lock(class Query_cache_query *);

	void unlock_n_destroy(class Query_cache_query *);

	ulonglong found_rows(class Query_cache_query *);

	void found_rows(class Query_cache_query *, ulonglong);

	class Query_cache_block * result(class Query_cache_query *);

	void result(class Query_cache_query *, class Query_cache_block *);

	class Query_cache_tls * writer(class Query_cache_query *);

	void writer(class Query_cache_query *, class Query_cache_tls *);

	uint8 tables_type(class Query_cache_query *);

	void tables_type(class Query_cache_query *, uint8);

	ulong length(class Query_cache_query *);

	ulong add(class Query_cache_query *, ulong);

	void length(class Query_cache_query *, ulong);

	uchar * query(class Query_cache_query *);

	void lock_writing(class Query_cache_query *);

	void lock_reading(class Query_cache_query *);

	my_bool try_lock_writing(class Query_cache_query *);

	void unlock_writing(class Query_cache_query *);

	void unlock_reading(class Query_cache_query *);


	/* size: 104, cachelines: 2, members: 7 */
	/* sum members: 101, holes: 1, sum holes: 3 */
	/* last cacheline: 40 bytes */
};
struct Query_cache_result {
	void Query_cache_result(class Query_cache_result *);

	class Query_cache_block *  query;                /*     0     8 */
	uchar * data(class Query_cache_result *);

	class Query_cache_block * parent(class Query_cache_result *);

	void parent(class Query_cache_result *, class Query_cache_block *);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct Query_cache_tls {
	class Query_cache_block *  first_query_block;    /*     0     8 */
	void set_first_query_block(class Query_cache_tls *, class Query_cache_block *);

	void Query_cache_tls(class Query_cache_tls *);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct Query_cache_memory_bin {
	void Query_cache_memory_bin(class Query_cache_memory_bin *);

	uint                       number;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class Query_cache_block *  free_blocks;          /*     8     8 */
	void init(class Query_cache_memory_bin *, ulong);


	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct Query_cache_memory_bin_step {
	void Query_cache_memory_bin_step(class Query_cache_memory_bin_step *);

	ulong                      size;                 /*     0     8 */
	ulong                      increment;            /*     8     8 */
	uint                       idx;                  /*    16     4 */
	void init(class Query_cache_memory_bin_step *, ulong, uint, ulong);


	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
class Query_cache {
	enum Cache_lock_status {
		UNLOCKED       = 0,
		LOCKED_NO_WAIT = 1,
		LOCKED         = 2,
	};

	enum enum_qcci_lock_mode {
		CALLER_HOLDS_LOCK   = 0,
		LOCK_WHILE_CHECKING = 1,
	};

public:

	ulong                      query_cache_size;     /*     0     8 */
	ulong                      query_cache_limit;    /*     8     8 */
	ulong                      free_memory;          /*    16     8 */
	ulong                      queries_in_cache;     /*    24     8 */
	ulong                      hits;                 /*    32     8 */
	ulong                      inserts;              /*    40     8 */
	ulong                      refused;              /*    48     8 */
	ulong                      free_memory_blocks;   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	ulong                      total_blocks;         /*    64     8 */
	ulong                      lowmem_prunes;        /*    72     8 */
	mysql_cond_t               COND_cache_status_changed; /*    80    56 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	enum Cache_lock_status     m_cache_lock_status;  /*   136     4 */
	bool                       m_query_cache_is_disabled; /*   140     1 */

	/* XXX 3 bytes hole, try to pack */
	void free_query_internal(class Query_cache *, class Query_cache_block *);

	void invalidate_table_internal(class Query_cache *, class THD *, uchar *, size_t);

	void disable_query_cache(class Query_cache *);

protected:


	mysql_mutex_t              structure_guard_mutex; /*   144    48 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	uchar *                    cache;                /*   192     8 */
	class Query_cache_block *  first_block;          /*   200     8 */
	class Query_cache_block *  queries_blocks;       /*   208     8 */
	class Query_cache_block *  tables_blocks;        /*   216     8 */
	class Query_cache_memory_bin * bins;             /*   224     8 */
	class Query_cache_memory_bin_step * steps;       /*   232     8 */
	HASH                       queries;              /*   240   112 */
	/* --- cacheline 5 boundary (320 bytes) was 32 bytes ago --- */
	HASH                       tables;               /*   352   112 */
	/* --- cacheline 7 boundary (448 bytes) was 16 bytes ago --- */
	ulong                      min_allocation_unit;  /*   464     8 */
	ulong                      min_result_data_size; /*   472     8 */
	uint                       def_query_hash_size;  /*   480     4 */
	uint                       def_table_hash_size;  /*   484     4 */
	uint                       mem_bin_num;          /*   488     4 */
	uint                       mem_bin_steps;        /*   492     4 */
	my_bool                    initialized;          /*   496     1 */
	void double_linked_list_exclude(class Query_cache_block *, class Query_cache_block * *);

	void double_linked_list_simple_include(class Query_cache_block *, class Query_cache_block * *);

	void double_linked_list_join(class Query_cache_block *, class Query_cache_block *);

	size_t filename_2_table_key(char *, const char  *, size_t *);

	void flush_cache(class Query_cache *);

	my_bool free_old_query(class Query_cache *);

	void free_query(class Query_cache *, class Query_cache_block *);

	my_bool allocate_data_chain(class Query_cache *, class Query_cache_block * *, ulong, class Query_cache_block *, my_bool);

	void invalidate_table(class Query_cache *, class THD *, class TABLE_LIST *);

	void invalidate_table(class Query_cache *, class THD *, class TABLE *);

	void invalidate_table(class Query_cache *, class THD *, uchar *, size_t);

	void invalidate_table(class Query_cache *, class THD *, class Query_cache_block *);

	void invalidate_query_block_list(class Query_cache *, class THD *, class Query_cache_block_table *);

	size_t register_tables_from_list(class Query_cache *, class TABLE_LIST *, size_t, class Query_cache_block_table *);

	my_bool register_all_tables(class Query_cache *, class Query_cache_block *, class TABLE_LIST *, size_t);

	my_bool insert_table(class Query_cache *, size_t, const char  *, class Query_cache_block_table *, size_t, uint8, qc_engine_callback, ulonglong);

	void unlink_table(class Query_cache *, class Query_cache_block_table *);

	class Query_cache_block * get_free_block(class Query_cache *, size_t, my_bool, size_t);

	void free_memory_block(class Query_cache *, class Query_cache_block *);

	void split_block(class Query_cache *, class Query_cache_block *, ulong);

	class Query_cache_block * join_free_blocks(class Query_cache *, class Query_cache_block *, class Query_cache_block *);

	my_bool append_next_free_block(class Query_cache *, class Query_cache_block *, ulong);

	void exclude_from_free_memory_list(class Query_cache *, class Query_cache_block *);

	void insert_into_free_memory_list(class Query_cache *, class Query_cache_block *);

	my_bool move_by_type(class Query_cache *, uchar * *, class Query_cache_block * *, ulong *, class Query_cache_block *);

	uint find_bin(class Query_cache *, size_t);

	void move_to_query_list_end(class Query_cache *, class Query_cache_block *);

	void insert_into_free_memory_sorted_list(class Query_cache *, class Query_cache_block *, class Query_cache_block * *);

	void pack_cache(class Query_cache *);

	void relink(class Query_cache *, class Query_cache_block *, class Query_cache_block *, class Query_cache_block *, class Query_cache_block *, class Query_cache_block *, class Query_cache_block *);

	my_bool join_results(class Query_cache *, ulong);

	ulong init_cache(class Query_cache *);

	void make_disabled(class Query_cache *);

	void free_cache(class Query_cache *);

	class Query_cache_block * write_block_data(class Query_cache *, size_t, uchar *, size_t, enum block_type, size_t);

	my_bool append_result_data(class Query_cache *, class Query_cache_block * *, ulong, uchar *, class Query_cache_block *);

	my_bool write_result_data(class Query_cache *, class Query_cache_block * *, ulong, uchar *, class Query_cache_block *, enum block_type);

	ulong get_min_first_result_data_size(class Query_cache *);

	ulong get_min_append_result_data_size(class Query_cache *);

	class Query_cache_block * allocate_block(class Query_cache *, size_t, my_bool, size_t);

	size_t is_cacheable(class Query_cache *, class THD *, class LEX *, class TABLE_LIST *, uint8 *);

	size_t process_and_count_tables(class Query_cache *, class THD *, class TABLE_LIST *, uint8 *);

	my_bool ask_handler_allowance(class THD *, class TABLE_LIST *);

public:

	void Query_cache(class Query_cache *, ulong, ulong, ulong, uint, uint);

	bool is_disabled(class Query_cache *);

	void init(class Query_cache *);

	ulong resize(class Query_cache *, ulong);

	void result_size_limit(class Query_cache *, ulong);

	ulong set_min_res_unit(class Query_cache *, ulong);

	void store_query(class Query_cache *, class THD *, class TABLE_LIST *);

	int send_result_to_client(class Query_cache *, class THD *, const LEX_CSTRING  &);

	void invalidate_single(class Query_cache *, class THD *, class TABLE_LIST *, my_bool);

	void invalidate(class Query_cache *, class THD *, class TABLE_LIST *, my_bool);

	void invalidate(class Query_cache *, CHANGED_TABLE_LIST *);

	void invalidate_locked_for_write(class Query_cache *, class TABLE_LIST *);

	void invalidate(class Query_cache *, class THD *, class TABLE *, my_bool);

	void invalidate(class Query_cache *, class THD *, const char  *, uint32, my_bool);

	void invalidate(class Query_cache *, const char  *);

	void invalidate_by_MyISAM_filename(class Query_cache *, const char  *);

	void flush(class Query_cache *);

	void pack(class Query_cache *, ulong, uint);

	void destroy(class Query_cache *);

	void insert(class Query_cache *, class Query_cache_tls *, const char  *, ulong, unsigned int);

	void end_of_result(class Query_cache *, class THD *);

	void abort(class Query_cache *, class Query_cache_tls *);

	void wreck(class Query_cache *, uint, const char  *);

	void bins_dump(class Query_cache *);

	void cache_dump(class Query_cache *);

	void queries_dump(class Query_cache *);

	void tables_dump(class Query_cache *);

	bool check_integrity(class Query_cache *, enum enum_qcci_lock_mode);

	my_bool in_list(class Query_cache *, class Query_cache_block *, class Query_cache_block *, const char  *);

	my_bool in_table_list(class Query_cache *, class Query_cache_block_table *, class Query_cache_block_table *, const char  *);

	my_bool in_blocks(class Query_cache *, class Query_cache_block *);

	bool try_lock(class Query_cache *, bool);

	void lock(class Query_cache *);

	void lock_and_suspend(class Query_cache *);

	void unlock(class Query_cache *);


	/* size: 504, cachelines: 8, members: 29 */
	/* sum members: 494, holes: 1, sum holes: 3 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
class Ha_trx_info {
public:

	void register_ha(class Ha_trx_info *, class Ha_trx_info *, class handlerton *);

	void reset(class Ha_trx_info *);

	void Ha_trx_info(class Ha_trx_info *);

	void set_trx_read_write(class Ha_trx_info *);

	bool is_trx_read_write(const class Ha_trx_info  *);

	void set_trx_noop_read_write(class Ha_trx_info *);

	bool is_trx_noop_read_write(const class Ha_trx_info  *);

	bool is_started(const class Ha_trx_info  *);

	void coalesce_trx_with(class Ha_trx_info *, const class Ha_trx_info  *);

	class Ha_trx_info * next(const class Ha_trx_info  *);

	class handlerton * ht(const class Ha_trx_info  *);

	class Ha_trx_info *        m_next;               /*     0     8 */
	class handlerton *         m_ht;                 /*     8     8 */
	uchar                      m_flags;              /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
class Transaction_ctx {
	enum enum_trx_scope {
		STMT    = 0,
		SESSION = 1,
	};

	struct THD_TRANS {
		bool                       m_no_2pc;             /*     0     1 */

		/* XXX 3 bytes hole, try to pack */

		int                        m_rw_ha_count;        /*     4     4 */
		class Ha_trx_info *        m_ha_list;            /*     8     8 */
	private:

		unsigned int               m_unsafe_rollback_flags; /*    16     4 */

		/* Bitfield combined with previous fields */

		static const unsigned int         MODIFIED_NON_TRANS_TABLE = 1; /*     0     0 */
		static const unsigned int         CREATED_TEMP_TABLE = 2; /*     0     0 */
		static const unsigned int         DROPPED_TEMP_TABLE = 4; /*     0     0 */
		bool cannot_safely_rollback(const class THD_TRANS  *);

		unsigned int get_unsafe_rollback_flags(const class THD_TRANS  *);

		void set_unsafe_rollback_flags(class THD_TRANS *, unsigned int);

		void add_unsafe_rollback_flags(class THD_TRANS *, unsigned int);

		void reset_unsafe_rollback_flags(class THD_TRANS *);

		void mark_modified_non_trans_table(class THD_TRANS *);

		bool has_modified_non_trans_table(const class THD_TRANS  *);

		void mark_created_temp_table(class THD_TRANS *);

		bool has_created_temp_table(const class THD_TRANS  *);

		void mark_dropped_temp_table(class THD_TRANS *);

		bool has_dropped_temp_table(const class THD_TRANS  *);

		void reset(class THD_TRANS *);

		bool is_empty(const class THD_TRANS  *);


		/* size: 24, cachelines: 1, members: 4, static members: 3 */
		/* sum members: 17, holes: 1, sum holes: 3 */
		/* padding: 4 */
		/* last cacheline: 24 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

	struct {
		bool                       enabled;              /*     0     1 */
		bool                       pending;              /*     1     1 */
		bool                       xid_written;          /*     2     1 */
		bool                       real_commit;          /*     3     1 */
		bool                       commit_low;           /*     4     1 */
		bool                       run_hooks;            /*     5     1 */

		/* size: 6, cachelines: 1, members: 6 */
		/* last cacheline: 6 bytes */
	};

public:

	void Transaction_ctx(class Transaction_ctx *, const class Transaction_ctx  &);

	int ()(void) * *           _vptr.Transaction_ctx; /*     0     8 */
	SAVEPOINT *                m_savepoints;         /*     8     8 */
	struct THD_TRANS           m_scope_info[2];      /*    16    48 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class XID_STATE           m_xid_state;           /*    64   168 */

	/* XXX last struct has 3 bytes of padding */

	/* --- cacheline 3 boundary (192 bytes) was 40 bytes ago --- */
	CHANGED_TABLE_LIST *       m_changed_tables;     /*   232     8 */
	MEM_ROOT                   m_mem_root;           /*   240    88 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	struct {
		bool               enabled;              /*   328     1 */
		bool               pending;              /*   329     1 */
		bool               xid_written;          /*   330     1 */
		bool               real_commit;          /*   331     1 */
		bool               commit_low;           /*   332     1 */
		bool               run_hooks;            /*   333     1 */
	} m_flags;                                       /*   328     6 */

	/* XXX 2 bytes hole, try to pack */

	int64                      last_committed;       /*   336     8 */
	int64                      sequence_number;      /*   344     8 */
	void store_commit_parent(class Transaction_ctx *, int64);

	void Transaction_ctx(class Transaction_ctx *);

	virtual void ~Transaction_ctx(class Transaction_ctx *, int);

	void cleanup(class Transaction_ctx *);

	bool is_active(const class Transaction_ctx  *, enum enum_trx_scope);

	void push_unsafe_rollback_warnings(class Transaction_ctx *, class THD *);

	void merge_unsafe_rollback_flags(class Transaction_ctx *);

	void init_mem_root_defaults(class Transaction_ctx *, ulong, ulong);

	MEM_ROOT * transaction_memroot(class Transaction_ctx *);

	void * allocate_memory(class Transaction_ctx *, unsigned int);

	void claim_memory_ownership(class Transaction_ctx *);

	void free_memory(class Transaction_ctx *, myf);

	char * strmake(class Transaction_ctx *, const char  *, size_t);

	void invalidate_changed_tables_in_cache(class Transaction_ctx *);

	bool add_changed_table(class Transaction_ctx *, const char  *, long int);

	class Ha_trx_info * ha_trx_info(class Transaction_ctx *, enum enum_trx_scope);

	const class Ha_trx_info  * ha_trx_info(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_ha_trx_info(class Transaction_ctx *, enum enum_trx_scope, class Ha_trx_info *);

	class XID_STATE * xid_state(class Transaction_ctx *);

	const class XID_STATE  * xid_state(const class Transaction_ctx  *);

	bool cannot_safely_rollback(const class Transaction_ctx  *, enum enum_trx_scope);

	unsigned int get_unsafe_rollback_flags(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_unsafe_rollback_flags(class Transaction_ctx *, enum enum_trx_scope, unsigned int);

	void add_unsafe_rollback_flags(class Transaction_ctx *, enum enum_trx_scope, unsigned int);

	void reset_unsafe_rollback_flags(class Transaction_ctx *, enum enum_trx_scope);

	void mark_modified_non_trans_table(class Transaction_ctx *, enum enum_trx_scope);

	bool has_modified_non_trans_table(const class Transaction_ctx  *, enum enum_trx_scope);

	void mark_created_temp_table(class Transaction_ctx *, enum enum_trx_scope);

	bool has_created_temp_table(const class Transaction_ctx  *, enum enum_trx_scope);

	void mark_dropped_temp_table(class Transaction_ctx *, enum enum_trx_scope);

	bool has_dropped_temp_table(const class Transaction_ctx  *, enum enum_trx_scope);

	void reset(class Transaction_ctx *, enum enum_trx_scope);

	bool is_empty(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_no_2pc(class Transaction_ctx *, enum enum_trx_scope, bool);

	bool no_2pc(const class Transaction_ctx  *, enum enum_trx_scope);

	int rw_ha_count(const class Transaction_ctx  *, enum enum_trx_scope);

	void set_rw_ha_count(class Transaction_ctx *, enum enum_trx_scope, int);

	void reset_scope(class Transaction_ctx *, enum enum_trx_scope);

	CHANGED_TABLE_LIST * changed_table_dup(class Transaction_ctx *, const char  *, long int);

	bool list_include(class Transaction_ctx *, CHANGED_TABLE_LIST * *, CHANGED_TABLE_LIST *, CHANGED_TABLE_LIST *);

	class Rpl_transaction_ctx * get_rpl_transaction_ctx(class Transaction_ctx *);

	const class Rpl_transaction_ctx  * get_rpl_transaction_ctx(const class Transaction_ctx  *);

	class Rpl_transaction_write_set_ctx * get_transaction_write_set_ctx(class Transaction_ctx *);

	const class Rpl_transaction_write_set_ctx  * get_transaction_write_set_ctx(const class Transaction_ctx  *);

	class Rpl_transaction_ctx m_rpl_transaction_ctx; /*   352    40 */
	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
	class Rpl_transaction_write_set_ctx m_transaction_write_set_ctx; /*   392   168 */

	/* XXX last struct has 5 bytes of padding */

	/* size: 560, cachelines: 9, members: 11 */
	/* sum members: 558, holes: 1, sum holes: 2 */
	/* paddings: 2, sum paddings: 8 */
	/* last cacheline: 48 bytes */
};
class QueryStripComments {
	void QueryStripComments(class QueryStripComments *, const class QueryStripComments  &);

	class QueryStripComments & operator=(class QueryStripComments *, const class QueryStripComments  &);

public:

	void QueryStripComments(class QueryStripComments *);

	void ~QueryStripComments(class QueryStripComments *, int);

	void set(class QueryStripComments *, LEX_CSTRING, uint);

	char * query(class QueryStripComments *);

	uint query_length(class QueryStripComments *);

	void cleanup(class QueryStripComments *);

	char *                     buffer;               /*     0     8 */
	uint                       length;               /*     8     4 */
	uint                       buffer_length;        /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct fragmentation_stats_t {
	ulonglong                  scan_pages_contiguous; /*     0     8 */
	ulonglong                  scan_pages_disjointed; /*     8     8 */
	ulonglong                  scan_pages_total_seek_distance; /*    16     8 */
	ulonglong                  scan_data_size;       /*    24     8 */
	ulonglong                  scan_deleted_recs_size; /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct st_log_info {
	char                       log_file_name[512];   /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	my_off_t                   index_file_offset;    /*   512     8 */
	my_off_t                   index_file_start_offset; /*   520     8 */
	my_off_t                   pos;                  /*   528     8 */
	bool                       fatal;                /*   536     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        entry_index;          /*   540     4 */
	void st_log_info(class st_log_info *);


	/* size: 544, cachelines: 9, members: 6 */
	/* sum members: 541, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct st_user_var_events {
	class user_var_entry *     user_var_event;       /*     0     8 */
	char *                     value;                /*     8     8 */
	ulong                      length;               /*    16     8 */
	enum Item_result           type;                 /*    24     4 */
	uint                       charset_number;       /*    28     4 */
	bool                       unsigned_flag;        /*    32     1 */

	/* size: 40, cachelines: 1, members: 6 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
class user_var_entry {
	static const size_t               extra_size = 8; /*     0     0 */
	char *                     m_ptr;                /*     0     8 */
	size_t                     m_length;             /*     8     8 */
	enum Item_result           m_type;               /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	class THD *                m_owner;              /*    24     8 */
	void reset_value(class user_var_entry *);

	void set_value(class user_var_entry *, char *, size_t);

	char * internal_buffer_ptr(const class user_var_entry  *);

	char * name_ptr(const class user_var_entry  *);

	bool mem_realloc(class user_var_entry *, size_t);

	bool alloced(class user_var_entry *);

	void free_value(class user_var_entry *);

	void copy_name(class user_var_entry *, const class Simple_cstring  &);

	void init(class user_var_entry *, class THD *, const class Simple_cstring  &, const CHARSET_INFO  *);

	bool store(class user_var_entry *, const void  *, size_t, enum Item_result);

	void assert_locked(const class user_var_entry  *);

	LEX_CSTRING                m_catalog;            /*    32    16 */
public:

	void user_var_entry(class user_var_entry *);

	class Simple_cstring      entry_name;            /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class DTCollation         collation;             /*    64    16 */
	query_id_t                 update_query_id;      /*    80     8 */
	query_id_t                 used_query_id;        /*    88     8 */
	bool                       unsigned_flag;        /*    96     1 */
	bool store(class user_var_entry *, const void  *, size_t, enum Item_result, const CHARSET_INFO  *, enum Derivation, bool);

	void set_type(class user_var_entry *, enum Item_result);

	void set_null_value(class user_var_entry *, enum Item_result);

	class user_var_entry * create(class THD *, const class Name_string  &, const CHARSET_INFO  *);

	void destroy(class user_var_entry *);

	void lock(class user_var_entry *);

	void unlock(class user_var_entry *);

	const char  * ptr(const class user_var_entry  *);

	size_t length(const class user_var_entry  *);

	enum Item_result type(const class user_var_entry  *);

	double val_real(const class user_var_entry  *, my_bool *);

	longlong val_int(const class user_var_entry  *, my_bool *);

	class String * val_str(const class user_var_entry  *, my_bool *, class String *, uint);

	class my_decimal * val_decimal(const class user_var_entry  *, my_bool *, class my_decimal *);


	/* size: 104, cachelines: 2, members: 10, static members: 1 */
	/* sum members: 93, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
class thd_scheduler {
public:

	void *                     data;                 /*     0     8 */
	void thd_scheduler(class thd_scheduler *);

	void ~thd_scheduler(class thd_scheduler *, int);


	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct rpl_event_coordinates {
	char *                     file_name;            /*     0     8 */
	my_off_t                   pos;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Query_arena {
	enum enum_state {
		STMT_INITIALIZED            = 0,
		STMT_INITIALIZED_FOR_SP     = 1,
		STMT_PREPARED               = 2,
		STMT_CONVENTIONAL_EXECUTION = 3,
		STMT_EXECUTED               = 4,
		STMT_ERROR                  = 4294967295,
	};

public:

	void Query_arena(class Query_arena *, const class Query_arena  &);

	class Query_arena & operator=(class Query_arena *, const class Query_arena  &);

	int ()(void) * *           _vptr.Query_arena;    /*     0     8 */
	class Item *               free_list;            /*     8     8 */
	MEM_ROOT *                 mem_root;             /*    16     8 */
	enum enum_state            state;                /*    24     4 */
	void Query_arena(class Query_arena *, MEM_ROOT *, enum enum_state);

	void Query_arena(class Query_arena *);

	virtual void ~Query_arena(class Query_arena *, int);

	bool is_stmt_prepare(const class Query_arena  *);

	bool is_stmt_prepare_or_first_sp_execute(const class Query_arena  *);

	bool is_stmt_prepare_or_first_stmt_execute(const class Query_arena  *);

	bool is_conventional(const class Query_arena  *);

	void * alloc(class Query_arena *, size_t);

	void * mem_calloc(class Query_arena *, size_t);

	char * mem_strdup(class Query_arena *, const char  *);

	char * strmake(class Query_arena *, const char  *, size_t);

	LEX_CSTRING strmake(class Query_arena *, LEX_CSTRING);

	void * memdup(class Query_arena *, const void  *, size_t);

	void set_query_arena(class Query_arena *, class Query_arena *);

	void free_items(class Query_arena *);

	virtual void cleanup_stmt(class Query_arena *);

	/* vtable has 1 entries: {
	   [2] = cleanup_stmt((null)), 
	} */
	/* size: 32, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
class Prepared_statement_map {
public:

	void Prepared_statement_map(class Prepared_statement_map *);

	int insert(class Prepared_statement_map *, class THD *, class Prepared_statement *);

	class Prepared_statement * find_by_name(class Prepared_statement_map *, const LEX_CSTRING  &);

	class Prepared_statement * find(class Prepared_statement_map *, ulong);

	void erase(class Prepared_statement_map *, class Prepared_statement *);

	void claim_memory_ownership(class Prepared_statement_map *);

	void reset(class Prepared_statement_map *);

	void ~Prepared_statement_map(class Prepared_statement_map *, int);

	HASH                       st_hash;              /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	HASH                       names_hash;           /*   112   112 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	class Prepared_statement * m_last_found_statement; /*   224     8 */

	/* size: 232, cachelines: 4, members: 3 */
	/* last cacheline: 40 bytes */
};
class I_List<Item_change_record> : base_ilist<Item_change_record> {
	using ::empty;

	using ::is_empty;

	using ::get;

	using ::push_front;

	using ::push_back;

	using ::head;

	/* class base_ilist<Item_change_record> <ancestor>; */ /*     0    32 */
public:

	void move_elements_to(class I_List<Item_change_record> *, class I_List<Item_change_record> *);

	void ~I_List(class I_List<Item_change_record> *, int);

	void I_List(class I_List<Item_change_record> *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Prealloced_array<Reprepare_observer*, 4, true> {
	class Reprepare_observer * * cast_rawbuff(class Prealloced_array<Reprepare_observer*, 4, true> *);

public:

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4, true> *, const class Prealloced_array<Reprepare_observer*, 4, true>  &);

	void Prealloced_array(class Prealloced_array<Reprepare_observer*, 4, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Reprepare_observer * const * const_iterator;

	class Prealloced_array<Reprepare_observer*, 4, true> & operator=(class Prealloced_array<Reprepare_observer*, 4, true> *, const class Prealloced_array<Reprepare_observer*, 4, true>  &);

	void ~Prealloced_array(class Prealloced_array<Reprepare_observer*, 4, true> *, int);

	size_t capacity(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	size_t element_size(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	bool empty(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	size_t size(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	class Reprepare_observer * & at(class Prealloced_array<Reprepare_observer*, 4, true> *, size_t);

	class Reprepare_observer * const & at(const class Prealloced_array<Reprepare_observer*, 4, true>  *, size_t);

	class Reprepare_observer * & operator[](class Prealloced_array<Reprepare_observer*, 4, true> *, size_t);

	class Reprepare_observer * const & operator[](const class Prealloced_array<Reprepare_observer*, 4, true>  *, size_t);

	class Reprepare_observer * & back(class Prealloced_array<Reprepare_observer*, 4, true> *);

	class Reprepare_observer * const & back(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	class Reprepare_observer * & front(class Prealloced_array<Reprepare_observer*, 4, true> *);

	class Reprepare_observer * const & front(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	typedef class Reprepare_observer * * iterator;

	iterator begin(class Prealloced_array<Reprepare_observer*, 4, true> *);

	iterator end(class Prealloced_array<Reprepare_observer*, 4, true> *);

	const_iterator begin(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	const_iterator end(const class Prealloced_array<Reprepare_observer*, 4, true>  *);

	bool reserve(class Prealloced_array<Reprepare_observer*, 4, true> *, size_t);

	bool push_back(class Prealloced_array<Reprepare_observer*, 4, true> *, class Reprepare_observer * const &);

	void pop_back(class Prealloced_array<Reprepare_observer*, 4, true> *);

	iterator insert(class Prealloced_array<Reprepare_observer*, 4, true> *, iterator, const value_type  &);

	typedef class Reprepare_observer * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<Reprepare_observer**, bool> insert_unique(class Prealloced_array<Reprepare_observer*, 4, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Reprepare_observer*, 4, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Reprepare_observer*, 4, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<Reprepare_observer*, 4, true> *, iterator);

	iterator erase(class Prealloced_array<Reprepare_observer*, 4, true> *, size_t);

	void erase_at_end(class Prealloced_array<Reprepare_observer*, 4, true> *, iterator);

	iterator erase(class Prealloced_array<Reprepare_observer*, 4, true> *, iterator, iterator);

	void swap(class Prealloced_array<Reprepare_observer*, 4, true> *, class Prealloced_array<Reprepare_observer*, 4, true> &);

	void shrink_to_fit(class Prealloced_array<Reprepare_observer*, 4, true> *);

	void resize(class Prealloced_array<Reprepare_observer*, 4, true> *, size_t, class Reprepare_observer * const &);

	void clear(class Prealloced_array<Reprepare_observer*, 4, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<32, 8> m_buff __attribute__((__aligned__(8))); /*    16    32 */
	class Reprepare_observer * * m_array_ptr;        /*    48     8 */
	PSI_memory_key             m_psi_key;            /*    56     4 */

	/* size: 64, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class Reprepare_observer {
public:

	void Reprepare_observer(class Reprepare_observer *);

	bool report_error(class Reprepare_observer *, class THD *);

	bool is_invalidated(const class Reprepare_observer  *);

	void reset_reprepare_observer(class Reprepare_observer *);

	bool can_retry(const class Reprepare_observer  *);

	bool                       m_invalidated;        /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        m_attempt;            /*     4     4 */

	/* Bitfield combined with previous fields */

	static const int                  MAX_REPREPARE_ATTEMPTS = 3; /*     0     0 */

	/* size: 8, cachelines: 1, members: 2, static members: 1 */
	/* sum members: 5, holes: 1, sum holes: 3 */
	/* last cacheline: 8 bytes */
};
class Open_tables_state {
	enum enum_flags {
		BACKUPS_AVAIL = 1,
	};

	class Prealloced_array<Reprepare_observer*, 4, true> m_reprepare_observers __attribute__((__aligned__(8))); /*     0    64 */

	/* XXX last struct has 4 bytes of padding */
public:

	class Reprepare_observer * get_reprepare_observer(const class Open_tables_state  *);

	void push_reprepare_observer(class Open_tables_state *, class Reprepare_observer *);

	class Reprepare_observer * pop_reprepare_observer(class Open_tables_state *);

	void reset_reprepare_observers(class Open_tables_state *);


	/* --- cacheline 1 boundary (64 bytes) --- */
	class TABLE *              open_tables;          /*    64     8 */
	class TABLE *              temporary_tables;     /*    72     8 */
	class TABLE *              derived_tables;       /*    80     8 */
	MYSQL_LOCK *               lock;                 /*    88     8 */
	MYSQL_LOCK *               extra_lock;           /*    96     8 */
	enum enum_locked_tables_mode locked_tables_mode; /*   104     4 */
	uint                       state_flags;          /*   108     4 */
	void Open_tables_state(class Open_tables_state *);

	void set_open_tables_state(class Open_tables_state *, class Open_tables_state *);

	void reset_open_tables_state(class Open_tables_state *);

	void ~Open_tables_state(class Open_tables_state *, int);


	/* size: 112, cachelines: 2, members: 8 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
class Open_tables_backup : public Open_tables_state {
public:

	/* class Open_tables_state   <ancestor>; */      /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	class MDL_savepoint       mdl_system_tables_svp; /*   112    16 */
	void ~Open_tables_backup(class Open_tables_backup *, int);

	void Open_tables_backup(class Open_tables_backup *);


	/* size: 128, cachelines: 2, members: 2 */

	/* BRAIN FART ALERT! 128 bytes != 16 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 896 bits */
} __attribute__((__aligned__(8)));
class Sub_statement_state {
public:

	ulonglong                  option_bits;          /*     0     8 */
	ulonglong                  first_successful_insert_id_in_prev_stmt; /*     8     8 */
	ulonglong                  first_successful_insert_id_in_cur_stmt; /*    16     8 */
	ulonglong                  insert_id_for_cur_row; /*    24     8 */
	class Discrete_interval   auto_inc_interval_for_cur_row; /*    32    32 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class Discrete_intervals_list auto_inc_intervals_forced; /*    64    64 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) --- */
	ulonglong                  current_found_rows;   /*   128     8 */
	ulonglong                  previous_found_rows;  /*   136     8 */
	ha_rows                    cuted_fields;         /*   144     8 */
	ha_rows                    sent_row_count;       /*   152     8 */
	ha_rows                    examined_row_count;   /*   160     8 */
	ulong                      client_capabilities;  /*   168     8 */
	uint                       in_sub_stmt;          /*   176     4 */
	bool                       enable_slow_log;      /*   180     1 */
	bool                       last_insert_id_used;  /*   181     1 */

	/* XXX 2 bytes hole, try to pack */

	ulong                      tmp_tables_used;      /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	ulong                      tmp_tables_disk_used; /*   192     8 */
	ulonglong                  tmp_tables_size;      /*   200     8 */
	bool                       innodb_was_used;      /*   208     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      innodb_io_reads;      /*   216     8 */
	ulonglong                  innodb_io_read;       /*   224     8 */
	uint64_t                   innodb_io_reads_wait_timer; /*   232     8 */
	uint64_t                   innodb_lock_que_wait_timer; /*   240     8 */
	uint64_t                   innodb_innodb_que_wait_timer; /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	ulong                      innodb_page_access;   /*   256     8 */
	ulong                      query_plan_flags;     /*   264     8 */
	ulong                      query_plan_fsort_passes; /*   272     8 */
	SAVEPOINT *                savepoints;           /*   280     8 */
	enum enum_check_fields     count_cuted_fields;   /*   288     4 */

	/* size: 296, cachelines: 5, members: 29 */
	/* sum members: 283, holes: 2, sum holes: 9 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 40 bytes */
};
class Locked_tables_list {
	MEM_ROOT                   m_locked_tables_root; /*     0    88 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	class TABLE_LIST *         m_locked_tables;      /*    88     8 */
	class TABLE_LIST * *       m_locked_tables_last; /*    96     8 */
	class TABLE * *            m_reopen_array;       /*   104     8 */
	size_t                     m_locked_tables_count; /*   112     8 */
public:

	void Locked_tables_list(class Locked_tables_list *);

	void unlock_locked_tables(class Locked_tables_list *, class THD *);

	void ~Locked_tables_list(class Locked_tables_list *, int);

	bool init_locked_tables(class Locked_tables_list *, class THD *);

	class TABLE_LIST * locked_tables(class Locked_tables_list *);

	void unlink_from_list(class Locked_tables_list *, class THD *, class TABLE_LIST *, bool);

	void unlink_all_closed_tables(class Locked_tables_list *, class THD *, MYSQL_LOCK *, size_t);

	bool reopen_tables(class Locked_tables_list *, class THD *);


	/* size: 120, cachelines: 2, members: 5 */
	/* last cacheline: 56 bytes */
};
struct Ha_data {
	void *                     ha_ptr;               /*     0     8 */
	void *                     ha_ptr_backup;        /*     8     8 */
	class Ha_trx_info         ha_info[2];            /*    16    48 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	plugin_ref                 lock;                 /*    64     8 */
	void Ha_data(class Ha_data *);


	/* size: 72, cachelines: 2, members: 4 */
	/* last cacheline: 8 bytes */
};
class Global_read_lock {
	enum enum_grl_state {
		GRL_NONE                       = 0,
		GRL_ACQUIRED                   = 1,
		GRL_ACQUIRED_AND_BLOCKS_COMMIT = 2,
	};

public:

	void Global_read_lock(class Global_read_lock *);

	bool lock_global_read_lock(class Global_read_lock *, class THD *);

	void unlock_global_read_lock(class Global_read_lock *, class THD *);

	bool global_read_lock_active(void);

	bool can_acquire_protection(const class Global_read_lock  *);

	bool make_global_read_lock_block_commit(class Global_read_lock *, class THD *);

	bool is_acquired(const class Global_read_lock  *);

	void set_explicit_lock_duration(class Global_read_lock *, class THD *);

	static volatile int32             m_active_requests; /*     0     0 */
	enum enum_grl_state        m_state;              /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class MDL_ticket *         m_mdl_global_shared_lock; /*     8     8 */
	class MDL_ticket *         m_mdl_blocks_commits_lock; /*    16     8 */

	/* size: 24, cachelines: 1, members: 3, static members: 1 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class Global_backup_lock {
public:

	void Global_backup_lock(class Global_backup_lock *, enum enum_mdl_namespace);

	bool acquire(class Global_backup_lock *, class THD *);

	void release(class Global_backup_lock *, class THD *);

	void set_explicit_locks_duration(class Global_backup_lock *, class THD *);

	bool acquire_protection(class Global_backup_lock *, class THD *, enum enum_mdl_duration, ulong);

	void init_protection_request(const class Global_backup_lock  *, class MDL_request *, enum enum_mdl_duration);

	void release_protection(class Global_backup_lock *, class THD *);

	bool abort_if_acquired(const class Global_backup_lock  *);

	bool is_acquired(const class Global_backup_lock  *);

	bool is_protection_acquired(const class Global_backup_lock  *);

	enum enum_mdl_namespace    m_namespace;          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	class MDL_ticket *         m_lock;               /*     8     8 */
	class MDL_ticket *         m_prot_lock;          /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
class Bloom_filter {
	enum {
		SIZE = 8191,
	};

	typedef struct bitset<8191> Bit_set;

	Bit_set *                  bit_set;              /*     0     8 */
	mysql_mutex_t              LOCK_bit_set;         /*     8    48 */
	void Bloom_filter(class Bloom_filter *, const class Bloom_filter  &);

	class Bloom_filter & operator=(class Bloom_filter *, const class Bloom_filter  &);

public:

	void Bloom_filter(class Bloom_filter *);

	void ~Bloom_filter(class Bloom_filter *, int);

	void clear(class Bloom_filter *);

	bool test_and_set(class Bloom_filter *, ulong);


	/* size: 56, cachelines: 1, members: 2 */
	/* last cacheline: 56 bytes */
};
class base_ilist<Item_change_record> {
	class Item_change_record * first;                /*     0     8 */
	class ilink<Item_change_record> sentinel;        /*     8    24 */
public:

	void empty(class base_ilist<Item_change_record> *);

	void base_ilist(class base_ilist<Item_change_record> *);

	bool is_empty(const class base_ilist<Item_change_record>  *);

	void push_front(class base_ilist<Item_change_record> *, class Item_change_record *);

	void push_back(class base_ilist<Item_change_record> *, class Item_change_record *);

	class Item_change_record * get(class base_ilist<Item_change_record> *);

	class Item_change_record * head(class base_ilist<Item_change_record> *);

	void move_elements_to(class base_ilist<Item_change_record> *, class base_ilist<Item_change_record> *);

	void base_ilist(class base_ilist<Item_change_record> *, const class base_ilist<Item_change_record>  &);

	void operator=(class base_ilist<Item_change_record> *, const class base_ilist<Item_change_record>  &);

	void ~base_ilist(class base_ilist<Item_change_record> *, int);


	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
class Item_change_record : public ilink<Item_change_record> {
public:

	/* class ilink<Item_change_record> <ancestor>; */ /*     0    24 */
	void Item_change_record(class Item_change_record *, const class Item_change_record  &);

	void Item_change_record(class Item_change_record *);

	void Item_change_record(class Item_change_record *, class Item * *, class Item *);

	class Item * *             place;                /*    24     8 */
	class Item *               old_value;            /*    32     8 */
	class Item *               new_value;            /*    40     8 */
	virtual void ~Item_change_record(class Item_change_record *, int);


	/* size: 48, cachelines: 1, members: 4 */
	/* last cacheline: 48 bytes */

	/* BRAIN FART ALERT! 48 bytes != 24 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class ilink<Item_change_record> {
public:

	void ilink(class ilink<Item_change_record> *, const class ilink<Item_change_record>  &);

	int ()(void) * *           _vptr.ilink;          /*     0     8 */
	class Item_change_record * * prev;               /*     8     8 */
	class Item_change_record * next;                 /*    16     8 */
	void ilink(class ilink<Item_change_record> *);

	void unlink(class ilink<Item_change_record> *);

	virtual void ~ilink(class ilink<Item_change_record> *, int);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class Prealloced_array<st_user_var_events*, 2, true> {
	class st_user_var_events * * cast_rawbuff(class Prealloced_array<st_user_var_events*, 2, true> *);

public:

	void Prealloced_array(class Prealloced_array<st_user_var_events*, 2, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<st_user_var_events*, 2, true> *, const class Prealloced_array<st_user_var_events*, 2, true>  &);

	void Prealloced_array(class Prealloced_array<st_user_var_events*, 2, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class st_user_var_events * const * const_iterator;

	class Prealloced_array<st_user_var_events*, 2, true> & operator=(class Prealloced_array<st_user_var_events*, 2, true> *, const class Prealloced_array<st_user_var_events*, 2, true>  &);

	void ~Prealloced_array(class Prealloced_array<st_user_var_events*, 2, true> *, int);

	size_t capacity(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	size_t element_size(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	bool empty(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	size_t size(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	class st_user_var_events * & at(class Prealloced_array<st_user_var_events*, 2, true> *, size_t);

	class st_user_var_events * const & at(const class Prealloced_array<st_user_var_events*, 2, true>  *, size_t);

	class st_user_var_events * & operator[](class Prealloced_array<st_user_var_events*, 2, true> *, size_t);

	class st_user_var_events * const & operator[](const class Prealloced_array<st_user_var_events*, 2, true>  *, size_t);

	class st_user_var_events * & back(class Prealloced_array<st_user_var_events*, 2, true> *);

	class st_user_var_events * const & back(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	class st_user_var_events * & front(class Prealloced_array<st_user_var_events*, 2, true> *);

	class st_user_var_events * const & front(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	typedef class st_user_var_events * * iterator;

	iterator begin(class Prealloced_array<st_user_var_events*, 2, true> *);

	iterator end(class Prealloced_array<st_user_var_events*, 2, true> *);

	const_iterator begin(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	const_iterator end(const class Prealloced_array<st_user_var_events*, 2, true>  *);

	bool reserve(class Prealloced_array<st_user_var_events*, 2, true> *, size_t);

	bool push_back(class Prealloced_array<st_user_var_events*, 2, true> *, class st_user_var_events * const &);

	void pop_back(class Prealloced_array<st_user_var_events*, 2, true> *);

	iterator insert(class Prealloced_array<st_user_var_events*, 2, true> *, iterator, const value_type  &);

	typedef class st_user_var_events * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<st_user_var_events**, bool> insert_unique(class Prealloced_array<st_user_var_events*, 2, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<st_user_var_events*, 2, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<st_user_var_events*, 2, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<st_user_var_events*, 2, true> *, iterator);

	iterator erase(class Prealloced_array<st_user_var_events*, 2, true> *, size_t);

	void erase_at_end(class Prealloced_array<st_user_var_events*, 2, true> *, iterator);

	iterator erase(class Prealloced_array<st_user_var_events*, 2, true> *, iterator, iterator);

	void swap(class Prealloced_array<st_user_var_events*, 2, true> *, class Prealloced_array<st_user_var_events*, 2, true> &);

	void shrink_to_fit(class Prealloced_array<st_user_var_events*, 2, true> *);

	void resize(class Prealloced_array<st_user_var_events*, 2, true> *, size_t, class st_user_var_events * const &);

	void clear(class Prealloced_array<st_user_var_events*, 2, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<16, 8> m_buff __attribute__((__aligned__(8))); /*    16    16 */
	class st_user_var_events * * m_array_ptr;        /*    32     8 */
	PSI_memory_key             m_psi_key;            /*    40     4 */

	/* size: 48, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
struct my_aligned_storage<88, 8> {
	union {
		char                       data[88];             /*     0    88 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[88];             /*     0    88 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0    88 */

	/* size: 88, cachelines: 2, members: 1 */
	/* forced alignments: 1 */
	/* last cacheline: 24 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<long unsigned int, 11, true> {
	long unsigned int * cast_rawbuff(class Prealloced_array<long unsigned int, 11, true> *);

public:

	void Prealloced_array(class Prealloced_array<long unsigned int, 11, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<long unsigned int, 11, true> *, const class Prealloced_array<long unsigned int, 11, true>  &);

	void Prealloced_array(class Prealloced_array<long unsigned int, 11, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const long unsigned int  * const_iterator;

	class Prealloced_array<long unsigned int, 11, true> & operator=(class Prealloced_array<long unsigned int, 11, true> *, const class Prealloced_array<long unsigned int, 11, true>  &);

	void ~Prealloced_array(class Prealloced_array<long unsigned int, 11, true> *, int);

	size_t capacity(const class Prealloced_array<long unsigned int, 11, true>  *);

	size_t element_size(const class Prealloced_array<long unsigned int, 11, true>  *);

	bool empty(const class Prealloced_array<long unsigned int, 11, true>  *);

	size_t size(const class Prealloced_array<long unsigned int, 11, true>  *);

	long unsigned int & at(class Prealloced_array<long unsigned int, 11, true> *, size_t);

	const long unsigned int  & at(const class Prealloced_array<long unsigned int, 11, true>  *, size_t);

	long unsigned int & operator[](class Prealloced_array<long unsigned int, 11, true> *, size_t);

	const long unsigned int  & operator[](const class Prealloced_array<long unsigned int, 11, true>  *, size_t);

	long unsigned int & back(class Prealloced_array<long unsigned int, 11, true> *);

	const long unsigned int  & back(const class Prealloced_array<long unsigned int, 11, true>  *);

	long unsigned int & front(class Prealloced_array<long unsigned int, 11, true> *);

	const long unsigned int  & front(const class Prealloced_array<long unsigned int, 11, true>  *);

	typedef long unsigned int * iterator;

	iterator begin(class Prealloced_array<long unsigned int, 11, true> *);

	iterator end(class Prealloced_array<long unsigned int, 11, true> *);

	const_iterator begin(const class Prealloced_array<long unsigned int, 11, true>  *);

	const_iterator end(const class Prealloced_array<long unsigned int, 11, true>  *);

	bool reserve(class Prealloced_array<long unsigned int, 11, true> *, size_t);

	bool push_back(class Prealloced_array<long unsigned int, 11, true> *, const long unsigned int  &);

	void pop_back(class Prealloced_array<long unsigned int, 11, true> *);

	iterator insert(class Prealloced_array<long unsigned int, 11, true> *, iterator, const value_type  &);

	typedef long unsigned int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<long unsigned int*, bool> insert_unique(class Prealloced_array<long unsigned int, 11, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<long unsigned int, 11, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<long unsigned int, 11, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<long unsigned int, 11, true> *, iterator);

	iterator erase(class Prealloced_array<long unsigned int, 11, true> *, size_t);

	void erase_at_end(class Prealloced_array<long unsigned int, 11, true> *, iterator);

	iterator erase(class Prealloced_array<long unsigned int, 11, true> *, iterator, iterator);

	void swap(class Prealloced_array<long unsigned int, 11, true> *, class Prealloced_array<long unsigned int, 11, true> &);

	void shrink_to_fit(class Prealloced_array<long unsigned int, 11, true> *);

	void resize(class Prealloced_array<long unsigned int, 11, true> *, size_t, const long unsigned int  &);

	void clear(class Prealloced_array<long unsigned int, 11, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<88, 8> m_buff __attribute__((__aligned__(8))); /*    16    88 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	long unsigned int *        m_array_ptr;          /*   104     8 */
	PSI_memory_key             m_psi_key;            /*   112     4 */

	/* size: 120, cachelines: 2, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 56 bytes */
} __attribute__((__aligned__(8)));
class sql_exchange : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	struct Field_separators    field;                /*     0    32 */

	/* XXX last struct has 7 bytes of padding */

	struct Line_separators     line;                 /*    32    16 */
	enum enum_filetype         filetype;             /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              file_name;            /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       dumpfile;             /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	ulong                      skip_lines;           /*    72     8 */
	const CHARSET_INFO  *      cs;                   /*    80     8 */
	void sql_exchange(class sql_exchange *, const char  *, bool, enum enum_filetype);

	bool escaped_given(class sql_exchange *);


	/* size: 88, cachelines: 2, members: 8 */
	/* sum members: 77, holes: 2, sum holes: 11 */
	/* paddings: 2, sum paddings: 8 */
	/* last cacheline: 24 bytes */
};
class List<PT_select_var> : public base_list {
	using ::sort;

public:

	/* class base_list           <ancestor>; */      /*     0    24 */

	/* XXX last struct has 4 bytes of padding */
	void List(class List<PT_select_var> *);

	void List(class List<PT_select_var> *, const class List<PT_select_var>  &);

	class List<PT_select_var> & operator=(class List<PT_select_var> *, const class List<PT_select_var>  &);

	void List(class List<PT_select_var> *, const class List<PT_select_var>  &, MEM_ROOT *);

	bool push_back(class List<PT_select_var> *, class PT_select_var *);

	bool push_back(class List<PT_select_var> *, class PT_select_var *, MEM_ROOT *);

	bool push_front(class List<PT_select_var> *, class PT_select_var *);

	bool push_front(class List<PT_select_var> *, class PT_select_var *, MEM_ROOT *);

	class PT_select_var * head(class List<PT_select_var> *);

	class PT_select_var * * head_ref(class List<PT_select_var> *);

	class PT_select_var * pop(class List<PT_select_var> *);

	void concat(class List<PT_select_var> *, class List<PT_select_var> *);

	void disjoin(class List<PT_select_var> *, class List<PT_select_var> *);

	void prepand(class List<PT_select_var> *, class List<PT_select_var> *);

	void delete_elements(class List<PT_select_var> *);


	/* size: 24, cachelines: 1, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
struct my_aligned_storage<4000, 8> {
	union {
		char                       data[4000];           /*     0  4000 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[4000];           /*     0  4000 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0  4000 */

	/* size: 4000, cachelines: 63, members: 1 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<THD*, 500, true> {
	class THD * * cast_rawbuff(class Prealloced_array<THD*, 500, true> *);

public:

	void Prealloced_array(class Prealloced_array<THD*, 500, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<THD*, 500, true> *, const class Prealloced_array<THD*, 500, true>  &);

	void Prealloced_array(class Prealloced_array<THD*, 500, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class THD * const * const_iterator;

	class Prealloced_array<THD*, 500, true> & operator=(class Prealloced_array<THD*, 500, true> *, const class Prealloced_array<THD*, 500, true>  &);

	void ~Prealloced_array(class Prealloced_array<THD*, 500, true> *, int);

	size_t capacity(const class Prealloced_array<THD*, 500, true>  *);

	size_t element_size(const class Prealloced_array<THD*, 500, true>  *);

	bool empty(const class Prealloced_array<THD*, 500, true>  *);

	size_t size(const class Prealloced_array<THD*, 500, true>  *);

	class THD * & at(class Prealloced_array<THD*, 500, true> *, size_t);

	class THD * const & at(const class Prealloced_array<THD*, 500, true>  *, size_t);

	class THD * & operator[](class Prealloced_array<THD*, 500, true> *, size_t);

	class THD * const & operator[](const class Prealloced_array<THD*, 500, true>  *, size_t);

	class THD * & back(class Prealloced_array<THD*, 500, true> *);

	class THD * const & back(const class Prealloced_array<THD*, 500, true>  *);

	class THD * & front(class Prealloced_array<THD*, 500, true> *);

	class THD * const & front(const class Prealloced_array<THD*, 500, true>  *);

	typedef class THD * * iterator;

	iterator begin(class Prealloced_array<THD*, 500, true> *);

	iterator end(class Prealloced_array<THD*, 500, true> *);

	const_iterator begin(const class Prealloced_array<THD*, 500, true>  *);

	const_iterator end(const class Prealloced_array<THD*, 500, true>  *);

	bool reserve(class Prealloced_array<THD*, 500, true> *, size_t);

	bool push_back(class Prealloced_array<THD*, 500, true> *, class THD * const &);

	void pop_back(class Prealloced_array<THD*, 500, true> *);

	iterator insert(class Prealloced_array<THD*, 500, true> *, iterator, const value_type  &);

	typedef class THD * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<THD**, bool> insert_unique(class Prealloced_array<THD*, 500, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<THD*, 500, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<THD*, 500, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<THD*, 500, true> *, iterator);

	iterator erase(class Prealloced_array<THD*, 500, true> *, size_t);

	void erase_at_end(class Prealloced_array<THD*, 500, true> *, iterator);

	iterator erase(class Prealloced_array<THD*, 500, true> *, iterator, iterator);

	void swap(class Prealloced_array<THD*, 500, true> *, class Prealloced_array<THD*, 500, true> &);

	void shrink_to_fit(class Prealloced_array<THD*, 500, true> *);

	void resize(class Prealloced_array<THD*, 500, true> *, size_t, class THD * const &);

	void clear(class Prealloced_array<THD*, 500, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<4000, 8> m_buff __attribute__((__aligned__(8))); /*    16  4000 */
	/* --- cacheline 62 boundary (3968 bytes) was 48 bytes ago --- */
	class THD * *              m_array_ptr;          /*  4016     8 */
	PSI_memory_key             m_psi_key;            /*  4024     4 */

	/* size: 4032, cachelines: 63, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class Prealloced_array<unsigned int, 1000, true> {
	unsigned int * cast_rawbuff(class Prealloced_array<unsigned int, 1000, true> *);

public:

	void Prealloced_array(class Prealloced_array<unsigned int, 1000, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<unsigned int, 1000, true> *, const class Prealloced_array<unsigned int, 1000, true>  &);

	void Prealloced_array(class Prealloced_array<unsigned int, 1000, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const unsigned int  * const_iterator;

	class Prealloced_array<unsigned int, 1000, true> & operator=(class Prealloced_array<unsigned int, 1000, true> *, const class Prealloced_array<unsigned int, 1000, true>  &);

	void ~Prealloced_array(class Prealloced_array<unsigned int, 1000, true> *, int);

	size_t capacity(const class Prealloced_array<unsigned int, 1000, true>  *);

	size_t element_size(const class Prealloced_array<unsigned int, 1000, true>  *);

	bool empty(const class Prealloced_array<unsigned int, 1000, true>  *);

	size_t size(const class Prealloced_array<unsigned int, 1000, true>  *);

	unsigned int & at(class Prealloced_array<unsigned int, 1000, true> *, size_t);

	const unsigned int  & at(const class Prealloced_array<unsigned int, 1000, true>  *, size_t);

	unsigned int & operator[](class Prealloced_array<unsigned int, 1000, true> *, size_t);

	const unsigned int  & operator[](const class Prealloced_array<unsigned int, 1000, true>  *, size_t);

	unsigned int & back(class Prealloced_array<unsigned int, 1000, true> *);

	const unsigned int  & back(const class Prealloced_array<unsigned int, 1000, true>  *);

	unsigned int & front(class Prealloced_array<unsigned int, 1000, true> *);

	const unsigned int  & front(const class Prealloced_array<unsigned int, 1000, true>  *);

	typedef unsigned int * iterator;

	iterator begin(class Prealloced_array<unsigned int, 1000, true> *);

	iterator end(class Prealloced_array<unsigned int, 1000, true> *);

	const_iterator begin(const class Prealloced_array<unsigned int, 1000, true>  *);

	const_iterator end(const class Prealloced_array<unsigned int, 1000, true>  *);

	bool reserve(class Prealloced_array<unsigned int, 1000, true> *, size_t);

	bool push_back(class Prealloced_array<unsigned int, 1000, true> *, const unsigned int  &);

	void pop_back(class Prealloced_array<unsigned int, 1000, true> *);

	iterator insert(class Prealloced_array<unsigned int, 1000, true> *, iterator, const value_type  &);

	typedef unsigned int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<unsigned int*, bool> insert_unique(class Prealloced_array<unsigned int, 1000, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<unsigned int, 1000, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<unsigned int, 1000, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<unsigned int, 1000, true> *, iterator);

	iterator erase(class Prealloced_array<unsigned int, 1000, true> *, size_t);

	void erase_at_end(class Prealloced_array<unsigned int, 1000, true> *, iterator);

	iterator erase(class Prealloced_array<unsigned int, 1000, true> *, iterator, iterator);

	void swap(class Prealloced_array<unsigned int, 1000, true> *, class Prealloced_array<unsigned int, 1000, true> &);

	void shrink_to_fit(class Prealloced_array<unsigned int, 1000, true> *);

	void resize(class Prealloced_array<unsigned int, 1000, true> *, size_t, const unsigned int  &);

	void clear(class Prealloced_array<unsigned int, 1000, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<4000, 8> m_buff __attribute__((__aligned__(8))); /*    16  4000 */
	/* --- cacheline 62 boundary (3968 bytes) was 48 bytes ago --- */
	unsigned int *             m_array_ptr;          /*  4016     8 */
	PSI_memory_key             m_psi_key;            /*  4024     4 */

	/* size: 4032, cachelines: 63, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class Global_THD_manager {
public:

	static const my_thread_id         reserved_thread_id; /*     0     0 */
	class Global_THD_manager * get_instance(void);

	bool create_instance(void);

	void destroy_instance(void);

	void set_unit_test(class Global_THD_manager *);

	void add_thd(class Global_THD_manager *, class THD *);

	void remove_thd(class Global_THD_manager *, class THD *);

	int get_num_thread_running(const class Global_THD_manager  *);

	void inc_thread_running(class Global_THD_manager *);

	void dec_thread_running(class Global_THD_manager *);

	ulonglong get_num_thread_created(const class Global_THD_manager  *);

	void inc_thread_created(class Global_THD_manager *);

	my_thread_id get_new_thread_id(class Global_THD_manager *);

	void release_thread_id(class Global_THD_manager *, my_thread_id);

	my_thread_id get_thread_id(const class Global_THD_manager  *);

	void set_thread_id_counter(class Global_THD_manager *, my_thread_id);

	uint get_thd_count(const class Global_THD_manager  *);

	void wait_till_no_thd(class Global_THD_manager *);

	void do_for_all_thd_copy(class Global_THD_manager *, class Do_THD_Impl *);

	void do_for_all_thd(class Global_THD_manager *, class Do_THD_Impl *);

	class THD * find_thd(class Global_THD_manager *, class Find_THD_Impl *);

	static int                        global_thd_count; /*     0     0 */
	void Global_THD_manager(class Global_THD_manager *);

	void ~Global_THD_manager(class Global_THD_manager *, int);

	static class Global_THD_manager * thd_manager;   /*     0     0 */
	typedef struct Prealloced_array<THD*, 500, true> THD_array;

	THD_array                  thd_list __attribute__((__aligned__(8))); /*     0  4032 */
	typedef struct Prealloced_array<unsigned int, 1000, true> Thread_id_array;

	/* --- cacheline 63 boundary (4032 bytes) --- */
	Thread_id_array            thread_ids __attribute__((__aligned__(8))); /*  4032  4032 */
	/* --- cacheline 126 boundary (8064 bytes) --- */
	mysql_cond_t               COND_thd_list;        /*  8064    56 */
	mysql_mutex_t              LOCK_thd_list;        /*  8120    48 */
	/* --- cacheline 127 boundary (8128 bytes) was 40 bytes ago --- */
	mysql_mutex_t              LOCK_thd_remove;      /*  8168    48 */
	/* --- cacheline 128 boundary (8192 bytes) was 24 bytes ago --- */
	mysql_mutex_t              LOCK_thread_ids;      /*  8216    48 */
	/* --- cacheline 129 boundary (8256 bytes) was 8 bytes ago --- */
	volatile int32             num_thread_running;   /*  8264     4 */

	/* XXX 4 bytes hole, try to pack */

	volatile int64             thread_created;       /*  8272     8 */
	my_thread_id               thread_id_counter;    /*  8280     4 */
	bool                       unit_test;            /*  8284     1 */

	/* size: 8288, cachelines: 130, members: 10, static members: 3 */
	/* sum members: 8281, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* forced alignments: 2 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Do_THD_Impl {
public:

	int ()(void) * *           _vptr.Do_THD_Impl;    /*     0     8 */
	virtual void ~Do_THD_Impl(class Do_THD_Impl *, int);

	virtual void operator()(class Do_THD_Impl *, class THD *);

	/* vtable has 1 entries: {
	   [2] = operator()((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Find_THD_Impl {
public:

	void Find_THD_Impl(class Find_THD_Impl *, const class Find_THD_Impl  &);

	void Find_THD_Impl(class Find_THD_Impl *);

	int ()(void) * *           _vptr.Find_THD_Impl;  /*     0     8 */
	virtual void ~Find_THD_Impl(class Find_THD_Impl *, int);

	virtual bool operator()(class Find_THD_Impl *, class THD *);

	/* vtable has 1 entries: {
	   [2] = operator()((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class List_iterator<Item> : public base_list_iterator {
public:

	/* class base_list_iterator  <ancestor>; */      /*     0    32 */
	void List_iterator(class List_iterator<Item> *, class List<Item> &);

	void List_iterator(class List_iterator<Item> *);

	void init(class List_iterator<Item> *, class List<Item> &);

	class Item * operator++(class List_iterator<Item> *, int);

	class Item * replace(class List_iterator<Item> *, class Item *);

	class Item * replace(class List_iterator<Item> *, class List<Item> &);

	void rewind(class List_iterator<Item> *);

	void remove(class List_iterator<Item> *);

	void after(class List_iterator<Item> *, class Item *);

	bool after(class List_iterator<Item> *, class Item *, MEM_ROOT *);

	class Item * * ref(class List_iterator<Item> *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
struct st_table_rule_ent {
	char *                     db;                   /*     0     8 */
	char *                     tbl_name;             /*     8     8 */
	uint                       key_len;              /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
class Prealloced_array<st_table_rule_ent*, 16, true> {
	class st_table_rule_ent * * cast_rawbuff(class Prealloced_array<st_table_rule_ent*, 16, true> *);

public:

	void Prealloced_array(class Prealloced_array<st_table_rule_ent*, 16, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<st_table_rule_ent*, 16, true> *, const class Prealloced_array<st_table_rule_ent*, 16, true>  &);

	void Prealloced_array(class Prealloced_array<st_table_rule_ent*, 16, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class st_table_rule_ent * const * const_iterator;

	class Prealloced_array<st_table_rule_ent*, 16, true> & operator=(class Prealloced_array<st_table_rule_ent*, 16, true> *, const class Prealloced_array<st_table_rule_ent*, 16, true>  &);

	void ~Prealloced_array(class Prealloced_array<st_table_rule_ent*, 16, true> *, int);

	size_t capacity(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	size_t element_size(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	bool empty(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	size_t size(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	class st_table_rule_ent * & at(class Prealloced_array<st_table_rule_ent*, 16, true> *, size_t);

	class st_table_rule_ent * const & at(const class Prealloced_array<st_table_rule_ent*, 16, true>  *, size_t);

	class st_table_rule_ent * & operator[](class Prealloced_array<st_table_rule_ent*, 16, true> *, size_t);

	class st_table_rule_ent * const & operator[](const class Prealloced_array<st_table_rule_ent*, 16, true>  *, size_t);

	class st_table_rule_ent * & back(class Prealloced_array<st_table_rule_ent*, 16, true> *);

	class st_table_rule_ent * const & back(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	class st_table_rule_ent * & front(class Prealloced_array<st_table_rule_ent*, 16, true> *);

	class st_table_rule_ent * const & front(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	typedef class st_table_rule_ent * * iterator;

	iterator begin(class Prealloced_array<st_table_rule_ent*, 16, true> *);

	iterator end(class Prealloced_array<st_table_rule_ent*, 16, true> *);

	const_iterator begin(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	const_iterator end(const class Prealloced_array<st_table_rule_ent*, 16, true>  *);

	bool reserve(class Prealloced_array<st_table_rule_ent*, 16, true> *, size_t);

	bool push_back(class Prealloced_array<st_table_rule_ent*, 16, true> *, class st_table_rule_ent * const &);

	void pop_back(class Prealloced_array<st_table_rule_ent*, 16, true> *);

	iterator insert(class Prealloced_array<st_table_rule_ent*, 16, true> *, iterator, const value_type  &);

	typedef class st_table_rule_ent * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<st_table_rule_ent**, bool> insert_unique(class Prealloced_array<st_table_rule_ent*, 16, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<st_table_rule_ent*, 16, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<st_table_rule_ent*, 16, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<st_table_rule_ent*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<st_table_rule_ent*, 16, true> *, size_t);

	void erase_at_end(class Prealloced_array<st_table_rule_ent*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<st_table_rule_ent*, 16, true> *, iterator, iterator);

	void swap(class Prealloced_array<st_table_rule_ent*, 16, true> *, class Prealloced_array<st_table_rule_ent*, 16, true> &);

	void shrink_to_fit(class Prealloced_array<st_table_rule_ent*, 16, true> *);

	void resize(class Prealloced_array<st_table_rule_ent*, 16, true> *, size_t, class st_table_rule_ent * const &);

	void clear(class Prealloced_array<st_table_rule_ent*, 16, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<128, 8> m_buff __attribute__((__aligned__(8))); /*    16   128 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class st_table_rule_ent * * m_array_ptr;         /*   144     8 */
	PSI_memory_key             m_psi_key;            /*   152     4 */

	/* size: 160, cachelines: 3, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class base_ilist<i_string> {
	class i_string *           first;                /*     0     8 */
	class ilink<i_string>     sentinel;              /*     8    24 */
public:

	void empty(class base_ilist<i_string> *);

	void base_ilist(class base_ilist<i_string> *);

	bool is_empty(const class base_ilist<i_string>  *);

	void push_front(class base_ilist<i_string> *, class i_string *);

	void push_back(class base_ilist<i_string> *, class i_string *);

	class i_string * get(class base_ilist<i_string> *);

	class i_string * head(class base_ilist<i_string> *);

	void move_elements_to(class base_ilist<i_string> *, class base_ilist<i_string> *);

	void base_ilist(class base_ilist<i_string> *, const class base_ilist<i_string>  &);

	void operator=(class base_ilist<i_string> *, const class base_ilist<i_string>  &);


	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
class i_string : public ilink<i_string> {
public:

	/* class ilink<i_string>     <ancestor>; */      /*     0    24 */
	const char  *              ptr;                  /*    24     8 */
	void i_string(class i_string *);

	void i_string(class i_string *, const char  *);

	virtual void ~i_string(class i_string *, int);


	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class ilink<i_string> {
public:

	void ilink(class ilink<i_string> *, const class ilink<i_string>  &);

	int ()(void) * *           _vptr.ilink;          /*     0     8 */
	class i_string * *         prev;                 /*     8     8 */
	class i_string *           next;                 /*    16     8 */
	void ilink(class ilink<i_string> *);

	void unlink(class ilink<i_string> *);

	virtual void ~ilink(class ilink<i_string> *, int);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class I_List<i_string> : base_ilist<i_string> {
	using ::empty;

	using ::is_empty;

	using ::get;

	using ::push_front;

	using ::push_back;

	using ::head;

	/* class base_ilist<i_string> <ancestor>; */     /*     0    32 */
public:

	void move_elements_to(class I_List<i_string> *, class I_List<i_string> *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class base_ilist<i_string_pair> {
	class i_string_pair *      first;                /*     0     8 */
	class ilink<i_string_pair> sentinel;             /*     8    24 */
public:

	void empty(class base_ilist<i_string_pair> *);

	void base_ilist(class base_ilist<i_string_pair> *);

	bool is_empty(const class base_ilist<i_string_pair>  *);

	void push_front(class base_ilist<i_string_pair> *, class i_string_pair *);

	void push_back(class base_ilist<i_string_pair> *, class i_string_pair *);

	class i_string_pair * get(class base_ilist<i_string_pair> *);

	class i_string_pair * head(class base_ilist<i_string_pair> *);

	void move_elements_to(class base_ilist<i_string_pair> *, class base_ilist<i_string_pair> *);

	void base_ilist(class base_ilist<i_string_pair> *, const class base_ilist<i_string_pair>  &);

	void operator=(class base_ilist<i_string_pair> *, const class base_ilist<i_string_pair>  &);


	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
class i_string_pair : public ilink<i_string_pair> {
public:

	/* class ilink<i_string_pair> <ancestor>; */     /*     0    24 */
	const char  *              key;                  /*    24     8 */
	const char  *              val;                  /*    32     8 */
	void i_string_pair(class i_string_pair *);

	void i_string_pair(class i_string_pair *, const char  *, const char  *);

	virtual void ~i_string_pair(class i_string_pair *, int);


	/* size: 40, cachelines: 1, members: 3 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 40 bytes != 16 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class ilink<i_string_pair> {
public:

	void ilink(class ilink<i_string_pair> *, const class ilink<i_string_pair>  &);

	int ()(void) * *           _vptr.ilink;          /*     0     8 */
	class i_string_pair * *    prev;                 /*     8     8 */
	class i_string_pair *      next;                 /*    16     8 */
	void ilink(class ilink<i_string_pair> *);

	void unlink(class ilink<i_string_pair> *);

	virtual void ~ilink(class ilink<i_string_pair> *, int);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class I_List<i_string_pair> : base_ilist<i_string_pair> {
	using ::empty;

	using ::is_empty;

	using ::get;

	using ::push_front;

	using ::push_back;

	using ::head;

	/* class base_ilist<i_string_pair> <ancestor>; */ /*     0    32 */
public:

	void move_elements_to(class I_List<i_string_pair> *, class I_List<i_string_pair> *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Rpl_filter {
public:

	void Rpl_filter(class Rpl_filter *);

	void ~Rpl_filter(class Rpl_filter *, int);

	void Rpl_filter(class Rpl_filter *, const class Rpl_filter  &);

	class Rpl_filter & operator=(class Rpl_filter *, const class Rpl_filter  &);

	bool tables_ok(class Rpl_filter *, const char  *, class TABLE_LIST *);

	bool db_ok(class Rpl_filter *, const char  *);

	bool db_ok_with_wild_table(class Rpl_filter *, const char  *);

	bool is_on(class Rpl_filter *);

	bool is_rewrite_empty(class Rpl_filter *);

	int build_do_table_hash(class Rpl_filter *);

	int build_ignore_table_hash(class Rpl_filter *);

	int add_string_list(class Rpl_filter *, class I_List<i_string> *, const char  *);

	int add_string_pair_list(class Rpl_filter *, class I_List<i_string_pair> *, char *, char *);

	int add_do_table_array(class Rpl_filter *, const char  *);

	int add_ignore_table_array(class Rpl_filter *, const char  *);

	int add_wild_do_table(class Rpl_filter *, const char  *);

	int add_wild_ignore_table(class Rpl_filter *, const char  *);

	int set_do_db(class Rpl_filter *, class List<Item> *);

	int set_ignore_db(class Rpl_filter *, class List<Item> *);

	int set_do_table(class Rpl_filter *, class List<Item> *);

	int set_ignore_table(class Rpl_filter *, class List<Item> *);

	int set_wild_do_table(class Rpl_filter *, class List<Item> *);

	int set_wild_ignore_table(class Rpl_filter *, class List<Item> *);

	int set_db_rewrite(class Rpl_filter *, class List<Item> *);

	int parse_filter_list(class Rpl_filter *, class List<Item> *, Add_filter);

	typedef int ()(class Rpl_filter *, const char  *) Rpl_filter::* Add_filter;

	int add_do_db(class Rpl_filter *, const char  *);

	int add_ignore_db(class Rpl_filter *, const char  *);

	int add_db_rewrite(class Rpl_filter *, const char  *, const char  *);

	void get_do_table(class Rpl_filter *, class String *);

	void get_ignore_table(class Rpl_filter *, class String *);

	void get_wild_do_table(class Rpl_filter *, class String *);

	void get_wild_ignore_table(class Rpl_filter *, class String *);

	const char  * get_rewrite_db(class Rpl_filter *, const char  *, size_t *);

	void get_rewrite_db(class Rpl_filter *, class String *);

	class I_List<i_string> * get_do_db(class Rpl_filter *);

	class I_List<i_string> * get_ignore_db(class Rpl_filter *);

	void free_string_list(class Rpl_filter *, class I_List<i_string> *);

	void free_string_pair_list(class Rpl_filter *, class I_List<i_string_pair> *);

	bool                       table_rules_on;       /*     0     1 */

	/* XXX 7 bytes hole, try to pack */
	void init_table_rule_hash(class Rpl_filter *, HASH *, bool *);

	void init_table_rule_array(class Rpl_filter *, Table_rule_array *, bool *);

	typedef struct Prealloced_array<st_table_rule_ent*, 16, true> Table_rule_array;

	int add_table_rule_to_array(class Rpl_filter *, Table_rule_array *, const char  *);

	int add_table_rule_to_hash(class Rpl_filter *, HASH *, const char  *, uint);

	void free_string_array(class Rpl_filter *, Table_rule_array *);

	void table_rule_ent_hash_to_str(class Rpl_filter *, class String *, HASH *, bool);

	void table_rule_ent_dynamic_array_to_str(class Rpl_filter *, class String *, Table_rule_array *, bool);

	TABLE_RULE_ENT * find_wild(class Rpl_filter *, Table_rule_array *, const char  *, size_t);

	int build_table_hash_from_array(class Rpl_filter *, Table_rule_array *, HASH *, bool, bool *);


	HASH                       do_table_hash;        /*     8   112 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	HASH                       ignore_table_hash;    /*   120   112 */
	/* --- cacheline 3 boundary (192 bytes) was 40 bytes ago --- */
	Table_rule_array           do_table_array __attribute__((__aligned__(8))); /*   232   160 */
	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
	Table_rule_array           ignore_table_array __attribute__((__aligned__(8))); /*   392   160 */
	/* --- cacheline 8 boundary (512 bytes) was 40 bytes ago --- */
	Table_rule_array           wild_do_table __attribute__((__aligned__(8))); /*   552   160 */
	/* --- cacheline 11 boundary (704 bytes) was 8 bytes ago --- */
	Table_rule_array           wild_ignore_table __attribute__((__aligned__(8))); /*   712   160 */
	/* --- cacheline 13 boundary (832 bytes) was 40 bytes ago --- */
	bool                       do_table_hash_inited; /*   872     1 */
	bool                       ignore_table_hash_inited; /*   873     1 */
	bool                       do_table_array_inited; /*   874     1 */
	bool                       ignore_table_array_inited; /*   875     1 */
	bool                       wild_do_table_inited; /*   876     1 */
	bool                       wild_ignore_table_inited; /*   877     1 */

	/* XXX 2 bytes hole, try to pack */

	class I_List<i_string>    do_db;                 /*   880    32 */
	/* --- cacheline 14 boundary (896 bytes) was 16 bytes ago --- */
	class I_List<i_string>    ignore_db;             /*   912    32 */
	class I_List<i_string_pair> rewrite_db;          /*   944    32 */

	/* size: 976, cachelines: 16, members: 16 */
	/* sum members: 967, holes: 2, sum holes: 9 */
	/* forced alignments: 4 */
	/* last cacheline: 16 bytes */
} __attribute__((__aligned__(8)));
class TC_LOG {
	enum enum_result {
		RESULT_SUCCESS      = 0,
		RESULT_ABORTED      = 1,
		RESULT_INCONSISTENT = 2,
	};

public:

	void TC_LOG(class TC_LOG *, const class TC_LOG  &);

	int ()(void) * *           _vptr.TC_LOG;         /*     0     8 */
	bool using_heuristic_recover(class TC_LOG *);

	void TC_LOG(class TC_LOG *);

	virtual void ~TC_LOG(class TC_LOG *, int);

	virtual int open(class TC_LOG *, const char  *);

	virtual void close(class TC_LOG *);

	virtual enum enum_result commit(class TC_LOG *, class THD *, bool);

	virtual int rollback(class TC_LOG *, class THD *, bool);

	virtual int prepare(class TC_LOG *, class THD *, bool);

	virtual void xlock(class TC_LOG *);

	virtual void xunlock(class TC_LOG *);

	virtual void slock(class TC_LOG *);

	virtual void sunlock(class TC_LOG *);

	/* vtable has 9 entries: {
	   [2] = open((null)), 
	   [3] = close((null)), 
	   [4] = commit((null)), 
	   [5] = rollback((null)), 
	   [6] = prepare((null)), 
	   [7] = xlock((null)), 
	   [8] = xunlock((null)), 
	   [9] = slock((null)), 
	   [10] = sunlock((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Prealloced_array<Slave_worker*, 4, true> {
	class Slave_worker * * cast_rawbuff(class Prealloced_array<Slave_worker*, 4, true> *);

public:

	void Prealloced_array(class Prealloced_array<Slave_worker*, 4, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Slave_worker*, 4, true> *, const class Prealloced_array<Slave_worker*, 4, true>  &);

	void Prealloced_array(class Prealloced_array<Slave_worker*, 4, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Slave_worker * const * const_iterator;

	class Prealloced_array<Slave_worker*, 4, true> & operator=(class Prealloced_array<Slave_worker*, 4, true> *, const class Prealloced_array<Slave_worker*, 4, true>  &);

	void ~Prealloced_array(class Prealloced_array<Slave_worker*, 4, true> *, int);

	size_t capacity(const class Prealloced_array<Slave_worker*, 4, true>  *);

	size_t element_size(const class Prealloced_array<Slave_worker*, 4, true>  *);

	bool empty(const class Prealloced_array<Slave_worker*, 4, true>  *);

	size_t size(const class Prealloced_array<Slave_worker*, 4, true>  *);

	class Slave_worker * & at(class Prealloced_array<Slave_worker*, 4, true> *, size_t);

	class Slave_worker * const & at(const class Prealloced_array<Slave_worker*, 4, true>  *, size_t);

	class Slave_worker * & operator[](class Prealloced_array<Slave_worker*, 4, true> *, size_t);

	class Slave_worker * const & operator[](const class Prealloced_array<Slave_worker*, 4, true>  *, size_t);

	class Slave_worker * & back(class Prealloced_array<Slave_worker*, 4, true> *);

	class Slave_worker * const & back(const class Prealloced_array<Slave_worker*, 4, true>  *);

	class Slave_worker * & front(class Prealloced_array<Slave_worker*, 4, true> *);

	class Slave_worker * const & front(const class Prealloced_array<Slave_worker*, 4, true>  *);

	typedef class Slave_worker * * iterator;

	iterator begin(class Prealloced_array<Slave_worker*, 4, true> *);

	iterator end(class Prealloced_array<Slave_worker*, 4, true> *);

	const_iterator begin(const class Prealloced_array<Slave_worker*, 4, true>  *);

	const_iterator end(const class Prealloced_array<Slave_worker*, 4, true>  *);

	bool reserve(class Prealloced_array<Slave_worker*, 4, true> *, size_t);

	bool push_back(class Prealloced_array<Slave_worker*, 4, true> *, class Slave_worker * const &);

	void pop_back(class Prealloced_array<Slave_worker*, 4, true> *);

	iterator insert(class Prealloced_array<Slave_worker*, 4, true> *, iterator, const value_type  &);

	typedef class Slave_worker * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<Slave_worker**, bool> insert_unique(class Prealloced_array<Slave_worker*, 4, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Slave_worker*, 4, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Slave_worker*, 4, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<Slave_worker*, 4, true> *, iterator);

	iterator erase(class Prealloced_array<Slave_worker*, 4, true> *, size_t);

	void erase_at_end(class Prealloced_array<Slave_worker*, 4, true> *, iterator);

	iterator erase(class Prealloced_array<Slave_worker*, 4, true> *, iterator, iterator);

	void swap(class Prealloced_array<Slave_worker*, 4, true> *, class Prealloced_array<Slave_worker*, 4, true> &);

	void shrink_to_fit(class Prealloced_array<Slave_worker*, 4, true> *);

	void resize(class Prealloced_array<Slave_worker*, 4, true> *, size_t, class Slave_worker * const &);

	void clear(class Prealloced_array<Slave_worker*, 4, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<32, 8> m_buff __attribute__((__aligned__(8))); /*    16    32 */
	class Slave_worker * *     m_array_ptr;          /*    48     8 */
	PSI_memory_key             m_psi_key;            /*    56     4 */

	/* size: 64, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
struct my_aligned_storage<256, 8> {
	union {
		char                       data[256];            /*     0   256 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[256];            /*     0   256 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0   256 */

	/* size: 256, cachelines: 4, members: 1 */
	/* forced alignments: 1 */
} __attribute__((__aligned__(8)));
class Prealloced_array<Log_event*, 32, true> {
	class Log_event * * cast_rawbuff(class Prealloced_array<Log_event*, 32, true> *);

public:

	void Prealloced_array(class Prealloced_array<Log_event*, 32, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<Log_event*, 32, true> *, const class Prealloced_array<Log_event*, 32, true>  &);

	void Prealloced_array(class Prealloced_array<Log_event*, 32, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Log_event * const * const_iterator;

	class Prealloced_array<Log_event*, 32, true> & operator=(class Prealloced_array<Log_event*, 32, true> *, const class Prealloced_array<Log_event*, 32, true>  &);

	void ~Prealloced_array(class Prealloced_array<Log_event*, 32, true> *, int);

	size_t capacity(const class Prealloced_array<Log_event*, 32, true>  *);

	size_t element_size(const class Prealloced_array<Log_event*, 32, true>  *);

	bool empty(const class Prealloced_array<Log_event*, 32, true>  *);

	size_t size(const class Prealloced_array<Log_event*, 32, true>  *);

	class Log_event * & at(class Prealloced_array<Log_event*, 32, true> *, size_t);

	class Log_event * const & at(const class Prealloced_array<Log_event*, 32, true>  *, size_t);

	class Log_event * & operator[](class Prealloced_array<Log_event*, 32, true> *, size_t);

	class Log_event * const & operator[](const class Prealloced_array<Log_event*, 32, true>  *, size_t);

	class Log_event * & back(class Prealloced_array<Log_event*, 32, true> *);

	class Log_event * const & back(const class Prealloced_array<Log_event*, 32, true>  *);

	class Log_event * & front(class Prealloced_array<Log_event*, 32, true> *);

	class Log_event * const & front(const class Prealloced_array<Log_event*, 32, true>  *);

	typedef class Log_event * * iterator;

	iterator begin(class Prealloced_array<Log_event*, 32, true> *);

	iterator end(class Prealloced_array<Log_event*, 32, true> *);

	const_iterator begin(const class Prealloced_array<Log_event*, 32, true>  *);

	const_iterator end(const class Prealloced_array<Log_event*, 32, true>  *);

	bool reserve(class Prealloced_array<Log_event*, 32, true> *, size_t);

	bool push_back(class Prealloced_array<Log_event*, 32, true> *, class Log_event * const &);

	void pop_back(class Prealloced_array<Log_event*, 32, true> *);

	iterator insert(class Prealloced_array<Log_event*, 32, true> *, iterator, const value_type  &);

	typedef class Log_event * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<Log_event**, bool> insert_unique(class Prealloced_array<Log_event*, 32, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<Log_event*, 32, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<Log_event*, 32, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<Log_event*, 32, true> *, iterator);

	iterator erase(class Prealloced_array<Log_event*, 32, true> *, size_t);

	void erase_at_end(class Prealloced_array<Log_event*, 32, true> *, iterator);

	iterator erase(class Prealloced_array<Log_event*, 32, true> *, iterator, iterator);

	void swap(class Prealloced_array<Log_event*, 32, true> *, class Prealloced_array<Log_event*, 32, true> &);

	void shrink_to_fit(class Prealloced_array<Log_event*, 32, true> *);

	void resize(class Prealloced_array<Log_event*, 32, true> *, size_t, class Log_event * const &);

	void clear(class Prealloced_array<Log_event*, 32, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<256, 8> m_buff __attribute__((__aligned__(8))); /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	class Log_event * *        m_array_ptr;          /*   272     8 */
	PSI_memory_key             m_psi_key;            /*   280     4 */

	/* size: 288, cachelines: 5, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Deferred_log_events {
	class Prealloced_array<Log_event*, 32, true> m_array __attribute__((__aligned__(8))); /*     0   288 */

	/* XXX last struct has 4 bytes of padding */
public:

	void Deferred_log_events(class Deferred_log_events *, class Relay_log_info *);

	void ~Deferred_log_events(class Deferred_log_events *, int);

	int add(class Deferred_log_events *, class Log_event *);

	bool is_empty(class Deferred_log_events *);

	bool execute(class Deferred_log_events *, class Relay_log_info *);

	void rewind(class Deferred_log_events *);


	/* size: 288, cachelines: 5, members: 1 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class sp_rcontext : public Sql_alloc {
	class sp_handler_entry {
	public:

		const class sp_handler  *  handler;              /*     0     8 */
		uint                       first_ip;             /*     8     4 */
		void sp_handler_entry(class sp_handler_entry *, const class sp_handler  *, uint);


		/* size: 16, cachelines: 1, members: 2 */
		/* padding: 4 */
		/* last cacheline: 16 bytes */
	};

	class Handler_call_frame {
	public:

		const class sp_handler  *  handler;              /*     0     8 */
		class Sql_condition *      sql_condition;        /*     8     8 */
		uint                       continue_ip;          /*    16     4 */

		/* XXX 4 bytes hole, try to pack */

		class Diagnostics_area    handler_da;            /*    24   744 */
		void Handler_call_frame(class Handler_call_frame *, const class sp_handler  *, class Sql_condition *, uint);


		/* size: 768, cachelines: 12, members: 4 */
		/* sum members: 764, holes: 1, sum holes: 4 */
	};

public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	class sp_rcontext * create(class THD *, const class sp_pcontext  *, class Field *);

	void ~sp_rcontext(class sp_rcontext *, int);

	void sp_rcontext(class sp_rcontext *, const class sp_pcontext  *, class Field *, bool);

	void sp_rcontext(class sp_rcontext *, const class sp_rcontext  &);

	void operator=(class sp_rcontext *, class sp_rcontext &);


	class Query_arena *        callers_arena;        /*     0     8 */
	bool                       end_partial_result_set; /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	class sp_head *            sp;                   /*    16     8 */
	bool set_variable(class sp_rcontext *, class THD *, uint, class Item * *);

	class Item * get_item(const class sp_rcontext  *, uint);

	class Item * * get_item_addr(const class sp_rcontext  *, uint);

	bool set_return_value(class sp_rcontext *, class THD *, class Item * *);

	bool is_return_value_set(const class sp_rcontext  *);

	bool push_handler(class sp_rcontext *, class sp_handler *, uint);

	void pop_handlers(class sp_rcontext *, class sp_pcontext *);

	class Handler_call_frame * current_handler_frame(const class sp_rcontext  *);

	bool handle_sql_condition(class sp_rcontext *, class THD *, uint *, const class sp_instr  *);

	void exit_handler(class sp_rcontext *, class THD *, class sp_pcontext *);

	uint get_last_handler_continue_ip(const class sp_rcontext  *);

	bool push_cursor(class sp_rcontext *, class sp_instr_cpush *);

	void pop_cursors(class sp_rcontext *, uint);

	void pop_all_cursors(class sp_rcontext *);

	class sp_cursor * get_cursor(const class sp_rcontext  *, uint);

	bool set_case_expr(class sp_rcontext *, class THD *, int, class Item * *);

	class Item * get_case_expr(const class sp_rcontext  *, int);

	class Item * * get_case_expr_addr(const class sp_rcontext  *, int);

	bool alloc_arrays(class sp_rcontext *, class THD *);

	bool init_var_table(class sp_rcontext *, class THD *);

	bool init_var_items(class sp_rcontext *, class THD *);

	class Item_cache * create_case_expr_holder(const class sp_rcontext  *, class THD *, const class Item  *);

	bool set_variable(class sp_rcontext *, class THD *, class Field *, class Item * *);

	void pop_handler_frame(class sp_rcontext *, class THD *);

	const class sp_pcontext  * m_root_parsing_ctx;   /*    24     8 */
	class TABLE *              m_var_table;          /*    32     8 */
	class Bounds_checked_array<Item*> m_var_items;   /*    40    16 */
	class Field *              m_return_value_fld;   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	bool                       m_return_value_set;   /*    64     1 */
	bool                       m_in_sub_stmt;        /*    65     1 */

	/* XXX 6 bytes hole, try to pack */

	class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> m_visible_handlers __attribute__((__aligned__(8))); /*    72   160 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 3 boundary (192 bytes) was 40 bytes ago --- */
	class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> m_activated_handlers __attribute__((__aligned__(8))); /*   232   160 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
	class Bounds_checked_array<sp_cursor*> m_cstack; /*   392    16 */
	uint                       m_ccount;             /*   408     4 */

	/* XXX 4 bytes hole, try to pack */

	class Bounds_checked_array<Item_cache*> m_case_expr_holders; /*   416    16 */

	/* size: 432, cachelines: 7, members: 15 */
	/* sum members: 415, holes: 3, sum holes: 17 */
	/* paddings: 3, sum paddings: 9 */
	/* forced alignments: 2, forced holes: 1, sum forced holes: 6 */
	/* last cacheline: 48 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> {
	class sp_handler_entry * * cast_rawbuff(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

public:

	void Prealloced_array(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  &);

	void Prealloced_array(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class sp_handler_entry * const * const_iterator;

	class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> & operator=(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  &);

	void ~Prealloced_array(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, int);

	size_t capacity(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	size_t element_size(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	bool empty(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	size_t size(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	class sp_handler_entry * & at(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, size_t);

	class sp_handler_entry * const & at(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *, size_t);

	class sp_handler_entry * & operator[](class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, size_t);

	class sp_handler_entry * const & operator[](const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *, size_t);

	class sp_handler_entry * & back(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

	class sp_handler_entry * const & back(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	class sp_handler_entry * & front(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

	class sp_handler_entry * const & front(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	typedef class sp_handler_entry * * iterator;

	iterator begin(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

	iterator end(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

	const_iterator begin(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	const_iterator end(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *);

	bool reserve(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, size_t);

	bool push_back(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, class sp_handler_entry * const &);

	void pop_back(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

	iterator insert(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, iterator, const value_type  &);

	typedef class sp_handler_entry * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<sp_rcontext::sp_handler_entry**, bool> insert_unique(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, size_t);

	void erase_at_end(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, iterator, iterator);

	void swap(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> &);

	void shrink_to_fit(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

	void resize(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *, size_t, class sp_handler_entry * const &);

	void clear(class Prealloced_array<sp_rcontext::sp_handler_entry*, 16, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<128, 8> m_buff __attribute__((__aligned__(8))); /*    16   128 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class sp_handler_entry * * m_array_ptr;          /*   144     8 */
	PSI_memory_key             m_psi_key;            /*   152     4 */

	/* size: 160, cachelines: 3, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> {
	class Handler_call_frame * * cast_rawbuff(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

public:

	void Prealloced_array(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  &);

	void Prealloced_array(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef class Handler_call_frame * const * const_iterator;

	class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> & operator=(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  &);

	void ~Prealloced_array(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, int);

	size_t capacity(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	size_t element_size(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	bool empty(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	size_t size(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	class Handler_call_frame * & at(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, size_t);

	class Handler_call_frame * const & at(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *, size_t);

	class Handler_call_frame * & operator[](class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, size_t);

	class Handler_call_frame * const & operator[](const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *, size_t);

	class Handler_call_frame * & back(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

	class Handler_call_frame * const & back(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	class Handler_call_frame * & front(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

	class Handler_call_frame * const & front(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	typedef class Handler_call_frame * * iterator;

	iterator begin(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

	iterator end(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

	const_iterator begin(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	const_iterator end(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *);

	bool reserve(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, size_t);

	bool push_back(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, class Handler_call_frame * const &);

	void pop_back(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

	iterator insert(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, iterator, const value_type  &);

	typedef class Handler_call_frame * value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<sp_rcontext::Handler_call_frame**, bool> insert_unique(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, size_t);

	void erase_at_end(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, iterator);

	iterator erase(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, iterator, iterator);

	void swap(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> &);

	void shrink_to_fit(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

	void resize(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *, size_t, class Handler_call_frame * const &);

	void clear(class Prealloced_array<sp_rcontext::Handler_call_frame*, 16, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<128, 8> m_buff __attribute__((__aligned__(8))); /*    16   128 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	class Handler_call_frame * * m_array_ptr;        /*   144     8 */
	PSI_memory_key             m_psi_key;            /*   152     4 */

	/* size: 160, cachelines: 3, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Bounds_checked_array<sp_cursor*> {
public:

	void Bounds_checked_array(class Bounds_checked_array<sp_cursor*> *);

	void Bounds_checked_array(class Bounds_checked_array<sp_cursor*> *, class sp_cursor * *, size_t);

	void reset(class Bounds_checked_array<sp_cursor*> *);

	void reset(class Bounds_checked_array<sp_cursor*> *, class sp_cursor * *, size_t);

	void resize(class Bounds_checked_array<sp_cursor*> *, size_t);

	class sp_cursor * & operator[](class Bounds_checked_array<sp_cursor*> *, size_t);

	class sp_cursor * const & operator[](const class Bounds_checked_array<sp_cursor*>  *, size_t);

	typedef class sp_cursor * * iterator;

	iterator begin(class Bounds_checked_array<sp_cursor*> *);

	iterator end(class Bounds_checked_array<sp_cursor*> *);

	typedef class sp_cursor * const * const_iterator;

	const_iterator begin(const class Bounds_checked_array<sp_cursor*>  *);

	const_iterator end(const class Bounds_checked_array<sp_cursor*>  *);

	size_t element_size(const class Bounds_checked_array<sp_cursor*>  *);

	size_t size(const class Bounds_checked_array<sp_cursor*>  *);

	bool is_null(const class Bounds_checked_array<sp_cursor*>  *);

	void pop_front(class Bounds_checked_array<sp_cursor*> *);

	class sp_cursor * * array(const class Bounds_checked_array<sp_cursor*>  *);

	bool operator==(const class Bounds_checked_array<sp_cursor*>  *, const class Bounds_checked_array<sp_cursor*>  &);

	bool operator!=(const class Bounds_checked_array<sp_cursor*>  *, const class Bounds_checked_array<sp_cursor*>  &);

	class sp_cursor * *        m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class sp_cursor {
public:

	int ()(void) * *           _vptr.sp_cursor;      /*     0     8 */
	void sp_cursor(class sp_cursor *, class sp_instr_cpush *);

	virtual void ~sp_cursor(class sp_cursor *, int);

	bool open(class sp_cursor *, class THD *);

	bool close(class sp_cursor *, class THD *);

	bool is_open(const class sp_cursor  *);

	bool fetch(class sp_cursor *, class THD *, class List<sp_variable> *);

	class sp_instr_cpush * get_push_instr(class sp_cursor *);

	class Query_fetch_into_spvars {
	public:

		virtual void ~Query_fetch_into_spvars(class Query_fetch_into_spvars *, int);

		virtual bool send_eof(class Query_fetch_into_spvars *);

		/* vtable has 1 entries: {
		   [11] = send_eof((null)), 
		} */
		/* size: 0, cachelines: 0, members: 0 */
	};

	class Query_fetch_into_spvars m_result;          /*     8     0 */

	/* XXX 48 bytes hole, try to pack */

	class Server_side_cursor * m_server_side_cursor; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	class sp_instr_cpush *     m_push_instr;         /*    64     8 */
	void destroy(class sp_cursor *);


	/* size: 72, cachelines: 2, members: 4 */
	/* sum members: 24, holes: 1, sum holes: 48 */
	/* last cacheline: 8 bytes */
};
class Bounds_checked_array<Item_cache*> {
public:

	void Bounds_checked_array(class Bounds_checked_array<Item_cache*> *);

	void Bounds_checked_array(class Bounds_checked_array<Item_cache*> *, class Item_cache * *, size_t);

	void reset(class Bounds_checked_array<Item_cache*> *);

	void reset(class Bounds_checked_array<Item_cache*> *, class Item_cache * *, size_t);

	void resize(class Bounds_checked_array<Item_cache*> *, size_t);

	class Item_cache * & operator[](class Bounds_checked_array<Item_cache*> *, size_t);

	class Item_cache * const & operator[](const class Bounds_checked_array<Item_cache*>  *, size_t);

	typedef class Item_cache * * iterator;

	iterator begin(class Bounds_checked_array<Item_cache*> *);

	iterator end(class Bounds_checked_array<Item_cache*> *);

	typedef class Item_cache * const * const_iterator;

	const_iterator begin(const class Bounds_checked_array<Item_cache*>  *);

	const_iterator end(const class Bounds_checked_array<Item_cache*>  *);

	size_t element_size(const class Bounds_checked_array<Item_cache*>  *);

	size_t size(const class Bounds_checked_array<Item_cache*>  *);

	bool is_null(const class Bounds_checked_array<Item_cache*>  *);

	void pop_front(class Bounds_checked_array<Item_cache*> *);

	class Item_cache * * array(const class Bounds_checked_array<Item_cache*>  *);

	bool operator==(const class Bounds_checked_array<Item_cache*>  *, const class Bounds_checked_array<Item_cache*>  &);

	bool operator!=(const class Bounds_checked_array<Item_cache*>  *, const class Bounds_checked_array<Item_cache*>  &);

	class Item_cache * *       m_array;              /*     0     8 */
	size_t                     m_size;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Date_time_format {
	uchar                      positions[8];         /*     0     8 */
	char                       time_separator;       /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	uint                       flag;                 /*    12     4 */
	LEX_STRING                 format;               /*    16    16 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 29, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct Known_date_time_format {
	const char  *              format_name;          /*     0     8 */
	const char  *              date_format;          /*     8     8 */
	const char  *              datetime_format;      /*    16     8 */
	const char  *              time_format;          /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct st_slave_job_group {
	char *                     group_master_log_name; /*     0     8 */
	my_off_t                   group_master_log_pos; /*     8     8 */
	char *                     group_relay_log_name; /*    16     8 */
	my_off_t                   group_relay_log_pos;  /*    24     8 */
	ulong                      worker_id;            /*    32     8 */
	class Slave_worker *       worker;               /*    40     8 */
	ulonglong                  total_seqno;          /*    48     8 */
	my_off_t                   master_log_pos;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint                       checkpoint_seqno;     /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	my_off_t                   checkpoint_log_pos;   /*    72     8 */
	char *                     checkpoint_log_name;  /*    80     8 */
	my_off_t                   checkpoint_relay_log_pos; /*    88     8 */
	char *                     checkpoint_relay_log_name; /*    96     8 */
	int32                      done;                 /*   104     4 */

	/* XXX 4 bytes hole, try to pack */

	ulong                      shifted;              /*   112     8 */
	time_t                     ts;                   /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	longlong                   last_committed;       /*   128     8 */
	longlong                   sequence_number;      /*   136     8 */
	class Format_description_log_event * new_fd_event; /*   144     8 */
	void reset(class st_slave_job_group *, my_off_t, ulonglong);


	/* size: 152, cachelines: 3, members: 19 */
	/* sum members: 144, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct my_aligned_storage<152, 8> {
	union {
		char                       data[152];            /*     0   152 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	};

	union {
		char               data[152];            /*     0   152 */
		struct my_alignment_imp<8> align __attribute__((__aligned__(8))); /*     0     8 */
	} __attribute__((__aligned__(8)));               /*     0   152 */

	/* size: 152, cachelines: 3, members: 1 */
	/* forced alignments: 1 */
	/* last cacheline: 24 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<st_slave_job_group, 1, true> {
	class st_slave_job_group * cast_rawbuff(class Prealloced_array<st_slave_job_group, 1, true> *);

public:

	void Prealloced_array(class Prealloced_array<st_slave_job_group, 1, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<st_slave_job_group, 1, true> *, const class Prealloced_array<st_slave_job_group, 1, true>  &);

	void Prealloced_array(class Prealloced_array<st_slave_job_group, 1, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const class st_slave_job_group  * const_iterator;

	class Prealloced_array<st_slave_job_group, 1, true> & operator=(class Prealloced_array<st_slave_job_group, 1, true> *, const class Prealloced_array<st_slave_job_group, 1, true>  &);

	void ~Prealloced_array(class Prealloced_array<st_slave_job_group, 1, true> *, int);

	size_t capacity(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	size_t element_size(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	bool empty(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	size_t size(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	class st_slave_job_group & at(class Prealloced_array<st_slave_job_group, 1, true> *, size_t);

	const class st_slave_job_group  & at(const class Prealloced_array<st_slave_job_group, 1, true>  *, size_t);

	class st_slave_job_group & operator[](class Prealloced_array<st_slave_job_group, 1, true> *, size_t);

	const class st_slave_job_group  & operator[](const class Prealloced_array<st_slave_job_group, 1, true>  *, size_t);

	class st_slave_job_group & back(class Prealloced_array<st_slave_job_group, 1, true> *);

	const class st_slave_job_group  & back(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	class st_slave_job_group & front(class Prealloced_array<st_slave_job_group, 1, true> *);

	const class st_slave_job_group  & front(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	typedef class st_slave_job_group * iterator;

	iterator begin(class Prealloced_array<st_slave_job_group, 1, true> *);

	iterator end(class Prealloced_array<st_slave_job_group, 1, true> *);

	const_iterator begin(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	const_iterator end(const class Prealloced_array<st_slave_job_group, 1, true>  *);

	bool reserve(class Prealloced_array<st_slave_job_group, 1, true> *, size_t);

	bool push_back(class Prealloced_array<st_slave_job_group, 1, true> *, const class st_slave_job_group  &);

	void pop_back(class Prealloced_array<st_slave_job_group, 1, true> *);

	iterator insert(class Prealloced_array<st_slave_job_group, 1, true> *, iterator, const value_type  &);

	typedef struct st_slave_job_group value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<st_slave_job_group*, bool> insert_unique(class Prealloced_array<st_slave_job_group, 1, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<st_slave_job_group, 1, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<st_slave_job_group, 1, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<st_slave_job_group, 1, true> *, iterator);

	iterator erase(class Prealloced_array<st_slave_job_group, 1, true> *, size_t);

	void erase_at_end(class Prealloced_array<st_slave_job_group, 1, true> *, iterator);

	iterator erase(class Prealloced_array<st_slave_job_group, 1, true> *, iterator, iterator);

	void swap(class Prealloced_array<st_slave_job_group, 1, true> *, class Prealloced_array<st_slave_job_group, 1, true> &);

	void shrink_to_fit(class Prealloced_array<st_slave_job_group, 1, true> *);

	void resize(class Prealloced_array<st_slave_job_group, 1, true> *, size_t, const class st_slave_job_group  &);

	void clear(class Prealloced_array<st_slave_job_group, 1, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<152, 8> m_buff __attribute__((__aligned__(8))); /*    16   152 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	class st_slave_job_group * m_array_ptr;          /*   168     8 */
	PSI_memory_key             m_psi_key;            /*   176     4 */

	/* size: 184, cachelines: 3, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 56 bytes */
} __attribute__((__aligned__(8)));
class circular_buffer_queue<st_slave_job_group> {
public:

	class Prealloced_array<st_slave_job_group, 1, true> m_Q __attribute__((__aligned__(8))); /*     0   184 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	ulong                      size;                 /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	ulong                      avail;                /*   192     8 */
	ulong                      entry;                /*   200     8 */
	volatile ulong             len;                  /*   208     8 */
	bool                       inited_queue;         /*   216     1 */
	void circular_buffer_queue(class circular_buffer_queue<st_slave_job_group> *, ulong);

	void circular_buffer_queue(class circular_buffer_queue<st_slave_job_group> *);

	void ~circular_buffer_queue(class circular_buffer_queue<st_slave_job_group> *, int);

	ulong de_queue(class circular_buffer_queue<st_slave_job_group> *, class st_slave_job_group *);

	ulong de_tail(class circular_buffer_queue<st_slave_job_group> *, class st_slave_job_group *);

	ulong en_queue(class circular_buffer_queue<st_slave_job_group> *, class st_slave_job_group *);

	class st_slave_job_group * head_queue(class circular_buffer_queue<st_slave_job_group> *);

	bool gt(class circular_buffer_queue<st_slave_job_group> *, ulong, ulong);

	bool in(class circular_buffer_queue<st_slave_job_group> *, ulong);

	bool empty(class circular_buffer_queue<st_slave_job_group> *);

	bool full(class circular_buffer_queue<st_slave_job_group> *);


	/* size: 224, cachelines: 4, members: 6 */
	/* padding: 7 */
	/* paddings: 1, sum paddings: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 32 bytes */
} __attribute__((__aligned__(8)));
class Prealloced_array<long long unsigned int, 1, true> {
	long long unsigned int * cast_rawbuff(class Prealloced_array<long long unsigned int, 1, true> *);

public:

	void Prealloced_array(class Prealloced_array<long long unsigned int, 1, true> *, PSI_memory_key);

	void Prealloced_array(class Prealloced_array<long long unsigned int, 1, true> *, const class Prealloced_array<long long unsigned int, 1, true>  &);

	void Prealloced_array(class Prealloced_array<long long unsigned int, 1, true> *, PSI_memory_key, const_iterator, const_iterator);

	typedef const long long unsigned int  * const_iterator;

	class Prealloced_array<long long unsigned int, 1, true> & operator=(class Prealloced_array<long long unsigned int, 1, true> *, const class Prealloced_array<long long unsigned int, 1, true>  &);

	void ~Prealloced_array(class Prealloced_array<long long unsigned int, 1, true> *, int);

	size_t capacity(const class Prealloced_array<long long unsigned int, 1, true>  *);

	size_t element_size(const class Prealloced_array<long long unsigned int, 1, true>  *);

	bool empty(const class Prealloced_array<long long unsigned int, 1, true>  *);

	size_t size(const class Prealloced_array<long long unsigned int, 1, true>  *);

	long long unsigned int & at(class Prealloced_array<long long unsigned int, 1, true> *, size_t);

	const long long unsigned int  & at(const class Prealloced_array<long long unsigned int, 1, true>  *, size_t);

	long long unsigned int & operator[](class Prealloced_array<long long unsigned int, 1, true> *, size_t);

	const long long unsigned int  & operator[](const class Prealloced_array<long long unsigned int, 1, true>  *, size_t);

	long long unsigned int & back(class Prealloced_array<long long unsigned int, 1, true> *);

	const long long unsigned int  & back(const class Prealloced_array<long long unsigned int, 1, true>  *);

	long long unsigned int & front(class Prealloced_array<long long unsigned int, 1, true> *);

	const long long unsigned int  & front(const class Prealloced_array<long long unsigned int, 1, true>  *);

	typedef long long unsigned int * iterator;

	iterator begin(class Prealloced_array<long long unsigned int, 1, true> *);

	iterator end(class Prealloced_array<long long unsigned int, 1, true> *);

	const_iterator begin(const class Prealloced_array<long long unsigned int, 1, true>  *);

	const_iterator end(const class Prealloced_array<long long unsigned int, 1, true>  *);

	bool reserve(class Prealloced_array<long long unsigned int, 1, true> *, size_t);

	bool push_back(class Prealloced_array<long long unsigned int, 1, true> *, const long long unsigned int  &);

	void pop_back(class Prealloced_array<long long unsigned int, 1, true> *);

	iterator insert(class Prealloced_array<long long unsigned int, 1, true> *, iterator, const value_type  &);

	typedef long long unsigned int value_type;

	/* tag__fprintf: const_type tag not supported! */;

	class pair<long long unsigned int*, bool> insert_unique(class Prealloced_array<long long unsigned int, 1, true> *, const value_type  &);

	typedef size_t size_type;

	size_type erase_unique(class Prealloced_array<long long unsigned int, 1, true> *, const value_type  &);

	size_type count_unique(const class Prealloced_array<long long unsigned int, 1, true>  *, const value_type  &);

	iterator erase(class Prealloced_array<long long unsigned int, 1, true> *, iterator);

	iterator erase(class Prealloced_array<long long unsigned int, 1, true> *, size_t);

	void erase_at_end(class Prealloced_array<long long unsigned int, 1, true> *, iterator);

	iterator erase(class Prealloced_array<long long unsigned int, 1, true> *, iterator, iterator);

	void swap(class Prealloced_array<long long unsigned int, 1, true> *, class Prealloced_array<long long unsigned int, 1, true> &);

	void shrink_to_fit(class Prealloced_array<long long unsigned int, 1, true> *);

	void resize(class Prealloced_array<long long unsigned int, 1, true> *, size_t, const long long unsigned int  &);

	void clear(class Prealloced_array<long long unsigned int, 1, true> *);

	size_t                     m_size;               /*     0     8 */
	size_t                     m_capacity;           /*     8     8 */
	struct my_aligned_storage<8, 8> m_buff __attribute__((__aligned__(8))); /*    16     8 */
	long long unsigned int *   m_array_ptr;          /*    24     8 */
	PSI_memory_key             m_psi_key;            /*    32     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* forced alignments: 1 */
	/* last cacheline: 40 bytes */
} __attribute__((__aligned__(8)));
class Slave_committed_queue : public circular_buffer_queue<st_slave_job_group> {
public:

	/* class circular_buffer_queue<st_slave_job_group> <ancestor>; */ /*     0   224 */

	/* XXX last struct has 7 bytes of padding */
	/* XXX 65529 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) was 25 bytes ago --- */
	bool                       inited;               /*   217     1 */

	/* XXX 6 bytes hole, try to pack */
	void update_current_binlog(class Slave_committed_queue *, const char  *);


	Slave_job_group            lwm;                  /*   224   152 */
	/* --- cacheline 5 boundary (320 bytes) was 56 bytes ago --- */
	class Prealloced_array<long long unsigned int, 1, true> last_done __attribute__((__aligned__(8))); /*   376    40 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 6 boundary (384 bytes) was 32 bytes ago --- */
	ulong                      assigned_group_index; /*   416     8 */
	void Slave_committed_queue(class Slave_committed_queue *, const char  *, ulong, uint);

	void ~Slave_committed_queue(class Slave_committed_queue *, int);

	ulong move_queue_head(class Slave_committed_queue *, Slave_worker_array *);

	void free_dynamic_items(class Slave_committed_queue *);

	Slave_job_group * get_job_group(class Slave_committed_queue *, ulong);

	ulong en_queue(class Slave_committed_queue *, Slave_job_group *);

	ulong de_queue(class Slave_committed_queue *, Slave_job_group *);

	ulong de_tail(class Slave_committed_queue *, Slave_job_group *);

	ulong find_lwm(class Slave_committed_queue *, Slave_job_group * *, ulong);


	/* size: 424, cachelines: 7, members: 5 */
	/* sum members: 201, holes: 2, sum holes: 65535 */
	/* paddings: 2, sum paddings: 11 */
	/* forced alignments: 1 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 424 bytes != 201 (member bytes) + 0 (member bits) + 65535 (byte holes) + 0 (bit holes), diff = -522496 bits */
} __attribute__((__aligned__(8)));
class Commit_order_manager {
	enum order_commit_status {
		OCS_WAIT   = 0,
		OCS_SIGNAL = 1,
		OCS_FINISH = 2,
	};

	struct worker_info {
		uint32                     next;                 /*     0     4 */

		/* XXX 4 bytes hole, try to pack */

		mysql_cond_t               cond;                 /*     8    56 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		enum order_commit_status   status;               /*    64     4 */

		/* size: 72, cachelines: 2, members: 3 */
		/* sum members: 64, holes: 1, sum holes: 4 */
		/* padding: 4 */
		/* last cacheline: 8 bytes */
	};

	/* tag__fprintf: const_type tag not supported! */;

public:

	void Commit_order_manager(class Commit_order_manager *, uint32);

	void ~Commit_order_manager(class Commit_order_manager *, int);

	void register_trx(class Commit_order_manager *, class Slave_worker *);

	bool wait_for_its_turn(class Commit_order_manager *, class Slave_worker *, bool);

	void unregister_trx(class Commit_order_manager *, class Slave_worker *);

	void report_rollback(class Commit_order_manager *, class Slave_worker *);

	void report_commit(class Commit_order_manager *, class Slave_worker *);

	void report_deadlock(class Commit_order_manager *, class Slave_worker *);

	mysql_mutex_t              m_mutex;              /*     0    48 */
	bool                       m_rollback_trx;       /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	class vector<Commit_order_manager::worker_info, std::allocator<Commit_order_manager::worker_info> > m_workers; /*    56    24 */
	uint32                     queue_head;           /*    80     4 */
	uint32                     queue_tail;           /*    84     4 */

	/* Bitfield combined with previous fields */

	static const uint32               QUEUE_EOF = 4294967295; /*     0     0 */
	bool queue_empty(class Commit_order_manager *);

	void queue_pop(class Commit_order_manager *);

	void queue_push(class Commit_order_manager *, uint32);

	uint32 queue_front(class Commit_order_manager *);

	void Commit_order_manager(class Commit_order_manager *, const class Commit_order_manager  &);

	class Commit_order_manager & operator=(class Commit_order_manager *, const class Commit_order_manager  &);


	/* size: 88, cachelines: 2, members: 5, static members: 1 */
	/* sum members: 81, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
class List_iterator<Key_part_spec> : public base_list_iterator {
public:

	/* class base_list_iterator  <ancestor>; */      /*     0    32 */
	void List_iterator(class List_iterator<Key_part_spec> *, class List<Key_part_spec> &);

	void List_iterator(class List_iterator<Key_part_spec> *);

	void init(class List_iterator<Key_part_spec> *, class List<Key_part_spec> &);

	class Key_part_spec * operator++(class List_iterator<Key_part_spec> *, int);

	class Key_part_spec * replace(class List_iterator<Key_part_spec> *, class Key_part_spec *);

	class Key_part_spec * replace(class List_iterator<Key_part_spec> *, class List<Key_part_spec> &);

	void rewind(class List_iterator<Key_part_spec> *);

	void remove(class List_iterator<Key_part_spec> *);

	void after(class List_iterator<Key_part_spec> *, class Key_part_spec *);

	bool after(class List_iterator<Key_part_spec> *, class Key_part_spec *, MEM_ROOT *);

	class Key_part_spec * * ref(class List_iterator<Key_part_spec> *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class List_iterator<Create_field> : public base_list_iterator {
public:

	/* class base_list_iterator  <ancestor>; */      /*     0    32 */
	void List_iterator(class List_iterator<Create_field> *, class List<Create_field> &);

	void List_iterator(class List_iterator<Create_field> *);

	void init(class List_iterator<Create_field> *, class List<Create_field> &);

	class Create_field * operator++(class List_iterator<Create_field> *, int);

	class Create_field * replace(class List_iterator<Create_field> *, class Create_field *);

	class Create_field * replace(class List_iterator<Create_field> *, class List<Create_field> &);

	void rewind(class List_iterator<Create_field> *);

	void remove(class List_iterator<Create_field> *);

	void after(class List_iterator<Create_field> *, class Create_field *);

	bool after(class List_iterator<Create_field> *, class Create_field *, MEM_ROOT *);

	class Create_field * * ref(class List_iterator<Create_field> *);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class base_ilist_iterator<Item_change_record> {
	class base_ilist<Item_change_record> * list;     /*     0     8 */
	class Item_change_record * * el;                 /*     8     8 */
	class Item_change_record * current;              /*    16     8 */
public:

	void base_ilist_iterator(class base_ilist_iterator<Item_change_record> *, class base_ilist<Item_change_record> &);

	class Item_change_record * next(class base_ilist_iterator<Item_change_record> *);


	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
class I_List_iterator<Item_change_record> : public base_ilist_iterator<Item_change_record> {
public:

	/* class base_ilist_iterator<Item_change_record> <ancestor>; */ /*     0    24 */
	void I_List_iterator(class I_List_iterator<Item_change_record> *, class I_List<Item_change_record> &);

	class Item_change_record * operator++(class I_List_iterator<Item_change_record> *, int);


	/* size: 24, cachelines: 1, members: 1 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class List_iterator_fast<Item> : public base_list_iterator {
public:

	/* class base_list_iterator  <ancestor>; */      /*     0    32 */
protected:

	class Item * replace(class List_iterator_fast<Item> *, class Item *);

	class Item * replace(class List_iterator_fast<Item> *, class List<Item> &);

	void remove(class List_iterator_fast<Item> *);

	void after(class List_iterator_fast<Item> *, class Item *);

	class Item * * ref(class List_iterator_fast<Item> *);

public:

	void List_iterator_fast(class List_iterator_fast<Item> *, class List<Item> &);

	void List_iterator_fast(class List_iterator_fast<Item> *);

	void init(class List_iterator_fast<Item> *, class List<Item> &);

	class Item * operator++(class List_iterator_fast<Item> *, int);

	void rewind(class List_iterator_fast<Item> *);

	void sublist(class List_iterator_fast<Item> *, class List<Item> &, uint);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class List_iterator_fast<PT_select_var> : public base_list_iterator {
public:

	/* class base_list_iterator  <ancestor>; */      /*     0    32 */
protected:

	class PT_select_var * replace(class List_iterator_fast<PT_select_var> *, class PT_select_var *);

	class PT_select_var * replace(class List_iterator_fast<PT_select_var> *, class List<PT_select_var> &);

	void remove(class List_iterator_fast<PT_select_var> *);

	void after(class List_iterator_fast<PT_select_var> *, class PT_select_var *);

	class PT_select_var * * ref(class List_iterator_fast<PT_select_var> *);

public:

	void List_iterator_fast(class List_iterator_fast<PT_select_var> *, class List<PT_select_var> &);

	void List_iterator_fast(class List_iterator_fast<PT_select_var> *);

	void init(class List_iterator_fast<PT_select_var> *, class List<PT_select_var> &);

	class PT_select_var * operator++(class List_iterator_fast<PT_select_var> *, int);

	void rewind(class List_iterator_fast<PT_select_var> *);

	void sublist(class List_iterator_fast<PT_select_var> *, class List<PT_select_var> &, uint);


	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class KeyringsLocker {
public:

	class KeyringsLocker & get_instance(void);

	void ~KeyringsLocker(class KeyringsLocker *, int);

	int lock_keyrings(class KeyringsLocker *, class THD *);

	int unlock_keyrings(class KeyringsLocker *, class THD *);

	typedef struct vector<st_plugin_int*, std::allocator<st_plugin_int*> > LockedKeyringsPlugins;

	LockedKeyringsPlugins      locked_keyring_plugins; /*     0    24 */
	void KeyringsLocker(class KeyringsLocker *);

	mysql_mutex_t              mutex;                /*    24    48 */

	/* size: 72, cachelines: 2, members: 2 */
	/* last cacheline: 8 bytes */
};
class Query_dumpvar : public Query_result_interceptor {
public:

	/* class Query_result_interceptor <ancestor>; */ /*     0    32 */
	void Query_dumpvar(class Query_dumpvar *, const class Query_dumpvar  &);

	ha_rows                    row_count;            /*    32     8 */
	class List<PT_select_var> var_list;              /*    40    24 */
	void Query_dumpvar(class Query_dumpvar *);

	virtual void ~Query_dumpvar(class Query_dumpvar *, int);

	virtual int prepare(class Query_dumpvar *, class List<Item> &, SELECT_LEX_UNIT *);

	virtual bool send_data(class Query_dumpvar *, class List<Item> &);

	virtual bool send_eof(class Query_dumpvar *);

	virtual bool check_simple_select(const class Query_dumpvar  *);

	virtual void cleanup(class Query_dumpvar *);

	/* vtable has 5 entries: {
	   [4] = prepare((null)), 
	   [8] = send_data((null)), 
	   [11] = send_eof((null)), 
	   [12] = check_simple_select((null)), 
	   [14] = cleanup((null)), 
	} */
	/* size: 64, cachelines: 1, members: 3 */

	/* BRAIN FART ALERT! 64 bytes != 32 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Query_result_dump : public Query_result_to_file {
public:

	/* class Query_result_to_file <ancestor>; */     /*     0   848 */
	void Query_result_dump(class Query_result_dump *, const class Query_result_dump  &);

	void Query_result_dump(class Query_result_dump *, class sql_exchange *);

	virtual int prepare(class Query_result_dump *, class List<Item> &, SELECT_LEX_UNIT *);

	virtual bool send_data(class Query_result_dump *, class List<Item> &);

	virtual void ~Query_result_dump(class Query_result_dump *, int);

	/* vtable has 2 entries: {
	   [4] = prepare((null)), 
	   [8] = send_data((null)), 
	} */
	/* size: 848, cachelines: 14, members: 1 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 848 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 6784 bits */
};
class Query_result_to_file : public Query_result_interceptor {
public:

	/* class Query_result_interceptor <ancestor>; */ /*     0    32 */
	void Query_result_to_file(class Query_result_to_file *, const class Query_result_to_file  &);

protected:

	class sql_exchange *       exchange;             /*    32     8 */
	File                       file;                 /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	IO_CACHE                   cache;                /*    48   280 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	ha_rows                    row_count;            /*   328     8 */
	char                       path[512];            /*   336   512 */
public:

	void Query_result_to_file(class Query_result_to_file *, class sql_exchange *);

	virtual void ~Query_result_to_file(class Query_result_to_file *, int);

	virtual void send_error(class Query_result_to_file *, uint, const char  *);

	virtual bool send_eof(class Query_result_to_file *);

	virtual void cleanup(class Query_result_to_file *);

	/* vtable has 3 entries: {
	   [10] = send_error((null)), 
	   [11] = send_eof((null)), 
	   [14] = cleanup((null)), 
	} */
	/* size: 848, cachelines: 14, members: 6 */
	/* sum members: 812, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 848 bytes != 812 (member bytes) + 0 (member bits) + 4 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Query_result_export : public Query_result_to_file {
public:

	/* class Query_result_to_file <ancestor>; */     /*     0   848 */
	void Query_result_export(class Query_result_export *, const class Query_result_export  &);

	/* --- cacheline 13 boundary (832 bytes) was 16 bytes ago --- */
	size_t                     field_term_length;    /*   848     8 */
	int                        field_sep_char;       /*   856     4 */
	int                        escape_char;          /*   860     4 */
	int                        line_sep_char;        /*   864     4 */
	int                        field_term_char;      /*   868     4 */
	bool                       is_ambiguous_field_sep; /*   872     1 */
	bool                       is_ambiguous_field_term; /*   873     1 */
	bool                       is_unsafe_field_sep;  /*   874     1 */
	bool                       fixed_row_size;       /*   875     1 */

	/* XXX 4 bytes hole, try to pack */

	const CHARSET_INFO  *      write_cs;             /*   880     8 */
	void Query_result_export(class Query_result_export *, class sql_exchange *);

	virtual void ~Query_result_export(class Query_result_export *, int);

	virtual int prepare(class Query_result_export *, class List<Item> &, SELECT_LEX_UNIT *);

	virtual bool send_data(class Query_result_export *, class List<Item> &);

	/* vtable has 2 entries: {
	   [4] = prepare((null)), 
	   [8] = send_data((null)), 
	} */
	/* size: 888, cachelines: 14, members: 11 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 888 bytes != 36 (member bytes) + 0 (member bits) + 4 (byte holes) + 0 (bit holes), diff = 6784 bits */
};
class Query_result_send : public Query_result {
public:

	/* class Query_result        <ancestor>; */      /*     0    32 */
	void Query_result_send(class Query_result_send *, const class Query_result_send  &);

	bool                       is_result_set_started; /*    32     1 */
	void Query_result_send(class Query_result_send *);

	virtual bool send_result_set_metadata(class Query_result_send *, class List<Item> &, uint);

	virtual bool send_data(class Query_result_send *, class List<Item> &);

	virtual bool send_eof(class Query_result_send *);

	virtual bool check_simple_select(const class Query_result_send  *);

	virtual void abort_result_set(class Query_result_send *);

	virtual void cleanup(class Query_result_send *);

	virtual void ~Query_result_send(class Query_result_send *, int);

	/* vtable has 6 entries: {
	   [7] = send_result_set_metadata((null)), 
	   [8] = send_data((null)), 
	   [11] = send_eof((null)), 
	   [12] = check_simple_select((null)), 
	   [13] = abort_result_set((null)), 
	   [14] = cleanup((null)), 
	} */
	/* size: 40, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 40 bytes != 1 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 256 bits */
};
class Internal_error_handler {
public:

	void Internal_error_handler(class Internal_error_handler *, const class Internal_error_handler  &);

	int ()(void) * *           _vptr.Internal_error_handler; /*     0     8 */
protected:

	void Internal_error_handler(class Internal_error_handler *);

	virtual void ~Internal_error_handler(class Internal_error_handler *, int);

public:

	virtual bool handle_condition(class Internal_error_handler *, class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	class Internal_error_handler * m_prev_internal_handler; /*     8     8 */
	/* vtable has 1 entries: {
	   [2] = handle_condition((null)), 
	} */
	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Drop_table_error_handler : public Internal_error_handler {
public:

	/* class Internal_error_handler <ancestor>; */   /*     0    16 */
	virtual bool handle_condition(class Drop_table_error_handler *, class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	virtual void ~Drop_table_error_handler(class Drop_table_error_handler *, int);

	/* vtable has 1 entries: {
	   [2] = handle_condition((null)), 
	} */
	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */

	/* BRAIN FART ALERT! 16 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class No_such_table_error_handler : public Internal_error_handler {
public:

	/* class Internal_error_handler <ancestor>; */   /*     0    16 */
	void No_such_table_error_handler(class No_such_table_error_handler *);

	virtual bool handle_condition(class No_such_table_error_handler *, class THD *, uint, const char  *, enum enum_severity_level *, const char  *);

	bool safely_trapped_errors(const class No_such_table_error_handler  *);

	int                        m_handled_errors;     /*    16     4 */
	int                        m_unhandled_errors;   /*    20     4 */
	virtual void ~No_such_table_error_handler(class No_such_table_error_handler *, int);

	/* vtable has 1 entries: {
	   [2] = handle_condition((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 8 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 128 bits */
};
class PT_select_sp_var : public PT_select_var {
public:

	/* class PT_select_var       <ancestor>; */      /*     0    24 */
	uint                       offset;               /*    24     4 */
	void PT_select_sp_var(class PT_select_sp_var *, const LEX_STRING  &);

	virtual bool is_local(const class PT_select_sp_var  *);

	virtual uint get_offset(const class PT_select_sp_var  *);

	virtual bool contextualize(class PT_select_sp_var *, class Parse_context *);

	virtual void ~PT_select_sp_var(class PT_select_sp_var *, int);

	/* vtable has 3 entries: {
	   [4] = is_local((null)), 
	   [5] = get_offset((null)), 
	   [2] = contextualize((null)), 
	} */
	/* size: 32, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */

	/* BRAIN FART ALERT! 32 bytes != 4 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 192 bits */
};
class PT_transaction_characteristic : public Parse_tree_node {
public:

	/* class Parse_tree_node     <ancestor>; */      /*     0     8 */
	void PT_transaction_characteristic(class PT_transaction_characteristic *, const class PT_transaction_characteristic  &);

	const char  *              name;                 /*     8     8 */
	int32                      value;                /*    16     4 */
	void PT_transaction_characteristic(class PT_transaction_characteristic *, const char  *, int32);

	virtual bool contextualize(class PT_transaction_characteristic *, class Parse_context *);

	virtual void ~PT_transaction_characteristic(class PT_transaction_characteristic *, int);

	/* vtable has 1 entries: {
	   [2] = contextualize((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 12 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class Sql_cmd : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */

	int ()(void) * *           _vptr.Sql_cmd;        /*     0     8 */
	void Sql_cmd(class Sql_cmd *, const class Sql_cmd  &);

	void operator=(class Sql_cmd *, class Sql_cmd &);

	virtual enum enum_sql_command sql_command_code(const class Sql_cmd  *);

	virtual bool execute(class Sql_cmd *, class THD *);

	virtual void cleanup(class Sql_cmd *, class THD *);

protected:

	void Sql_cmd(class Sql_cmd *);

	virtual void ~Sql_cmd(class Sql_cmd *, int);

	/* vtable has 3 entries: {
	   [0] = sql_command_code((null)), 
	   [1] = execute((null)), 
	   [2] = cleanup((null)), 
	} */
	/* size: 8, cachelines: 1, members: 2 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 8 bytes */
};
class Find_thd_with_id : public Find_THD_Impl {
public:

	/* class Find_THD_Impl       <ancestor>; */      /*     0     8 */
	void Find_thd_with_id(class Find_thd_with_id *, const class Find_thd_with_id  &);

	void Find_thd_with_id(class Find_thd_with_id *, ulong, bool);

	virtual bool operator()(class Find_thd_with_id *, class THD *);

	ulong                      m_id;                 /*     8     8 */
	const bool                 m_daemon_allowed;     /*    16     1 */
	virtual void ~Find_thd_with_id(class Find_thd_with_id *, int);

	/* vtable has 1 entries: {
	   [2] = operator()((null)), 
	} */
	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */

	/* BRAIN FART ALERT! 24 bytes != 9 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 64 bits */
};
class Object_creation_ctx {
public:

	void Object_creation_ctx(class Object_creation_ctx *, const class Object_creation_ctx  &);

	int ()(void) * *           _vptr.Object_creation_ctx; /*     0     8 */
	class Object_creation_ctx * set_n_backup(class Object_creation_ctx *, class THD *);

	void restore_env(class Object_creation_ctx *, class THD *, class Object_creation_ctx *);

protected:

	void Object_creation_ctx(class Object_creation_ctx *);

	virtual class Object_creation_ctx * create_backup_ctx(const class Object_creation_ctx  *, class THD *);

	virtual void change_env(const class Object_creation_ctx  *, class THD *);

public:

	virtual void ~Object_creation_ctx(class Object_creation_ctx *, int);

	/* vtable has 2 entries: {
	   [0] = create_backup_ctx((null)), 
	   [1] = change_env((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Parse_tree_item : public Item {
public:

	/* class Item                <ancestor>; */      /*     0     0 */
	void Parse_tree_item(class Parse_tree_item *, const POS  &);

	virtual enum Type type(const class Parse_tree_item  *);

	virtual double val_real(class Parse_tree_item *);

	virtual longlong val_int(class Parse_tree_item *);

	virtual class String * val_str(class Parse_tree_item *, class String *);

	virtual class my_decimal * val_decimal(class Parse_tree_item *, class my_decimal *);

	virtual bool get_date(class Parse_tree_item *, MYSQL_TIME *, uint);

	virtual bool get_time(class Parse_tree_item *, MYSQL_TIME *);

	virtual void ~Parse_tree_item(class Parse_tree_item *, int);

	/* vtable has 7 entries: {
	   [21] = type((null)), 
	   [24] = val_real((null)), 
	   [25] = val_int((null)), 
	   [28] = val_str((null)), 
	   [30] = val_decimal((null)), 
	   [59] = get_date((null)), 
	   [60] = get_time((null)), 
	} */
	/* size: 152, cachelines: 3, members: 1 */
	/* padding: 152 */
	/* last cacheline: 24 bytes */
};
class Foreign_key : public Key {
public:

	/* class Key                 <ancestor>; */      /*     0   120 */

	/* XXX last struct has 7 bytes of padding */
	void Foreign_key(class Foreign_key *, const class Foreign_key  &);


	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	LEX_CSTRING                ref_db;               /*   120    16 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	LEX_CSTRING                ref_table;            /*   136    16 */
	class List<Key_part_spec> ref_columns;           /*   152    24 */
	uint                       delete_opt;           /*   176     4 */
	uint                       update_opt;           /*   180     4 */
	uint                       match_opt;            /*   184     4 */
	void Foreign_key(class Foreign_key *, const LEX_STRING  &, class List<Key_part_spec> &, const LEX_CSTRING  &, const LEX_CSTRING  &, class List<Key_part_spec> &, uint, uint, uint);

	void Foreign_key(class Foreign_key *, const class Foreign_key  &, MEM_ROOT *);

	virtual class Key * clone(const class Foreign_key  *, MEM_ROOT *);

	bool validate(class Foreign_key *, class List<Create_field> &);

	virtual void ~Foreign_key(class Foreign_key *, int);

	/* vtable has 1 entries: {
	   [2] = clone((null)), 
	} */
	/* size: 192, cachelines: 3, members: 7 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 7 */

	/* BRAIN FART ALERT! 192 bytes != 68 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 960 bits */
};
class Rpl_transaction_ctx {
public:

	void Rpl_transaction_ctx(class Rpl_transaction_ctx *, const class Rpl_transaction_ctx  &);

	int ()(void) * *           _vptr.Rpl_transaction_ctx; /*     0     8 */
	void Rpl_transaction_ctx(class Rpl_transaction_ctx *);

	virtual void ~Rpl_transaction_ctx(class Rpl_transaction_ctx *, int);

	int set_rpl_transaction_ctx(class Rpl_transaction_ctx *, Transaction_termination_ctx);

	bool is_transaction_rollback(class Rpl_transaction_ctx *);

	bool is_generated_gtid(class Rpl_transaction_ctx *);

	int get_sidno(class Rpl_transaction_ctx *);

	long long int get_gno(class Rpl_transaction_ctx *);

	void cleanup(class Rpl_transaction_ctx *);

	Transaction_termination_ctx m_transaction_ctx;   /*     8    32 */

	/* size: 40, cachelines: 1, members: 2 */
	/* last cacheline: 40 bytes */
};
class Rpl_transaction_write_set_ctx {
public:

	void Rpl_transaction_write_set_ctx(class Rpl_transaction_write_set_ctx *, const class Rpl_transaction_write_set_ctx  &);

	int ()(void) * *           _vptr.Rpl_transaction_write_set_ctx; /*     0     8 */
	void Rpl_transaction_write_set_ctx(class Rpl_transaction_write_set_ctx *);

	virtual void ~Rpl_transaction_write_set_ctx(class Rpl_transaction_write_set_ctx *, int);

	bool add_write_set(class Rpl_transaction_write_set_ctx *, uint64);

	class set<long long unsigned int, std::less<long long unsigned int>, std::allocator<long long unsigned int> > * get_write_set(class Rpl_transaction_write_set_ctx *);

	void reset_state(class Rpl_transaction_write_set_ctx *);

	void set_has_missing_keys(class Rpl_transaction_write_set_ctx *);

	bool get_has_missing_keys(class Rpl_transaction_write_set_ctx *);

	void set_has_related_foreign_keys(class Rpl_transaction_write_set_ctx *);

	bool get_has_related_foreign_keys(class Rpl_transaction_write_set_ctx *);

	bool was_write_set_limit_reached(class Rpl_transaction_write_set_ctx *);

	size_t write_set_memory_size(class Rpl_transaction_write_set_ctx *);

	void add_savepoint(class Rpl_transaction_write_set_ctx *, char *);

	void del_savepoint(class Rpl_transaction_write_set_ctx *, char *);

	void rollback_to_savepoint(class Rpl_transaction_write_set_ctx *, char *);

	void reset_savepoint_list(class Rpl_transaction_write_set_ctx *);

	void restore_savepoint_list(class Rpl_transaction_write_set_ctx *);

	void set_global_write_set_memory_size_limit(int64);

	void update_global_write_set_memory_size_limit(int64);

	void set_global_require_full_write_set(bool);

	void set_local_ignore_write_set_memory_limit(class Rpl_transaction_write_set_ctx *, bool);

	void set_local_allow_drop_write_set(class Rpl_transaction_write_set_ctx *, bool);

	void clear_write_set(class Rpl_transaction_write_set_ctx *);

	class vector<long long unsigned int, std::allocator<long long unsigned int> > write_set; /*     8    24 */
	class set<long long unsigned int, std::less<long long unsigned int>, std::allocator<long long unsigned int> > write_set_unique; /*    32    48 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	bool                       m_has_missing_keys;   /*    80     1 */
	bool                       m_has_related_foreign_keys; /*    81     1 */

	/* XXX 6 bytes hole, try to pack */

	class map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > savepoint; /*    88    48 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	class list<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > >, std::allocator<std::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > > > savepoint_list; /*   136    24 */

	/* Bitfield combined with previous fields */

	static int32                      m_global_component_requires_write_sets; /*     0     0 */
	static int64                      m_global_write_set_memory_size_limit; /*     0     0 */
	bool                       m_ignore_write_set_memory_limit; /*   160     1 */
	bool                       m_local_allow_drop_write_set; /*   161     1 */
	bool                       m_local_has_reached_write_set_limit; /*   162     1 */

	/* size: 168, cachelines: 3, members: 10, static members: 2 */
	/* sum members: 157, holes: 1, sum holes: 6 */
	/* padding: 5 */
	/* last cacheline: 40 bytes */
};
class Item_var_func : public Item_func {
public:

	/* class Item_func           <ancestor>; */      /*     0     0 */
	void Item_var_func(class Item_var_func *, const class Item_var_func  &);

	void Item_var_func(class Item_var_func *);

	void Item_var_func(class Item_var_func *, const POS  &);

	void Item_var_func(class Item_var_func *, class THD *, class Item_var_func *);

	void Item_var_func(class Item_var_func *, class Item *);

	void Item_var_func(class Item_var_func *, const POS  &, class Item *);

	virtual bool get_date(class Item_var_func *, MYSQL_TIME *, my_time_flags_t);

	virtual bool get_time(class Item_var_func *, MYSQL_TIME *);

	virtual bool check_gcol_func_processor(class Item_var_func *, uchar *);

	virtual void ~Item_var_func(class Item_var_func *, int);

	/* vtable has 3 entries: {
	   [59] = get_date((null)), 
	   [60] = get_time((null)), 
	   [122] = check_gcol_func_processor((null)), 
	} */
	/* size: 216, cachelines: 4, members: 1 */
	/* padding: 216 */
	/* last cacheline: 24 bytes */
};
class Item_func_instr : public Item_func_locate {
public:

	/* class Item_func_locate    <ancestor>; */      /*     0     0 */
	void Item_func_instr(class Item_func_instr *, const POS  &, class Item *, class Item *);

	virtual const char  * func_name(const class Item_func_instr  *);

	virtual void ~Item_func_instr(class Item_func_instr *, int);

	/* vtable has 1 entries: {
	   [152] = func_name((null)), 
	} */
	/* size: 296, cachelines: 5, members: 1 */
	/* padding: 296 */
	/* last cacheline: 40 bytes */
};
class Item_func_bit_length : public Item_func_length {
public:

	/* class Item_func_length    <ancestor>; */      /*     0     0 */
	void Item_func_bit_length(class Item_func_bit_length *, const POS  &, class Item *);

	virtual longlong val_int(class Item_func_bit_length *);

	virtual const char  * func_name(const class Item_func_bit_length  *);

	virtual void ~Item_func_bit_length(class Item_func_bit_length *, int);

	/* vtable has 2 entries: {
	   [25] = val_int((null)), 
	   [152] = func_name((null)), 
	} */
	/* size: 248, cachelines: 4, members: 1 */
	/* padding: 248 */
	/* last cacheline: 56 bytes */
};
class Item_func_max : public Item_func_min_max {
public:

	/* class Item_func_min_max   <ancestor>; */      /*     0     0 */
	void Item_func_max(class Item_func_max *, const POS  &, class PT_item_list *);

	virtual const char  * func_name(const class Item_func_max  *);

	virtual void ~Item_func_max(class Item_func_max *, int);

	/* vtable has 1 entries: {
	   [152] = func_name((null)), 
	} */
	/* size: 272, cachelines: 5, members: 1 */
	/* padding: 272 */
	/* last cacheline: 16 bytes */
};
class Item_func_min : public Item_func_min_max {
public:

	/* class Item_func_min_max   <ancestor>; */      /*     0     0 */
	void Item_func_min(class Item_func_min *, const POS  &, class PT_item_list *);

	virtual const char  * func_name(const class Item_func_min  *);

	virtual void ~Item_func_min(class Item_func_min *, int);

	/* vtable has 1 entries: {
	   [152] = func_name((null)), 
	} */
	/* size: 272, cachelines: 5, members: 1 */
	/* padding: 272 */
	/* last cacheline: 16 bytes */
};
class Item_func_longfromgeohash : public Item_func_latlongfromgeohash {
public:

	/* class Item_func_latlongfromgeohash <ancestor>; */ /*     0     0 */
	void Item_func_longfromgeohash(class Item_func_longfromgeohash *, const POS  &, class Item *);

	virtual const char  * func_name(const class Item_func_longfromgeohash  *);

	virtual void ~Item_func_longfromgeohash(class Item_func_longfromgeohash *, int);

	/* vtable has 1 entries: {
	   [152] = func_name((null)), 
	} */
	/* size: 256, cachelines: 4, members: 1 */
	/* padding: 256 */
};
class Item_func_latfromgeohash : public Item_func_latlongfromgeohash {
public:

	/* class Item_func_latlongfromgeohash <ancestor>; */ /*     0     0 */
	void Item_func_latfromgeohash(class Item_func_latfromgeohash *, const POS  &, class Item *);

	virtual const char  * func_name(const class Item_func_latfromgeohash  *);

	virtual void ~Item_func_latfromgeohash(class Item_func_latfromgeohash *, int);

	/* vtable has 1 entries: {
	   [152] = func_name((null)), 
	} */
	/* size: 256, cachelines: 4, members: 1 */
	/* padding: 256 */
};
class Diagnostics_information_item : public Sql_alloc {
public:

	/* class Sql_alloc           <ancestor>; */      /*     0     0 */

	/* XXX last struct has 1 byte of padding */
	void Diagnostics_information_item(class Diagnostics_information_item *, const class Diagnostics_information_item  &);


	int ()(void) * *           _vptr.Diagnostics_information_item; /*     0     8 */
	bool set_value(class Diagnostics_information_item *, class THD *, class Item * *);

protected:

	void Diagnostics_information_item(class Diagnostics_information_item *, class Item *);

	virtual void ~Diagnostics_information_item(class Diagnostics_information_item *, int);

	class Item *               m_target;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* paddings: 1, sum paddings: 1 */
	/* last cacheline: 16 bytes */
};
class Item_copy : public Item {
public:

	/* class Item                <ancestor>; */      /*     0     0 */

	/* XXX 148 bytes hole, try to pack */
	void Item_copy(class Item_copy *, const class Item_copy  &);

protected:


	/* --- cacheline 2 boundary (128 bytes) was 20 bytes ago --- */
	enum enum_field_types      cached_field_type;    /*   148     4 */
	class Item *               item;                 /*   152     8 */
	enum Item_result           cached_result_type;   /*   160     4 */
	void Item_copy(class Item_copy *, class Item *);

	virtual enum type_conversion_status save_in_field_inner(class Item_copy *, class Field *, bool);

public:

	class Item_copy * create(class Item *);

	virtual bool copy(class Item_copy *, const class THD  *);

	class Item * get_item(class Item_copy *);

	virtual enum Type type(const class Item_copy  *);

	virtual enum_field_types field_type(const class Item_copy  *);

	virtual enum Item_result result_type(const class Item_copy  *);

	virtual void make_field(class Item_copy *, class Send_field *);

	virtual table_map used_tables(const class Item_copy  *);

	virtual bool const_item(const class Item_copy  *);

	virtual bool is_null(class Item_copy *);

	virtual void no_rows_in_result(class Item_copy *);

	virtual class String * val_str(class Item_copy *, class String *);

	virtual class my_decimal * val_decimal(class Item_copy *, class my_decimal *);

	virtual double val_real(class Item_copy *);

	virtual longlong val_int(class Item_copy *);

	virtual bool get_date(class Item_copy *, MYSQL_TIME *, my_time_flags_t);

	virtual bool get_time(class Item_copy *, MYSQL_TIME *);

	virtual bool val_json(class Item_copy *, class Json_wrapper *);

	virtual void ~Item_copy(class Item_copy *, int);

	/* vtable has 17 entries: {
	   [11] = save_in_field_inner((null)), 
	   [151] = copy((null)), 
	   [21] = type((null)), 
	   [20] = field_type((null)), 
	   [16] = result_type((null)), 
	   [7] = make_field((null)), 
	   [46] = used_tables((null)), 
	   [54] = const_item((null)), 
	   [63] = is_null((null)), 
	   [70] = no_rows_in_result((null)), 
	   [28] = val_str((null)), 
	   [30] = val_decimal((null)), 
	   [24] = val_real((null)), 
	   [25] = val_int((null)), 
	   [59] = get_date((null)), 
	   [60] = get_time((null)), 
	   [33] = val_json((null)), 
	} */
	/* size: 168, cachelines: 3, members: 4 */
	/* sum members: 16, holes: 1, sum holes: 148 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
class Item_bin_string : public Item_hex_string {
public:

	/* class Item_hex_string     <ancestor>; */      /*     0     0 */
	void Item_bin_string(class Item_bin_string *, const char  *, size_t);

	void Item_bin_string(class Item_bin_string *, const POS  &, const LEX_STRING  &);

	LEX_STRING make_bin_str(const char  *, size_t);

	void bin_string_init(class Item_bin_string *, const char  *, size_t);

	virtual void ~Item_bin_string(class Item_bin_string *, int);


	/* size: 160, cachelines: 3, members: 1 */
	/* padding: 160 */
	/* last cacheline: 32 bytes */
};
class Item_return_int : public Item_int {
public:

	/* class Item_int            <ancestor>; */      /*     0     0 */

	/* XXX 168 bytes hole, try to pack */
	void Item_return_int(class Item_return_int *, const class Item_return_int  &);


	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	enum_field_types           int_field_type;       /*   168     4 */
	void Item_return_int(class Item_return_int *, const char  *, uint, enum_field_types, longlong);

	virtual enum_field_types field_type(const class Item_return_int  *);

	virtual void ~Item_return_int(class Item_return_int *, int);

	/* vtable has 1 entries: {
	   [20] = field_type((null)), 
	} */
	/* size: 176, cachelines: 3, members: 2 */
	/* sum members: 4, holes: 1, sum holes: 168 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
class Item_blob : public Item_partition_func_safe_string {
public:

	/* class Item_partition_func_safe_string <ancestor>; */ /*     0   168 */

	/* XXX last struct has 168 bytes of padding */
	void Item_blob(class Item_blob *, const char  *, size_t);

	virtual enum Type type(const class Item_blob  *);

	virtual enum_field_types field_type(const class Item_blob  *);

	virtual void ~Item_blob(class Item_blob *, int);

	/* vtable has 2 entries: {
	   [21] = type((null)), 
	   [20] = field_type((null)), 
	} */
	/* size: 168, cachelines: 3, members: 1 */
	/* paddings: 1, sum paddings: 168 */
	/* last cacheline: 40 bytes */

	/* BRAIN FART ALERT! 168 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 1344 bits */
};
class Item_partition_func_safe_string : public Item_string {
public:

	/* class Item_string         <ancestor>; */      /*     0     0 */
	void Item_partition_func_safe_string(class Item_partition_func_safe_string *, const class Item_partition_func_safe_string  &);

	void Item_partition_func_safe_string(class Item_partition_func_safe_string *, class Name_string, size_t, const CHARSET_INFO  *);

	virtual void ~Item_partition_func_safe_string(class Item_partition_func_safe_string *, int);


	/* size: 168, cachelines: 3, members: 1 */
	/* padding: 168 */
	/* last cacheline: 40 bytes */
};
class Item_int_0 : public Item_int {
public:

	/* class Item_int            <ancestor>; */      /*     0     0 */
	void Item_int_0(class Item_int_0 *);

	void Item_int_0(class Item_int_0 *, const POS  &);

	virtual void ~Item_int_0(class Item_int_0 *, int);


	/* size: 168, cachelines: 3, members: 1 */
	/* padding: 168 */
	/* last cacheline: 40 bytes */
};
class Item_null_result : public Item_null {
public:

	/* class Item_null           <ancestor>; */      /*     0     0 */

	/* XXX 160 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	enum_field_types           fld_type;             /*   160     4 */
	enum Item_result           res_type;             /*   164     4 */
	class Field *              result_field;         /*   168     8 */
	void Item_null_result(class Item_null_result *, enum_field_types, enum Item_result);

	virtual bool is_result_field(class Item_null_result *);

	virtual void save_in_result_field(class Item_null_result *, bool);

	virtual bool check_partition_func_processor(class Item_null_result *, uchar *);

	virtual enum_field_types field_type(const class Item_null_result  *);

	virtual enum Item_result result_type(const class Item_null_result  *);

	virtual bool check_gcol_func_processor(class Item_null_result *, uchar *);

	virtual void ~Item_null_result(class Item_null_result *, int);

	/* vtable has 6 entries: {
	   [67] = is_result_field((null)), 
	   [69] = save_in_result_field((null)), 
	   [113] = check_partition_func_processor((null)), 
	   [20] = field_type((null)), 
	   [16] = result_type((null)), 
	   [122] = check_gcol_func_processor((null)), 
	} */
	/* size: 176, cachelines: 3, members: 4 */
	/* sum members: 16, holes: 1, sum holes: 160 */
	/* last cacheline: 48 bytes */
};
class Item_basic_constant : public Item {
public:

	/* class Item                <ancestor>; */      /*     0     0 */

	/* XXX 152 bytes hole, try to pack */
	void Item_basic_constant(class Item_basic_constant *, const class Item_basic_constant  &);


	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	table_map                  used_table_map;       /*   152     8 */
	void Item_basic_constant(class Item_basic_constant *);

	void Item_basic_constant(class Item_basic_constant *, const POS  &);

	void set_used_tables(class Item_basic_constant *, table_map);

	virtual table_map used_tables(const class Item_basic_constant  *);

	virtual bool check_gcol_func_processor(class Item_basic_constant *, uchar *);

	virtual void cleanup(class Item_basic_constant *);

	virtual void ~Item_basic_constant(class Item_basic_constant *, int);

	/* vtable has 3 entries: {
	   [46] = used_tables((null)), 
	   [122] = check_gcol_func_processor((null)), 
	   [6] = cleanup((null)), 
	} */
	/* size: 160, cachelines: 3, members: 2 */
	/* sum members: 8, holes: 1, sum holes: 152 */
	/* last cacheline: 32 bytes */
};
class Settable_routine_parameter {
public:

	void Settable_routine_parameter(class Settable_routine_parameter *, const class Settable_routine_parameter  &);

	int ()(void) * *           _vptr.Settable_routine_parameter; /*     0     8 */
	void Settable_routine_parameter(class Settable_routine_parameter *);

	virtual void ~Settable_routine_parameter(class Settable_routine_parameter *, int);

	virtual void set_required_privilege(class Settable_routine_parameter *, bool);

	virtual bool set_value(class Settable_routine_parameter *, class THD *, class sp_rcontext *, class Item * *);

	virtual void set_out_param_info(class Settable_routine_parameter *, class Send_field *);

	virtual const class Send_field  * get_out_param_info(const class Settable_routine_parameter  *);

	/* vtable has 4 entries: {
	   [2] = set_required_privilege((null)), 
	   [3] = set_value((null)), 
	   [4] = set_out_param_info((null)), 
	   [5] = get_out_param_info((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
class Proto_field {
public:

	void Proto_field(class Proto_field *, const class Proto_field  &);

	void Proto_field(class Proto_field *);

	void ~Proto_field(class Proto_field *, int);

	int ()(void) * *           _vptr.Proto_field;    /*     0     8 */
	virtual bool send_binary(class Proto_field *, class Protocol *);

	virtual bool send_text(class Proto_field *, class Protocol *);

	/* vtable has 2 entries: {
	   [0] = send_binary((null)), 
	   [1] = send_text((null)), 
	} */
	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
